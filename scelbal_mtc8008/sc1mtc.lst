AS8 assembler for intel 8008, t.e.jones Version 1.0
Options: listfile=1 debug=0 binaryout=1 singlelist=0
octalnums=1 markascii=1
Infile=sc1mtc.asm
Assembly Performed: Fri Sep 24 16:44:27 2021


Line Addr.  CodeBytes   Source Line
---- ------ ----------- ----------------------------------
   1                    ;;; This is the Scelbi Basic Program from 1974 known as
   2                    ;;; SCELBAL by Mark G. Arnold (MGA) and Nat Wadsworth  
   3                    ;;;
   4                    ;;;  Copyright 1975 Scelbi Computer Consulting, Inc.
   5                    ;;;  All rights reserved
   6                    ;;;
   7                    ;;; MGA gives permission to use SCELBAL for 
   8                    ;;; educational, historical, non-commercial purposes.
   9                    ;;; Versions of this have been circulating on the web since
  10                    ;;; about 2000; this version is authorized by MGA (Mar 2012)
  11                    ;;; with the understanding no warranty is expressed or implied.
  12                    ;;; As stated in the original, "no responsibility is assumed for
  13                    ;;; for inaccuracies or for the success or failure of
  14                    ;;; various applications to which the information herein
  15                    ;;; may be applied."
  16                    ;;; 
  17                    ;;; SCELBAL is the only open-source, floating-point 
  18                    ;;; high-level language ever implemented on Intel's first
  19                    ;;; general-purpose microprocessor, the 8008.  It was
  20                    ;;; published in book form:
  21                    ;;;
  22                    ;;;  SCELBAL: A Higher-Level Language for 8008/8080 Systems
  23                    ;;;
  24                    ;;; (Tiny BASIC only used 16-bit integers; the MCM\70
  25                    ;;; was a closed system; calculators implemented with 8008
  26                    ;;; were floating-point, but not high-level.)
  27                    ;;;
  28                    ;;; This version is modified to assemble with the
  29                    ;;; as8 assembler (using the -octal option) 
  30                    ;;; for the Intel 8008 by Thomas E. Jones.
  31                    ;;; This current form is made up non-relocatable so that
  32                    ;;; locations of all code and data is identical to the
  33                    ;;; original SCELBAL documents and patches.  It should be
  34                    ;;; reasonable after debugging code to convert this to a
  35                    ;;; relocatable and ROMable code with variables in RAM.
  36                    ;;; This code originates from a version made by 
  37                    ;;;
  38                    ;;;    Steve Loboyko in 2001.
  39                    ;;;
  40                    ;;; This version has all 3 patches for SCELBAL (the two
  41                    ;;; pasted in the original manual, and a third which was
  42                    ;;; written in SCELBAL UPDATE publication, as well as
  43                    ;;; a couple changes to constants which didn't actually
  44                    ;;; require a patch, just changes to bytes of data or
  45                    ;;; arguments to an instruction--one of these (Tucker) was 
  46                    ;;; incorrect and restored to original by MGA March 2012).
  47                    ;;; 
  48                    ;;; This comment must be incorporated with any version of SCELBAL
  49                    ;;; downloaded, distributed, posted or disemenated.
  50                    ;;;
  51                    ;;; Modified to run on a simulated 8008 based process monitoring
  52                    ;;; computer (promoncomp) that was made as a master thesis work
  53                    ;;; in 1975. The simulator is based on SIMH.
  54                    
  55                    ENDPGRAM:  EQU 055       ;MGA 4/10/12 as in orig; for his ROMable Loboyko said 077       [077]
  56                    BGNPGRAM:  EQU 033       ;MGA 4/10/12 as in orig; for his ROMable Loboyko said 044       [044]
  57                    	
  58                    ;;; Here are labels originally attempting to make the code
  59                    ;;; relocatable.  These 4 pages contain variable data
  60                    ;;; which needs to be relocated from ROM to RAM.
  61                    ;;; I can't vouch for ALL references to these pages in
  62                    ;;; the code being switched to these labels, but they
  63                    ;;; seem to be.
  64                    	
  65                    OLDPG1:		EQU	001#000
  66                    OLDPG26:	EQU	026#000
  67                    OLDPG27:	EQU	027#000
  68                    OLDPG57:	EQU	057#000
  69                    
  70                    
  71                    ;;; Page zero will contain the I/O Routines.  These are actually
  72                    ;;; just as suggested by Scelbal Manual for Serial I/O.
  73                    
  74                    	ORG 000#100		; save a bit of space before this
  75                    	
  76                    save:	
  77 00-100 104 266 010 load:	JMP EXEC		; By default, save and load isn't implemented.
  78                    
  79                    ;    These functions support a simulated I/O for the
  80                    ;        Intel 8008 Master Thesis computer (promoncomp).
  81                    ;
  82                    ;    Outport 0: used to select device for reading from Inport 0
  83                    ;        and writing to Outport 3.
  84                    ;    Inport 0: used to read external data.
  85                    ;    Outport 3: used to write external data.
  86                    ;
  87                    ;    Outport 1: used to save interupt state, connected to Inport 1.
  88                    ;    Outport 2: used to save interupt state, connected to Inport 2.
  89                    ;
  90                    ;    Inport 3: used to input data from tape-reader
  91                    ;    Outport 4: used to output character to printer.
  92                    ;    Inport 5: used to input character from keyboard.
  93                    ;
  94                    ;    Inport 4: used for status flags for the ports (Flagport).
  95                    ;      Flag 1 (bit 0): set to 1 when printer ready.
  96                    ;      Flag 2 (bit 1): set to 1 when input available from tape-reader.
  97                    ;      Flag 3 (bit 2): set to 1 when tape in tape-reader.
  98                    ;      Flag 5 (bit 4): set to 1 when character available from keyboard.
  99                    ;      Flag 7 (bit 6): set to 1 when the reset key on the computer is pressed.
 100                    ;
 101                    ;    Inport 7: used to start the printer motor, just using an output pulse,
 102                    ;        no data is read.
 103                    
 104                    CINP:   ; Get character from keyboard, return value of character in A register
 105                    	; the recieved character is echoed to the printer
 106                    	; for some reason in SCELBAL bit 7 is always "1" for the character
 107 00-103 111                 INP 4           ;input value from status port
 108 00-104 044 024             NDI 20          ;test Flag 5 (bit 4) if character is available from keyboard
 109 00-106 150 103 000         JTZ CINP        ;no character available, test status again
 110 00-111 113                 INP 5           ;get character
 111 00-112 131                 OUT 014         ;print character
 112 00-113 064 200     	ORI 200		;set bit 7 to "1"
 113 00-115 007                 RET
 114                    
 115                    CPRINT: ; Put charater to printer (or screen), output character in A register
 116                    	; register B is used to save the character
 117                    	; for some reason in SCELBAL bit 7 of the character is sometimes set
 118 00-116 310                 LBA             ;save character to print i B register
 119 00-117 111         STATST: INP 4           ;input value from status port
 120 00-120 044 001             NDI 1           ;test Flag 1 (bit 0) if printer is ready
 121 00-122 150 117 000         JTZ STATST      ;printer not ready, test again
 122 00-125 301                 LAB
 123 00-126 074 224     	CPI 224		;don't print CTRL-T
 124 00-130 053         	RTZ
 125 00-131 044 177     	NDI 177		;reset bit 7 of character
 126 00-133 131                 OUT 014         ;print character
 127 00-134 007                 RET
 128                    
 129                    ;;; no user defined functions yet, stop here if we: see one.
 130 00-135 001         UDEFX:	HLT
 131                    
 132                    
 133                    ;;; THE ABOVE MUST CONCLUDE BEFORE BY PAGE 1 STARTS
 134                    	
 135                    	
 136                    ;;; Page one has many constants and variables.
 137                    	
 138                    	ORG 001#000
 139 01-000             	DATA *4
 140 01-004 000 000 100  	DATA 000,000,100,001	; STORES FLOATING POINT CONSTANT +1.0
     01-007 001 
 141 01-010             	DATA *3
 142 01-013 000          	DATA 000		; EXPONENT COUNTER
 143 01-014 000 000 000  	DATA 000,000,000,000	; STORES FLOATING POINT NUMBER TEMPORARILLY
     01-017 000 
 144 01-020             	DATA *4
 145 01-024 000 000 300  	DATA 000,000,300,001	; STORES FLOATING POINT CONSTANT -1.0
     01-027 001 
 146 01-030 000 000 000  	DATA 000,000,000,000	; SCRATCH PAD AREA (16 BYTES)
     01-033 000 
 147 01-034 000 000 000  	DATA 000,000,000,000
     01-037 000 
 148 01-040 000 000 000  	DATA 000,000,000,000
     01-043 000 
 149 01-044 000 000 000  	DATA 000,000,000,000
     01-047 000 
 150 01-050 001 120 162  	DATA 001,120,162,002	; STORES RANDOM NUMBER GENERATOR CONSTANT VALUE
     01-053 002 
 151 01-054             	DATA *4
 152 01-060 003 150 157  	DATA 003,150,157,014	; STORES RANDOM NUMBER GENERATOR CONSTANT VALUE
     01-063 014 
 153 01-064 000 000 000  	DATA 000,000,000,000	; SCRATCH PAD AREA (12 BYTES) (01 064-077)
     01-067 000 
 154 01-070 000 000 000  	DATA 000,000,000,000
     01-073 000 
 155 01-074 000 000 000  	DATA 000,000,000,000
     01-077 000 
 156 01-100 000 000      	DATA 000,000		; SIGN INDICATOR
 157 01-102 000          	DATA 000		; BITS COUNTER
 158 01-103 000 000      	DATA 000,000		; SIGN INDICATOR
 159 01-105 000          	DATA 000		; INPUT DIGIT COUNTER
 160 01-106 000          	DATA 000		; TEMP STORATE
 161 01-107 000          	DATA 000		; OUTPUT DIGIT COUNTER
 162 01-110 000          	DATA 000 		; FP MODE INDICATOR
 163 01-111             	DATA *7			; NOT ASSIGNED (SHOULD BE 01 111-117)
 164 01-120 000 000 000  	DATA 000,000,000,000	; FPACC EXTENSION
     01-123 000 
 165 01-124 000 000 000  	DATA 000,000,000,000	; FPACC LSW, NSW, MSW, EXPONENT
     01-127 000 
 166 01-130 000 000 000  	DATA 000,000,000,000	; FPOP  Extension
     01-133 000 
 167 01-134 000 000 000  	DATA 000,000,000,000	; FPOP  LSW, NSW, MSW, EXPONENT
     01-137 000 
 168 01-140 000 000 000  	DATA 000,000,000,000	; FLOATING POINT WORKING AREA
     01-143 000 
 169 01-144 000 000 000  	DATA 000,000,000,000	; (SHOULD BE AT 01 140-01-167)
     01-147 000 
 170 01-150 000 000 000  	DATA 000,000,000,000
     01-153 000 
 171 01-154 000 000 000  	DATA 000,000,000,000
     01-157 000 
 172 01-160 000 000 000  	DATA 000,000,000,000
     01-163 000 
 173 01-164 000 000 000  	DATA 000,000,000,000
     01-167 000 
 174 01-170             	DATA *8			; NOT ASSIGNED (SHOULD BE 01 170-01 177)
 175 01-200 000 000 000  	DATA 000,000,000,000	; TEMPORARY REGISTER STORAGE AREA (D,E,H&L)
     01-203 000 
 176 01-204             	DATA *4			; NOT ASSIGNED (01 204-01 207)
 177 01-210 000 000 120  	DATA 000,000,120,004	; STORES FLOATING POINT CONSTANT +10.0
     01-213 004 
 178 01-214 147 146 146  	DATA 147,146,146,375	; STORES FLOATING POINT CONSTANT +0.1
     01-217 375 
 179 01-220 000          	DATA 000		; GETINP COUNTER
 180 01-221             	DATA *6			; NOT ASSIGNED (01 221-01 226)
 181 01-227 000          	DATA 000		; ARITHMETIC STACK POINTER (01 227)
 182 01-230 000          	DATA 000		; ARITHMETIC STACK (NOT CLEAR HOW LONG)
 183                    	ORG 001#272
 184 01-272 004          	DATA 004		; CC FOR SAVE
 185 01-273 323 301 326  	DATA "SAVE"
     01-276 305 
 186 01-277 004          	DATA 004		; CC FOR LOAD
 187 01-300 314 317 301  	DATA "LOAD"
     01-303 304 
 188 01-304 000 000 000  	DATA 000,000,000,000	; UNCLEAR WHAT THIS IS (01 304-01 317) ZEROS
     01-307 000 
 189 01-310 000 000 000  	DATA 000,000,000,000	; (PROBABLY STEP, FOR/NEXT, AND ARRAY PTR TEMP)
     01-313 000 
 190 01-314 000 000 000  	DATA 000,000,000,000
     01-317 000 
 191                    	;; AT THIS POINT WE SHOULD BE AT LOCATION 01 320
 192 01-320 004          	DATA 4
 193 01-321 324 310 305  	DATA "THEN"
     01-324 316 
 194 01-325 002          	DATA 2
 195 01-326 324 317      	DATA "TO"
 196 01-330 004          	DATA 4
 197 01-331 323 324 305  	DATA "STEP"
     01-334 320 
 198 01-335 004          	DATA 4
 199 01-336 314 311 323  	DATA "LIST"
     01-341 324 
 200 01-342 003          	DATA 3
 201 01-343 322 325 316  	DATA "RUN"
 202 01-346 003          	DATA 3
 203 01-347 323 303 322  	DATA "SCR
 204 01-352 013          	DATA 013		; CC FOR "READY" MESSAGE
 205 01-353 224 215 212  	DATA 224,215,212	; CTRL-T, CARRIAGE RETURN, LINE FEED
 206 01-356 322 305 301  	DATA "READY"
     01-361 304 331 
 207 01-363 215 212 212  	DATA 215,212,212	; CARRIAGE RETURN, LINE FEED, LINE FEED;
 208 01-366 011          	DATA 011
 209 01-367 240 301 324  	DATA " AT LINE "
     01-372 240 314 311
     01-375 316 305 240
 210                    	;; THIS SHOULD BE THE END OF PAGE 01
 211                    
 212                    	
 213                    	ORG 002#000		; START PAGE 02, THE CODE
 214                    	
 215                    
 216 02-000 106 255 002 SYNTAX:    CAL CLESYM             ;Clear the SYMBOL BUFFER area
 217 02-003 066 340                LLI 340                ;Set L to start of LINE NUMBER BUFFER
 218 02-005 056 026                LHI \HB\OLDPG26        ;** Set H to page of LINE NUMBER BUFFER
 219 02-007 076 000                LMI 000                ;Initialize line number buff by placing zero as (cc)
 220 02-011 066 201                LLI 201                ;Change pointer to syntax counter/pointer storage loc.
 221 02-013 076 001                LMI 001                ;Set pointer to first character (after cc) in line buffer
 222 02-015 066 201     SYNTX1:    LLI 201                ;Set pointer to syntax cntr/pntr storage location
 223 02-017 106 240 002            CAL GETCHR             ;Fetch the character pointed to by contents of syntax
 224 02-022 150 044 002            JTZ SYNTX2             ;Cntr/pntr from the line input buffer. If character was
 225 02-025 074 260                CPI 260                ;A space, ignore. Else, test to see if character was ASCII
 226 02-027 160 061 002            JTS SYNTX3             ;Code for a decimal digit. If not a decimal digit, consider
 227 02-032 074 272                CPI 272                ;Line number to have been processed by jumping
 228 02-034 120 061 002            JFS SYNTX3             ;Over the remainder of this SYNTX1 section.
 229 02-037 066 340                LLI 340                ;If have decimal digit, set pointer to start of LINE
 230 02-041 106 314 002            CAL CONCT1             ;NUMBER BUFFER and append incoming digit there.
 231 02-044 066 201     SYNTX2:    LLI 201                ;Reset L to syntax cntr/pntr storage location. Call sub-
 232 02-046 106 003 003            CAL LOOP               ;Routine to advance pntr and test for end of inr)ut buffer
 233 02-051 110 015 002            JFZ SYNTX1             ;If not end of input buffer, go back for next digit
 234 02-054 066 203                LLI 203                ;If end of buffer, only had a line number in the line.
 235 02-056 076 000                LMI 000                ;Set pntr to TOKEN storage location. Set TOKEN = 000.
 236 02-060 007                    RET                    ;Return to caller.
 237 02-061 066 201     SYNTX3:    LLI 201                ;Reset pointer to syntax cntr/pntr and fetch
 238 02-063 317                    LBM                    ;Position of next character after the line number
 239 02-064 066 202                LLI 202                ;Change pntr to SCAN pntr storage location
 240 02-066 371                    LMB                    ;Store address when SCAN takes up after line number
 241 02-067 066 202     SYNTX4:    LLI 202                ;Set pntr to SCAN pntr stomge location
 242 02-071 106 240 002            CAL GETCHR             ;Fetch the character pointed to by contents of the SCAN
 243 02-074 150 171 002            JTZ SYNTX6             ;Pointer storage location. If character was ASCII code
 244 02-077 074 275                CPI 275                ;For space, ignore. Else, compare character with "=" sign
 245 02-101 150 210 002            JTZ SYNTX7             ;If is an equal sign, go set TOKEN for IMPLIED LET.
 246 02-104 074 250                CPI 250                ;Else, compare character with left parenthesis " ( "
 247 02-106 150 215 002            JTZ SYNTX8             ;If left parenthesis, go set TOKEN for implied array LET
 248 02-111 106 310 002            CAL CONCTS             ;Otherwise, concatenate the character onto the string
 249 02-114 066 203                LLI 203                ;Being constructed in the SYMBOL BUFFER. Now set
 250 02-116 076 001                LMI 001                ;Up TOKEN storage location to an initial value of 001.
 251 02-120 056 027                LHI \HB\OLDPG27        ;** Set H to point to start of KEYWORD TABLE.
 252 02-122 066 000                LLI 000                ;Set L to point to start of KEYWORD TABLE.
 253 02-124 036 026     SYNTX5:    LDI \HB\OLDPG26        ;** Set D to page of SYMBOL BUFFER
 254 02-126 046 120                LEI 120                ;Set E to start of SYMBOL BUFFER
 255 02-130 106 332 002            CAL STRCP              ;Compare char string presently in SYMBOL BUFFER
 256 02-133 053                    RTZ                    ;With entry in KEYWORD TABLE. Exit if match.
 257 02-134 106 356 022            CAL SWITCH             ;TOKEN will be set to keyword found. Else, switch
 258 02-137 060         SYNTXL:    INL                    ;Pointers to get table address back and advance pntr to
 259 02-140 307                    LAM                    ;KEYWORD TABLE. Now look for start of next entry
 260 02-141 044 300                NDI 300                ;In KEYWORD TABLE by looking for (cc) byte which
 261 02-143 110 137 002            JFZ SYNTXL             ;Will NOT have a one in the two most sig. bits. Advance
 262 02-146 106 356 022            CAL SWITCH             ;Pntr til next entry found. Then switch pointers apin so
 263 02-151 066 203                LLI 203                ;Table pointer is in D&E. Put addr of TOKEN in L.
 264 02-153 056 026                LHI \HB\OLDPG26        ;** And page of TOKEN in H. Fetch the value currently
 265 02-155 317                    LBM                    ;In TOKEN and advance it to account for going on to
 266 02-156 010                    INB                    ;The next entry in the KEYWORD TABLE.
 267 02-157 371                    LMB                    ;Restore the updated TOKEN value back to storage.
 268 02-160 106 356 022            CAL SWITCH             ;Restore the keyword table pointer back to H&L.
 269 02-163 301                    LAB                    ;Put TOKEN count in ACC.
 270 02-164 074 015                CPI 015                ;See if have tested all entries in the keyword table.
 271 02-166 110 124 002            JFZ SYNTX5             ;If not, continue checking the keyword table.
 272 02-171 066 202     SYNTX6:    LLI 202                ;Set L to SCAN pointer storage location
 273 02-173 056 026                LHI \HB\OLDPG26        ;** Set H to page of SCAN pointer stomge location
 274 02-175 106 003 003            CAL LOOP               ;Call routine to advance pntr & test for end of In buffer
 275 02-200 110 067 002            JFZ SYNTX4             ;Go back and add another character to SYMBOL BUFF
 276 02-203 066 203                LLI 203                ;And search table for KEYWORD again. Unless reach
 277 02-205 076 377                LMI 377                ;End of line input buffer. In which case set TOKEN=377
 278 02-207 007                    RET                    ;As an error indicator and exit to calling routine.
 279 02-210 066 203     SYNTX7:    LLI 203                ;Set pointer to TOKEN storage register. Set TOKEN
 280 02-212 076 015                LMI 015                ;Equal to 015 when "=" sign found for IMPLIED LET.
 281 02-214 007                    RET                    ;Exit to calling routine.
 282 02-215 066 203     SYNTX8:    LLI 203                ;Set pointer to TOKEN storage register. Set TOKEN
 283 02-217 076 016                LMI 016                ;Equal to 016 when "(" found for IMPLIED array LET.
 284 02-221 007                    RET                    ;Exit to calling routine.
 285                    
 286                                                      ;The following are subroutines used by SYNTAX and
 287                                                      ;other routines in SCELBAL.
 288                    
 289 02-222 006 302     BIGERR:    LAI 302                ;Load ASCII code for letters B and G to indicate BIG
 290 02-224 026 307                LCI 307                ;ERROR (for when buffer, stack,etc., overflows).
 291 02-226 106 202 003 ERROR:     CAL ECHO               ;Call user provided display routine to print ASCII code
 292 02-231 302                    LAC                    ;In accumulator. Transfer ASCII code from C to ACC
 293 02-232 106 202 003            CAL ECHO               ;And repeat to display error codes.
 294 02-235 104 322 012            JMP FINERR             ;Go cpmplete error message (AT LINE) as required.
 295 02-240 307         GETCHR:    LAM                    ;Get pointer from memory location pointed to by H&L
 296 02-241 074 120                CPI 120                ;See if within range of line input buffer.
 297 02-243 120 222 002            JFS BIGERR             ;If not then have an overflow condition = error.
 298 02-246 360                    LLA                    ;Else can use it as addr of character to fetch from the
 299 02-247 056 026                LHI \HB\OLDPG26        ;** LINE INPUT BUFFER by setting up H too.
 300 02-251 307                    LAM                    ;Fetch the character from the line input buffer.
 301 02-252 074 240                CPI 240                ;See if it is ASCII code for space.
 302 02-254 007                    RET                    ;Return to caller with flags set according to comparison.
 303 02-255 066 120     CLESYM:    LLI 120                ;Set L to start of SYMBOL BUFFER.
 304 02-257 056 026                LHI \HB\OLDPG26        ;** Set H to page of SYMBOL BUFFER.
 305 02-261 076 000                LMI 000                ;Place a zero byte at start of SYMBOL BUFFER.
 306 02-263 007                    RET                    ;To effectively clear the buffer. Then exit to caller.
 307                    
 308                    
 309                                                      ;Subroutine to concatenate (append) a character to the
 310                                                      ;SYMBOL BUFFER. Character must be alphanumeric.
 311                    
 312 02-264 074 301     CONCTA:    CPI 301                ;See if character code less than that for letter A.
 313 02-266 160 276 002            JTS CONCTN             ;If so, go see if it is numeric.
 314 02-271 074 333                CPI 333                ;See if character code greater than that for letter Z.
 315 02-273 160 310 002            JTS CONCTS             ;If not, have valid alphabetical character.
 316 02-276 074 260     CONCTN:    CPI 260                ;Else, see if character in valid numeric range.
 317 02-300 160 327 002            JTS CONCTE             ;If not, have an error condition.
 318 02-303 074 272                CPI 272                ;Continue to check for valid number.
 319 02-305 120 327 002            JFS CONCTE             ;If not, have an error condition.
 320 02-310 066 120     CONCTS:    LLI 120                ;If character alphanumeric, can concatenate. Set pointer
 321 02-312 056 026                LHI \HB\OLDPG26        ;** To starting address of SYMBOL BUFFER.
 322 02-314 327         CONCT1:    LCM                    ;Fetch old character count in SYMBOL BUFFER.
 323 02-315 020                    INC                    ;Increment the value to account for adding new
 324 02-316 372                    LMC                    ;Character to the buffer. Restore updated (cc).
 325 02-317 310                    LBA                    ;Save character to be appended in register B.
 326 02-320 106 036 023            CAL INDEXC             ;Add (cc) to address in H & L to get new end of buffer
 327 02-323 371                    LMB                    ;Address and append the new character to buffer
 328 02-324 006 000                LAI 000                ;Clear the accumulator
 329 02-326 007                    RET                    ;Exit to caller
 330 02-327 104 152 011 CONCTE:    JMP SYNERR             ;If character to be appended not alphanumeric, ERROR!
 331                    
 332                                                      ;Subroutine to compare
 333                                                      ;character strings pointed to by
 334                                                      ;register pairs D & E and H & L.
 335                    
 336 02-332 307         STRCP:     LAM                    ;Fetch (cc) of first string.
 337 02-333 106 356 022            CAL SWITCH             ;Switch pointers and fetch length of second string (cc)
 338 02-336 317                    LBM                    ;Into register B. Compare the lengths of the two strings.
 339 02-337 271                    CPB                    ;If they are not the same
 340 02-340 013                    RFZ                    ;Return to caller with flags set to non-zero condition
 341 02-341 106 356 022            CAL SWITCH             ;Else, exchange the pointers back to first string.
 342 02-344 106 377 002 STRCPL:    CAL ADV                ;Advance the pointer to string number 1 and fetch a
 343 02-347 307                    LAM                    ;Character from that string into the accumulator.
 344 02-350 106 356 022            CAL SWITCH             ;Now switch the pointers to string number 2.
 345 02-353 106 377 002            CAL ADV                ;Advance the pointer in line number 2.
 346 02-356 277         STRCPE:    CPM                    ;Compare char in stxing 1 (ACC) to string 2 (memory)
 347 02-357 013                    RFZ                    ;If not equal, return to cauer with flags set to non-zero
 348 02-360 106 356 022            CAL SWITCH             ;Else, exchange pointers to restore pntr to string 1
 349 02-363 011                    DCB                    ;Decrement the string length counter in register B
 350 02-364 110 344 002            JFZ STRCPL             ;If not finiahed, continue testing entire string
 351 02-367 007                    RET                    ;If complete match, return with flag in zero condition
 352 02-370 307         STRCPC:    LAM                    ;Fetch character pointed to by pointer to string 1
 353 02-371 106 356 022            CAL SWITCH             ;Exchange pointer to examine string 2
 354 02-374 104 356 002            JMP STRCPE             ;Continue the string comparison loop
 355                    
 356                                                      ;Subroutine to advance the two byte
 357                                                      ;value in CPU registers H and L.
 358                    
 359 02-377 060         ADV:       INL                    ;Advance value in register L.
 360 03-000 013                    RFZ                    ;If new value not zero, return to caller.
 361 03-001 050                    INH                    ;Else must increment value in H
 362 03-002 007                    RET                    ;Before retuming to caller
 363                    
 364                                                      ;Subroutine to advance a buffer pointer
 365                                                      ;and test to see if the end of the buffer
 366                                                      ;has been reached.
 367                    
 368 03-003 317         LOOP:      LBM                    ;Fetch memory location pointed to by H & L into B.
 369 03-004 010                    INB                    ;Increment the value.
 370 03-005 371                    LMB                    ;Restore it back to memory.
 371 03-006 066 000                LLI 000                ;Change pointer to start of INPUT LINE BUFFER
 372 03-010 307                    LAM                    ;Fetch buffer length (cc) value into the accumulator
 373 03-011 011                    DCB                    ;Make value in B original value
 374 03-012 271                    CPB                    ;See if buffer length same as that in B
 375 03-013 007                    RET                    ;Return with flags yielding results of the comparison
 376                    
 377                                                      ;The following subroutine is used to
 378                                                      ;input characters from the system's
 379                                                      ;input device (such as a keyboard)
 380                                                      ;into the LINE INPUT BUFFER. Routine has limited
 381                                                      ;editing capability included.
 382                                                      ;(Rubout = delete previous character(s) entered.)
 383                    ;;; This label, STRIN:	should be location 03 014
 384 03-014 026 000     STRIN:     LCI 000                ;Initialize register C to zero.
 385 03-016 106 221 003 STRIN1:    CAL CINPUT             ;Call user provided device input subroutine to fetch one
 386 03-021 074 377                CPI 377                ;Character from the input device. Is it ASCII code for
 387 03-023 110 045 003            JFZ NOTDEL             ;Rubout? Skip to next section if not rubout.
 388 03-026 006 334                LAI 334                ;Else, load ASCII code for backslash into ACC.
 389 03-030 106 202 003            CAL ECHO               ;Call user display driver to present backslash as a delete
 390 03-033 021                    DCC                    ;Indicator. Now decrement the input character counter.
 391 03-034 160 014 003            JTS STRIN              ;If at beginning of line do NOT decrement H and L.
 392 03-037 106 164 003            CAL DEC                ;Else, decrement H & L line pointer to erase previous
 393 03-042 104 016 003            JMP STRIN1             ;Entry, then go back for a new input.
 394 03-045 074 203     NOTDEL:    CPI 203                ;See if character inputted was'CONTROL C'
 395 03-047 150 313 012            JTZ CTRLC              ;If so, stop inputting and go back to the EXECutive
 396 03-052 074 215                CPI 215                ;If not, see if character was carriage-return
 397 03-054 150 102 003            JTZ STRINF             ;If so, have end of line of input
 398 03-057 074 212                CPI 212                ;If not, see if character was line-feed
 399 03-061 150 016 003            JTZ STRIN1             ;If so, ignore the input, get another character
 400 03-064 106 377 002            CAL ADV                ;If none of the above, advance contents of H & L
 401 03-067 020                    INC                    ;Increment the character counter
 402 03-070 370                    LMA                    ;Store the new character in the line input buffer
 403 03-071 302                    LAC                    ;Put new character count in the accumulator
 404 03-072 074 120                CPI 120                ;Make sure maximum buffer size not exceeded
 405 03-074 120 222 002            JFS BIGERR             ;If buffer size exceeded, go display BG error message
 406 03-077 104 016 003            JMP STRIN1             ;Else can go back to look for next input
 407 03-102 312         STRINF:    LBC                    ;Transfer character count from C to B
 408 03-103 106 113 003            CAL SUBHL              ;Subtract B from H & L to get starting address of
 409 03-106 372                    LMC                    ;The string and place the character count (cc) there
 410 03-107 106 141 003            CAL CRLF               ;Provide a line ending CR & LF combination on the
 411 03-112 007                    RET                    ;Display device. Then exit to caller.
 412                    
 413                                                      ;Subroutine to subtract contents of CPU register B from
 414                                                      ;the two byte value in CPU registers H & L.
 415                    
 416 03-113 306         SUBHL:     LAL                    ;Load contents of register L into the accumulator
 417 03-114 221                    SUB                    ;Subtract the contents of register B
 418 03-115 360                    LLA                    ;Restore the new value back to L
 419 03-116 003                    RFC                    ;If no carry, then no underflow. Exit to caller.
 420 03-117 051                    DCH                    ;Else must also decrement contents of H.
 421 03-120 007                    RET                    ;Before retuming to caller.
 422                    
 423                                                      ;Subroutine to display a character string on the system's
 424                                                      ;display device.
 425                    
 426 03-121 327         TEXTC:     LCM                    ;Fetch (cc) from the first location in the buffer (H & L
 427 03-122 307                    LAM                    ;Pointing there upon entry) into register B and ACC.
 428 03-123 240                    NDA                    ;Test the character count value.
 429 03-124 053                    RTZ                    ;No display if (cc) is zero.
 430 03-125 106 377 002 TEXTCL:    CAL ADV                ;Advance pointer to next location in buffer
 431 03-130 307                    LAM                    ;Fetch a character from the buffer into ACC
 432 03-131 106 202 003            CAL ECHO               ;Call the user's display driver subroutine
 433 03-134 021                    DCC                    ;Decrement the (cc)
 434 03-135 110 125 003            JFZ TEXTCL             ;If character counter not zero, continue display
 435 03-140 007                    RET                    ;Exit to caller when (cc) is zero.
 436                    
 437                                                      ;Subroutine to provide carriage-return and line-feed
 438                                                      ;combination to system's display device. Routine also
 439                                                      ;initializes a column counter to zero. Column counter
 440                                                      ;is used by selected output routines to count the num-
 441                                                      ;ber of characters that have been displayed on a line.
 442                    
 443 03-141 006 215     CRLF:      LAI 215                ;Load ASCII code for carriage-return into ACC
 444 03-143 106 202 003            CAL ECHO               ;Call user provided display driver subroutine
 445 03-146 006 212                LAI 212                ;Load ASCII code for line-feed into ACC
 446 03-150 106 202 003            CAL ECHO               ;Call user provided display driver subroutine
 447 03-153 066 043                LLI 043                ;Set L to point to COLUMN COUNTER storage location
 448 03-155 056 001                LHI \HB\OLDPG1         ;** Set H to page of COLUMN COUNTER
 449 03-157 076 001                LMI 001                ;Initialize COLUMN COUNTER to a value of one
 450 03-161 353                    LHD                    ;Restore H from D (saved by ECHO subroutine)
 451 03-162 364                    LLE                    ;Restore L from E (saved by ECHO subroutine)
 452 03-163 007                    RET                    ;Then exit to calling routine
 453                    
 454                                                      ;Subroutine to decrement double-byte value in CPU
 455                                                      ;registers H and L.
 456                    
 457 03-164 061         DEC:       DCL                    ;Decrement contents of L
 458 03-165 060                    INL                    ;Now increment to exercise CPU flags
 459 03-166 110 172 003            JFZ DECNO              ;If L not presently zero, skip decrementing H
 460 03-171 051                    DCH                    ;Else decrement H
 461 03-172 061         DECNO:     DCL                    ;Do the actual decrement of L
 462 03-173 007                    RET                    ;Return to caller
 463                    
 464                    
 465                                                      ;Subroutine to index the value in CPU registers H and L
 466                                                      ;by the contents of CPU register B.
 467                    
 468 03-174 306         INDEXB:    LAL                    ;Load L into the accumulator
 469 03-175 201                    ADB                    ;Add B to that value
 470 03-176 360                    LLA                    ;Restore the new value to L
 471 03-177 003                    RFC                    ;If no carry,  return to caller
 472 03-200 050                    INH                    ;Else, increment value in H
 473 03-201 007                    RET                    ;Before returning to caller
 474                    
 475                                                      ;The following subroutine is used to
 476                                                      ;display the ASCII encoded character in the ACC on the
 477                                                      ;system's display device. This routine calls a routine
 478                                                      ;labeled CINPUT which must be provided by the user to
 479                                                      ;actually drive the system's output device. The subroutine
 480                                                      ;below also increments an output column counter each time
 481                                                      ;it is used.
 482                    
 483 03-202 335         ECHO:      LDH                    ;Save entry value of H in register D
 484 03-203 346                    LEL                    ;And save entry value of L in register E
 485 03-204 066 043                LLI 043                ;Set L to point to COLUMN COUNTER storage location
 486 03-206 056 001                LHI \HB\OLDPG1         ;** Set H to page of COLUMN COUNTER
 487 03-210 317                    LBM                    ;Fetch the value in the COLUMN COUNTER
 488 03-211 010                    INB                    ;And increment it for each character displayed
 489 03-212 371                    LMB                    ;Restore the updated count in memory
 490 03-213 106 116 000            CAL CPRINT              ;tt Call the user's device driver subroutine
 491 03-216 353                    LHD                    ;Restore entry value of H from D
 492 03-217 364                    LLE                    ;Restore entry value of L from E
 493 03-220 007                    RET                    ;Return to calling routine
 494 03-221 104 103 000 CINPUT:	   JMP CINP               ;Reference to user defined input subroutine
 495                    
 496                    ;;; The label EVAL: SHOULD BE AT 03 224
 497 03-224 066 227     EVAL:      LLI 227                ;Load L with address of ARITHMETIC STACK pointer
 498 03-226 056 001                LHI \HB\OLDPG1         ;** Set H to page of ARITHMETIC STACK pointer
 499 03-230 076 224                LMI 224                ;Initialize ARITH STACK pointer value to addr minus 4
 500 03-232 060                    INL                    ;Advance memory pointer to FUN/ARRAY STACK pntr
 501 03-233 056 026                LHI \HB\OLDPG26        ;** Set H to page of FUN/ARRAY STACK pointer
 502 03-235 076 000                LMI 000                ;Initialize FUNIARRAY STACK pointer to start of stack
 503 03-237 106 255 002            CAL CLESYM             ;Initialize the SYMBOL BUFFER to empty condition
 504 03-242 066 210                LLI 210                ;Load L with address of OPERATOR STACK pointer
 505 03-244 076 000                LMI 000                ;Initialize OPERATOR STACK pointer value
 506 03-246 066 276                LLI 276                ;Set L to address of EVAL pointer (start of expression)
 507 03-250 317                    LBM                    ;Fetch the EVAL pointer value into register B
 508 03-251 066 200                LLI 200                ;Set up a working pointer register in this location
 509 03-253 371                    LMB                    ;And initialize EVAL CURRENT pointer
 510 03-254 066 200     SCAN1:     LLI 200                ;Load L with address of EVAL CURRENT pointer
 511 03-256 106 240 002            CAL GETCHR             ;Fetch a character in the expression being evaluated
 512 03-261 150 301 004            JTZ SCAN10             ;If character is a space, jump out of this section
 513 03-264 074 253                CPI 253                ;See if character is a "+" sign
 514 03-266 110 300 003            JFZ SCAN2              ;If not, continue checking for an operator
 515 03-271 066 176                LLI 176                ;If yes, set pointer to PARSER TOKEN storage location
 516 03-273 076 001                LMI 001                ;Place TOKEN value for "+" sign in PARSER TOKEN
 517 03-275 104 351 003            JMP SCANFN             ;Go to PARSER subroutine entry point
 518 03-300 074 255     SCAN2:     CPI 255                ;See if character is a minus ("-") sign
 519 03-302 110 357 003            JFZ SCAN4              ;If not, continue checking for an operator
 520 03-305 066 120                LLI 120                ;If yes, check the length of the symbol stored in the
 521 03-307 307                    LAM                    ;SYMBOL BUFFER by fetching the (cc) byte
 522 03-310 240                    NDA                    ;And testing to see if (cc) is zero
 523 03-311 110 345 003            JFZ SCAN3              ;If length not zero, then not a unary minus indicator
 524 03-314 066 176                LLI 176                ;Else, check to see if last operator was a right parenthesi
 525 03-316 307                    LAM                    ;By fetching the value in the PARSER TOKEN storage
 526 03-317 074 007                CPI 007                ;Location and seeing if it is token value for ")"
 527 03-321 150 345 003            JTZ SCAN3              ;If last operator was I')" then do not have a unary minus
 528 03-324 074 003                CPI 003                ;Check to see if last operator was C4*~2
 529 03-326 150 152 011            JTZ SYNERR             ;If yes, then have a syntax error
 530 03-331 074 005                CPI 005                ;Check to see if last operator was exponentiation
 531 03-333 150 152 011            JTZ SYNERR             ;If yes, then have a syntax error
 532 03-336 066 120                LLI 120                ;If none of the above, then minus sign is unary, put
 533 03-340 076 001                LMI 001                ;Character string representing the
 534 03-342 060                    INL                    ;Value zero in the SYMBOL BUFFER in string format
 535 03-343 076 260                LMI 260                ;(Character count (cc) followed by ASCII code for zero)
 536 03-345 066 176     SCAN3:     LLI 176                ;Set L to address of PARSER TOKEN storage location
 537 03-347 076 002                LMI 002                ;Set PARSER TOKEN value for minus operator
 538 03-351 106 324 004 SCANFN:    CAL PARSER             ;Call the PARSER subroutine to process current symbol
 539 03-354 104 301 004            JMP SCAN10             ;And operator. Then jump to continue processing.
 540 03-357 074 252     SCAN4:     CPI 252                ;See if character fetched from expression is
 541 03-361 110 373 003            JFZ SCAN5              ;If not, continue checking for an operator
 542 03-364 066 176                LLI 176                ;If yes, set pointer to PARSER TOKEN storage location
 543 03-366 076 003                LMI 003                ;Place TOKEN value for "*" (multiplication) operator in
 544 03-370 104 351 003            JMP SCANFN             ;PARSER TOKEN and go to PARSER subroutine entry
 545 03-373 074 257     SCAN5:     CPI 257                ;See if character fetched from expression is
 546 03-375 110 007 004            JFZ SCAN6              ;If not, continue checking for an operator
 547 04-000 066 176                LLI 176                ;If yes, set pointer to PARSER TOKEN storage location
 548 04-002 076 004                LMI 004                ;Place TOKEN value for "/" (division) operator in
 549 04-004 104 351 003            JMP SCANFN             ;PARSER TOKEN and go to PARSER subroutine entry
 550 04-007 074 250     SCAN6:     CPI 250                ;See if character fetched from expression is
 551 04-011 110 033 004            JFZ SCAN7              ;If not, continue checking for an operator
 552 04-014 066 230                LLI 230                ;If yes, load L with address of FUN/ARRAY STACK
 553 04-016 317                    LBM                    ;Pointer. Fetch the value in the stack pointer. Increment
 554 04-017 010                    INB                    ;It to indicate number of "(" operators encountered.
 555 04-020 371                    LMB                    ;Restore the updated stack pointer back to memory
 556 04-021 106 100 007            CAL FUNARR             ;Call subroutine to process possible FUNCTION or
 557 04-024 066 176                LLI 176                ;ARRAY variable subscript. Ihen set pointer to
 558 04-026 076 006                LMI 006                ;PARSER TOKEN storage and set value for operator
 559 04-030 104 351 003            JMP SCANFN             ;Go to PARSER subroutine entry point.
 560 04-033 074 251     SCAN7:     CPI 251                ;See if character fetched from expression is
 561 04-035 110 064 004            JFZ SCAN8              ;If not, continue checking for an operator
 562 04-040 066 176                LLI 176                ;If yes, load L with address of PARSER TOKEN
 563 04-042 076 007                LMI 007                ;Set PARSER TOKEN value to reflect ")"
 564 04-044 106 324 004            CAL PARSER             ;Call the  PARSER subroutine to process current symbol
 565                    	
 566 04-047 106 003 007            CAL PRIGHT             ;Call subroutine to handle FUNCTION or ARRAY
 567 04-052 066 230                LLI 230                ;Load L with address of FUN/ARRAY STACK pointer
 568 04-054 056 026                LHI \HB\OLDPG26        ;** Set H to page of FUN/ARRAY STACK pointer
 569 04-056 317                    LBM                    ;Fetch the value in the stack pointer. Decrement it
 570 04-057 011                    DCB                    ;To account for left parenthesis just processed.
 571 04-060 371                    LMB                    ;Restore the updated value back to memory.
 572 04-061 104 301 004            JMP SCAN10             ;Jump to continue processing expression.
 573 04-064 074 336     SCAN8:     CPI 336                ;See if character fetched from expression is " t
 574 04-066 110 100 004            JFZ SCAN9              ;If not, continue checking for an operator
 575 04-071 066 176                LLI 176                ;If yes, load L with address of PARSER TOKEN
 576 04-073 076 005                LMI 005                ;Put in value for exponentiation
 577 04-075 104 351 003            JMP SCANFN             ;Go to PARSER subroutine entry point.
 578 04-100 074 274     SCAN9:     CPI 274                ;See if character fetched is the "less than" sign
 579 04-102 110 143 004            JFZ SCAN11             ;If not, continue checking for an operator
 580 04-105 066 200                LLI 200                ;If yes, set L to the EVAL CURRENT pointer
 581 04-107 317                    LBM                    ;Fetch the pointer
 582 04-110 010                    INB                    ;Increment it to point to the next character
 583 04-111 371                    LMB                    ;Restore the updated pointer value
 584 04-112 106 240 002            CAL GETCHR             ;Fetch the next character in the expression
 585 04-115 074 275                CPI 275                ;Is the character the "= 9 $ sign?
 586 04-117 150 251 004            JTZ SCAN13             ;If so, have 'less than or equal" combination
 587 04-122 074 276                CPI 276                ;Is the character the "greater than" sign?
 588 04-124 150 267 004            JTZ SCAN15             ;If so, have "less than or greater than" combination
 589 04-127 066 200                LLI 200                ;Else character is not part of the operator. Set L back
 590 04-131 317                    LBM                    ;To the EVAL CURRENT pointer. Fetch the pointer
 591 04-132 011                    DCB                    ;Value and decriment it back one character in the
 592 04-133 371                    LMB                    ;Expression. Restore the original pointer value.
 593 04-134 066 176                LLI 176                ;Have just the 'less than" operator. Set L to the
 594 04-136 076 011                LMI 011                ;PARSER TOKEN storage location and set the value for
 595 04-140 104 351 003            JMP SCANFN             ;The 'less than" sign then go to PARSER entry point.
 596 04-143 074 275     SCAN11:    CPI 275                ;See if character fetched is the "= " sign
 597 04-145 110 206 004            JFZ SCAN12             ;If not, continue checking for an operator
 598 04-150 066 200                LLI 200                ;If yes, set L to the EVAL CURRENT pointer
 599 04-152 317                    LBM                    ;Fetch the pointer
 600 04-153 010                    INB                    ;Increment it to point to the next character
 601 04-154 371                    LMB                    ;Restore the updated pointer value
 602 04-155 106 240 002            CAL GETCHR             ;Fetch the next character in the expression
 603 04-160 074 274                CPI 274                ;Is the character the "less than" sign?
 604 04-162 150 251 004            JTZ SCAN13             ;If so, have "less than or equal" combination
 605 04-165 074 276                CPI 276                ;Is the character the "greater than" sign?
 606 04-167 150 260 004            JTZ SCAN14             ;If so, have "equal or greater than" combination
 607 04-172 066 200                LLI 200                ;Else character is not part of the operator. Set L back
 608 04-174 317                    LBM                    ;To the EVAL CURRENT pointer. Fetch the pointer
 609 04-175 011                    DCB                    ;Value and decrement it back one character in the
 610 04-176 371                    LMB                    ;Expression. Restore the original pointer value.
 611 04-177 066 176                LLI 176                ;Just have '~-- " operator. Set L to the PARSER TOKEN
 612 04-201 076 012                LMI 012                ;Storage location and set the value for the sign.
 613 04-203 104 351 003            JMP SCANFN             ;Go to the PARSER entry point.
 614 04-206 074 276     SCAN12:    CPI 276                ;See if character fetched is the "greater than" sign
 615 04-210 110 276 004            JFZ SCAN16             ;If not, go append the character to the SYMBOL BUFF
 616 04-213 066 200                LLI 200                ;If so, set L to the EVAL CURRENT pointer
 617 04-215 317                    LBM                    ;Fetch the pointer
 618 04-216 010                    INB                    ;Increment it to point to the next character
 619 04-217 371                    LMB                    ;Restore the updated pointer value
 620 04-220 106 240 002            CAL GETCHR             ;Fetch the next character in the expression
 621 04-223 074 274                CPI 274                ;Is the character the "less than" sign?
 622 04-225 150 267 004            JTZ SCAN15             ;If so, have "less than or greater than" combination
 623 04-230 074 275                CPI 275                ;Is the character the "= " sign?
 624 04-232 150 260 004            JTZ SCAN14             ;If so, have the "equal to or greater than " combination
 625 04-235 066 200                LLI 200                ;Else character is not part of the operator. Set L back
 626 04-237 317                    LBM                    ;To the EVAL CURRENT pointer. Fetch the pointer
 627 04-240 011                    DCB                    ;Value and decrement it back one character in the
 628 04-241 371                    LMB                    ;Expression. Restore the original pointer value.
 629 04-242 066 176                LLI 176                ;Have just the "greater than" operator. Set L to the
 630 04-244 076 013                LMI 013                ;PARSER TOKEN storage location and set the value for
 631 04-246 104 351 003            JMP SCANFN             ;The "greater than" sign then go to PARSER entry
 632 04-251 066 176     SCAN13:    LLI 176                ;When have 'less than or equal" combination set L to
 633 04-253 076 014                LMI 014                ;PARSER TOKEN storage location and set the value.
 634 04-255 104 351 003            JMP SCANFN             ;Then go to the PARSER entry point.
 635 04-260 066 176     SCAN14:    LLI 176                ;When have "equal to or greater than" combination set L
 636 04-262 076 015                LMI 015                ;To PARSER TOKEN storage location and set the value.
 637 04-264 104 351 003            JMP SCANFN             ;Then go to the PARSER entry point.
 638 04-267 066 176     SCAN15:    LLI 176                ;When have 'less than or greater than" combination set
 639 04-271 076 016                LMI 016                ;L to PARSER TOKEN storage location and set value.
 640 04-273 104 351 003            JMP SCANFN             ;Then go to the PARSER entry point.
 641 04-276 106 310 002 SCAN16:    CAL CONCTS             ;Concatenate the character to the SYMBOL BUFFER
 642 04-301 066 200     SCAN10:    LLI 200                ;Set L to the EVAL CURRENT pointer storage location
 643 04-303 056 026                LHI \HB\OLDPG26        ;** Set H to page of EVAL CURRENT pointer
 644 04-305 317                    LBM                    ;Fetch the EVAL CURRENT pointer value into B
 645 04-306 010                    INB                    ;Increment the pointer value to point to next character
 646 04-307 371                    LMB                    ;In the expression and restore the updated value.
 647 04-310 066 277                LLI 277                ;Set L to EVAL FINISH storage location.
 648 04-312 307                    LAM                    ;Fetch the EVAL FINISH value into the accumulator.
 649 04-313 011                    DCB                    ;Set B to last character processed in the expression.
 650 04-314 271                    CPB                    ;See if last character was at EVAL FINISH location.
 651 04-315 110 254 003            JFZ SCAN1              ;If not, continue processing the expression. Else, jump
 652 04-320 104 300 031            JMP PARSEP             ;To final evaluation procedure and test.  (Directs routine
 653 04-323 001                    HLT                    ;To a dislocated section.) Safety Halt in unused byte.
 654 04-324 066 120     PARSER:    LLI 120                ;Load L with starting address of SYMBOL BUFFER
 655 04-326 056 026                LHI \HB\OLDPG26        ;** Load H with page of SYMBOL BUFFER
 656 04-330 307                    LAM                    ;Fetch the (cc) for  contents of SYMBOL BUFFER
 657 04-331 240                    NDA                    ;Into the ACC and see if buffer is  empty
 658 04-332 150 231 005            JTZ PARSE              ;If empty then no need to convert contents
 659 04-335 060                    INL                    ;If not empty, advance buffer pointer
 660 04-336 307                    LAM                    ;Fetch the first character in the buffer
 661 04-337 074 256                CPI 256                ;See if it is ASCII code for decimal sign
 662 04-341 150 356 004            JTZ PARNUM             ;If yes, consider contents of buffer to be a number
 663 04-344 074 260                CPI 260                ;If not decimal sign, see if first character represents
 664 04-346 160 033 005            JTS LOOKUP             ;A deciinal digit, if not, should have a variable
 665 04-351 074 272                CPI 272                ;Continue to test for a decimal digit
 666 04-353 120 033 005            JFS LOOKUP             ;If not, go look up the variable nwne
 667 04-356 061         PARNUM:    DCL                    ;If SYMBOL BUFFER contains number, decrement
 668 04-357 307                    LAM                    ;Buffer pointer back to (cc) and fetch it to ACC
 669 04-360 074 001                CPI 001                ;See if length of string in buffer is just one
 670 04-362 150 005 005            JTZ NOEXPO             ;If so, cannot have number with scientific notation
 671 04-365 206                    ADL                    ;If not, add length to buffer pointer to
 672 04-366 360                    LLA                    ;Point to last character in the buffer
 673 04-367 307                    LAM                    ;Fetch the last character in buffer and see if it
 674 04-370 074 305                CPI 305                ;Represents letter E for Exponent
 675 04-372 110 005 005            JFZ NOEXPO             ;If not, cannot have number with scientific notation
 676 04-375 066 200                LLI 200                ;If yes, have part of a scientific number, set pointer to
 677 04-377 106 240 002            CAL GETCHR             ;Get the operator that follows the E and append it to
 678 05-002 104 310 002            JMP CONCTS             ;The SYMBOL BUFFER and return to EVAL routine
 679 05-005 066 227     NOEXPO:    LLI 227                ;Load L with address of ARITHMETIC STACK pointer
 680 05-007 056 001                LHI \HB\OLDPG1         ;** Load H with page of ARITHMETIC STACK pointer
 681 05-011 307                    LAM                    ;Fetch AS pointer value to ACC and add four to account
 682 05-012 004 004                ADI 004                ;For the number of bytes required to store a number in
 683 05-014 370                    LMA                    ;Floating point format. Restore pointer to mernory.
 684 05-015 360                    LLA                    ;Then, change L to point to entry position in the AS
 685 05-016 106 255 022            CAL FSTORE             ;Place contents of the FPACC onto top of the AS
 686 05-021 066 120                LLI 120                ;Change L to point to start of the SYMBOL BUFFER
 687 05-023 056 026                LHI \HB\OLDPG26        ;** Set H to page of the SYMBOL BUFFER
 688 05-025 106 044 023            CAL DINPUT             ;Convert number in the buffer to floating point format
 689 05-030 104 231 005            JMP PARSE              ;In the FPACC then jump to check operator sign.
 690 05-033 066 370     LOOKUP:    LLI 370                ;Load L with address of LOOK-UP COUNTER
 691 05-035 056 026                LHI \HB\OLDPG26        ;** Load H with page of the counter
 692 05-037 076 000                LMI 000                ;Initialize the counter to zero
 693 05-041 066 120                LLI 120                ;Load L with starting address of the SYMBOL BUFFER
 694 05-043 036 027                LDI \HB\OLDPG27        ;** Load D with page of the VARIABLES TABLE
 695 05-045 046 210                LEI 210                ;Load E with start of the VARL433LES TABLE
 696 05-047 307                    LAM                    ;Fetch the (cc) for the string in the SYMBOL BUFFER
 697 05-050 074 001                CPI 001                ;See if the name length is just one character. If not,
 698 05-052 110 061 005            JFZ LOOKU1             ;Should be two so proceed to look-up routine. Else,
 699 05-055 066 122                LLI 122                ;Change L to second character byte in the buffer and set
 700 05-057 076 000                LMI 000                ;It to zero to provide compatibility with entries in table
 701 05-061 066 121     LOOKU1:    LLI 121                ;Load L with addr of first character in the SYMBOL
 702 05-063 056 026                LHI \HB\OLDPG26        ;** BUFFER. Set H to page of the SYMBOL BUFFER.
 703 05-065 106 356 022            CAL SWITCH             ;Exchange contents of D&E with H&L so that can
 704 05-070 307                    LAM                    ;Fetch the first character of a name in the VARIABLES
 705 05-071 060                    INL                    ;TABLE. Advance the table pointer and save the
 706 05-072 317                    LBM                    ;Second byte of name in B. Then advance the pointer
 707 05-073 060                    INL                    ;Again to reach first bvte of floating point forrnatted
 708 05-074 106 356 022            CAL SWITCH             ;Number in table. Now exchange D&E with H&L and
 709 05-077 277                    CPM                    ;Compare first byte in table against first char in buffer
 710 05-100 110 111 005            JFZ LOOKU2             ;If not the same, go try next entry in table. If same,
 711 05-103 060                    INL                    ;Advance pointer to next char in buffer. Transfer the
 712 05-104 301                    LAB                    ;Character in B (second byte in table entry) to the ACC
 713 05-105 277                    CPM                    ;Compare it against second character in the buffer.
 714 05-106 150 201 005            JTZ LOOKU4             ;If match, have found the name in the VARIABLES tbl.
 715 05-111 106 256 006 LOOKU2:    CAL AD4DE              ;Call subroutine to add four to the pointer in D&E to
 716 05-114 066 370                LLI 370                ;Advance the table pointer over value bytes. Then set
 717 05-116 056 026                LHI \HB\OLDPG26        ;** Up H and L to point to LOOK-UP COUNTER.
 718 05-120 317                    LBM                    ;Fetch counter value (counts number of entries tested
 719 05-121 010                    INB                    ;In the VARIABLES TABLE), increment it
 720 05-122 371                    LMB                    ;And restore it back to meynory
 721 05-123 066 077                LLI 077                ;Load L with address of SYMBOL VARIABLES counter
 722 05-125 056 027                LHI \HB\OLDPG27        ;** Do same for H. (Counts number of names in table.)
 723 05-127 301                    LAB                    ;Place LOOK-UP COUNTER value in the accumulator.
 724 05-130 277                    CPM                    ;Compare it with number of entries in the table.
 725 05-131 110 061 005            JFZ LOOKU1             ;If have not reached end of table, keep looking for name.
 726 05-134 066 077                LLI 077                ;If reach end of table without match, need to add name
 727 05-136 056 027                LHI \HB\OLDPG27        ;** To table. First set H & L to the SYMBOL
 728 05-140 317                    LBM                    ;VARIABLES counter. Fetch the counter value and
 729 05-141 010                    INB                    ;Increment to account for new name being added to the
 730 05-142 371                    LMB                    ;Table. Restore the updated count to meinory. Also,
 731 05-143 301                    LAB                    ;Move the new counter value to the accumulator and
 732 05-144 074 025                CPI 025                ;Check to see that table size is not exceeded. If try to
 733 05-146 120 222 002            JFS BIGERR             ;Go over 20 (decirnal) entries then have BIG error.
 734 05-151 066 121                LLI 121                ;Else, set L to point to first character in the SYMBOL
 735 05-153 056 026                LHI \HB\OLDPG26        ;** BUFFER and set H to proper page. Set the number
 736 05-155 016 002                LBI 002                ;Of bytes to be transferred into register B as a counter.
 737 05-157 106 013 021            CAL MOVEIT             ;Move the symbol name from the buffer to the
 738 05-162 364                    LLE                    ;VARIABLES TABLE. Now set up H & L with value
 739 05-163 353                    LHD                    ;Contained in D & E after moving ops (points to first
 740 05-164 250                    XRA                    ;Byte of the value to be associated with the symbol
 741 05-165 370                    LMA                    ;Name.) Clear the accumulator and place zero in all four
 742 05-166 060                    INL                    ;Bytes associated with the variable name entered
 743 05-167 370                    LMA                    ;In the VARIABLES TABLE
 744 05-170 060                    INL                    ;In order to
 745 05-171 370                    LMA                    ;Assign an
 746 05-172 060                    INL                    ;Initial value
 747 05-173 370                    LMA                    ;To the variable narne
 748 05-174 306                    LAL                    ;Then transfer the address in L to the acc'umulator
 749 05-175 024 004                SUI 004                ;Subtract four to reset the pointer to start of zeroing ops
 750 05-177 340                    LEA                    ;Restore the address in D & E to be in same state as if
 751 05-200 335                    LDH                    ;Name was found in the table in the LOOKUP routine
 752 05-201 106 317 022 LOOKU4:    CAL SAVEHL             ;Save current address to VARIABLES TABLE
 753 05-204 066 227                LLI 227                ;Load L with address of ARITHMETIC STACK pointer
 754 05-206 056 001                LHI \HB\OLDPG1         ;** Load H with page of the pointer
 755 05-210 307                    LAM                    ;Fetch the AS pointer value to the accumulator
 756 05-211 004 004                ADI 004                ;Add four to account for next floating point forrnatted
 757 05-213 370                    LMA                    ;Number to be stored in the stack. Restore the stack
 758 05-214 360                    LLA                    ;Pointer to memory and set it up in register L too.
 759 05-215 106 255 022            CAL FSTORE             ;Place the value in the FPACC on the top of the
 760 05-220 106 337 022            CAL RESTHL             ;ARITHMETIC STACK. Restore the VARIABLES
 761 05-223 106 356 022            CAL SWITCH             ;TABLE pointer to H&L and move it to D&E. Now load
 762 05-226 106 244 022            CAL FLOAD              ;The VARIABLE value from the table to the FPACC.
 763 05-231 106 255 002 PARSE:     CAL CLESYM             ;Clear the SYMBOL BUFFER
 764 05-234 066 176                LLI 176                ;Load L with address of PARSER TOKEN VALUE
 765 05-236 307                    LAM                    ;And fetch the token value into the accumulator
 766 05-237 074 007                CPI 007                ;Is it token value for right parenthesis ")" ? If so, have
 767 05-241 150 332 005            JTZ PARSE2             ;Special case where must perforin ops til find a "(" !
 768 05-244 004 240                ADI 240                ;Else, fon-n address to HEIRARCHY IN table and
 769 05-246 360                    LLA                    ;Set L to point to HEIRARCHY IN VALUE in the table
 770 05-247 317                    LBM                    ;Fetch the heirarchy value from the table to register B
 771 05-250 066 210                LLI 210                ;Set L to OPERATOR STACK pointer storage location
 772 05-252 327                    LCM                    ;Fetch the OS pointer into CPU register C
 773 05-253 106 036 023            CAL INDEXC             ;Add OS pointer to address of OS pointer storage loc
 774 05-256 307                    LAM                    ;Fetch the token value for the operator at top of the OS
 775 05-257 004 257                ADI 257                ;And form address to HEIRARCHY OUT table
 776 05-261 360                    LLA                    ;Set L to point to HEIRARCHY OUT VALUE in the
 777 05-262 301                    LAB                    ;Table. Move the HEIRARCHY IN value to the ACC.
 778 05-263 277                    CPM                    ;Compare the HEIRARCHY IN with the HEIRARCHY
 779 05-264 150 307 005            JTZ PARSE1             ;OUT value. If heirarchy of current operator equal to or
 780 05-267 160 307 005            JTS PARSE1             ;Less than operator on top of OS stack, perfo
 781 05-272 066 176                LLI 176                ;Operation indicated in top of OS stack. Else, fetch the
 782 05-274 317                    LBM                    ;Current operator token value into register B.
 783 05-275 066 210                LLI 210                ;Load L with address of the OPERATOR STACK pntr
 784 05-277 327                    LCM                    ;Fetch the stack pointer value
 785 05-300 020                    INC                    ;Increment it to account for new entry on the stack
 786 05-301 372                    LMC                    ;Restore the stack pointer value to memory
 787 05-302 106 036 023            CAL INDEXC             ;For in pointer to next entry in OPERATOR STACK
 788 05-305 371                    LMB                    ;Place the current operator token value on top of the OS
 789 05-306 007                    RET                    ;Exit back to the EVAL routine.
 790 05-307 066 210     PARSE1:    LLI 210                ;Load L with address of the OPERATOR STACK pntr
 791 05-311 307                    LAM                    ;Fetch the stack pointer value to the accumulator
 792 05-312 206                    ADL                    ;Add in the value of the stack pointer address to form
 793 05-313 360                    LLA                    ;Address that points to top entry in the OS
 794 05-314 307                    LAM                    ;Fetch the token value at the top of the OS to the ACC
 795 05-315 240                    NDA                    ;Check to see if the token value is zero for end of stack
 796 05-316 053                    RTZ                    ;Exit back to the EVAL routine if stack empty
 797 05-317 066 210                LLI 210                ;Else, reset L to the OS pointer storage location
 798 05-321 327                    LCM                    ;Fetch the pointer value
 799 05-322 021                    DCC                    ;Decrement it to account for operator rernoved from
 800 05-323 372                    LMC                    ;The OPERATOR STACK and restore the pointer value
 801 05-324 106 364 005            CAL FPOPER             ;Perform the operation obtained from the top of the OS
 802 05-327 104 231 005            JMP PARSE              ;Continue to compare current operator against top of OS
 803 05-332 066 210     PARSE2:    LLI 210                ;Load L with address of the OPERATOR STACK pntr
 804 05-334 056 026                LHI \HB\OLDPG26        ;** Load H with page of the pointer
 805 05-336 307                    LAM                    ;Fetch the stack pointer value to the accumulator
 806 05-337 206                    ADL                    ;Add in the value of the stack pointer address to form
 807 05-340 360                    LLA                    ;Address that points to top entry in the OS
 808 05-341 307                    LAM                    ;Fetch the token value at the top of the 0 S to the ACC
 809 05-342 240                    NDA                    ;Check to see if the token value is zero for end of stack
 810 05-343 150 104 006            JTZ PARNER             ;If end of stack, then have a parenthesis error condx
 811 05-346 066 210                LLI 210                ;Else, reset L to the OS pointer storage location
 812 05-350 327                    LCM                    ;Fetch the pointer value
 813 05-351 021                    DCC                    ;Decrement it to account for operator removed from
 814 05-352 372                    LMC                    ;The OPERATOR STACK and restore the pointer value
 815 05-353 074 006                CPI 006                ;Check to see if token value is "(" to close parenthesis
 816 05-355 053                    RTZ                    ;If so, exit back to EVAL routine.
 817 05-356 106 364 005            CAL FPOPER             ;Else, perforin the op obtained from the top of the OS
 818 05-361 104 332 005            JMP PARSE2             ;Continue to process data in parenthesis
 819 05-364 066 371     FPOPER:    LLI 371                ;Load L with address of TEMP OP storage location
 820 05-366 056 026                LHI \HB\OLDPG26        ;** Load H with page of TEMP OP storage location
 821 05-370 370                    LMA                    ;Store OP (from top of OPERATOR STACK)
 822 05-371 066 227                LLI 227                ;Change L to address of ARff HMETIC STACK pointer
 823 05-373 056 001                LHI \HB\OLDPG1         ;** Load H with page of AS pointer
 824 05-375 307                    LAM                    ;Fetch AS pointer value into ACC
 825 05-376 360                    LLA                    ;Set L to top of ARITHMETIC STACK
 826 05-377 106 266 022            CAL OPLOAD             ;Transfer number from ARffHMETIC STACK to FPOP
 827 06-002 066 227                LLI 227                ;Restore pointer to AS pointer
 828 06-004 307                    LAM                    ;Fetch the pointer value to the ACC and subtract four
 829 06-005 024 004                SUI 004                ;To remove top value from the ARITHMETIC STACK
 830 06-007 370                    LMA                    ;Restore the updated AS pointer to memory
 831 06-010 066 371                LLI 371                ;Set L to address of TEMP OP storage location
 832 06-012 056 026                LHI \HB\OLDPG26        ;** Set H to page of TEMP OP storage location
 833 06-014 307                    LAM                    ;Fetch the operator token value to the ACC
 834 06-015 074 001                CPI 001                ;Find out which kind of operation indicated
 835 06-017 150 211 020            JTZ FPADD              ;Perforn addition if have plus operator
 836 06-022 074 002                CPI 002                ;If not plus, see if minus
 837 06-024 150 032 021            JTZ FPSUB              ;Perform subtraction if have minus operator
 838 06-027 074 003                CPI 003                ;If not minus, see if multiplication
 839 06-031 150 046 021            JTZ FPMULT             ;Perform multiplication if have multiplication operator
 840 06-034 074 004                CPI 004                ;If not multiplication, see if division
 841 06-036 150 322 021            JTZ FPDIV              ;Perform division if have division operator
 842 06-041 074 005                CPI 005                ;If not division, see if exponentiation
 843 06-043 150 263 006            JTZ INTEXP             ;Perform exponentiation if have exponentiation operator
 844 06-046 074 011                CPI 011                ;If not exponentiation, see if "less than" operator
 845 06-050 150 121 006            JTZ LT                 ;Perform compaison for "less than" op if indicated
 846 06-053 074 012                CPI 012                ;If not 'less than" see if have "equal" operator
 847 06-055 150 136 006            JTZ EQ                 ;Perforin comparison for "equal" op if indicated
 848 06-060 074 013                CPI 013                ;If not "equal" see if have "greater than" operator
 849 06-062 150 153 006            JTZ GT                 ;Perform comparison for "greater than" op if indicated
 850 06-065 074 014                CPI 014                ;If not "'greater than" see if have 'less than or equal" op
 851 06-067 150 173 006            JTZ LE                 ;Perform comparison for the combination op if indicated
 852 06-072 074 015                CPI 015                ;See if have "equal to or greater than" operator
 853 06-074 150 213 006            JTZ GE                 ;Perform comparison for the combination op if indicated
 854 06-077 074 016                CPI 016                ;See if have "less than or greater than" operator
 855 06-101 150 230 006            JTZ NE                 ;Perform comparison for the combination op if indicated
 856 06-104 066 230     PARNER:    LLI 230                ;If cannot find operator, expression is not balanced
 857 06-106 056 026                LHI \HB\OLDPG26        ;** Set H and L to address of F/A STACK pointer
 858 06-110 076 000                LMI 000                ;Clear the F/A STACK pointer to re-initialize
 859 06-112 006 311                LAI 311                ;Load ASCII code for letter I into the accumulator
 860 06-114 026 250                LCI 250                ;And code for "(" character into register C
 861 06-116 104 226 002            JMP ERROR              ;Go display 1( for "Imbalanced Parenthesis") error msg
 862 06-121 106 032 021 LT:        CAL FPSUB              ;Subtract contents of FPACC from FPOP to compare
 863 06-124 066 126                LLI 126                ;Set L to point to the MSW of the FPACC (Contains
 864 06-126 307                    LAM                    ;Result of the subtraction.) Fetch the MSW of the
 865 06-127 240                    NDA                    ;FPACC to the accumulator and test to see if result is
 866 06-130 160 242 006            JTS CTRUE              ;Positive or negative. Set up the FPACC as a function
 867 06-133 104 247 006            JMP CFALSE             ;Of the result obtained.
 868 06-136 106 032 021 EQ:        CAL FPSUB              ;Subtract contents of FPACC from FPOP to compare
 869 06-141 066 126                LLI 126                ;Set L to point to the MSW of the FPACC (Contains
 870 06-143 307                    LAM                    ;Result of the subtraction.) Fetch the MSW of the
 871 06-144 240                    NDA                    ;FPACC to the accumulator and test to see if result is
 872 06-145 150 242 006            JTZ CTRUE              ;Equal. Set up the FPACC as a function
 873 06-150 104 247 006            JMP CFALSE             ;Of the result obtained.
 874 06-153 106 032 021 GT:        CAL FPSUB              ;Subtract contents of FPACC from FPOP to compare
 875 06-156 066 126                LLI 126                ;Set L to point to the MSW of the FPACC (Contains
 876 06-160 307                    LAM                    ;Result of the subtraction.) Fetch the MSW of the
 877 06-161 240                    NDA                    ;FPACC to the accumulator and test to see if result is
 878 06-162 150 247 006            JTZ CFALSE             ;Positive, Negative, or Equal. Set up the FPACC
 879 06-165 120 242 006            JFS CTRUE              ;As a function
 880 06-170 104 247 006            JMP CFALSE             ;Of the result obtained.
 881 06-173 106 032 021 LE:        CAL FPSUB              ;Subtract contents of FPACC from FPOP to compare
 882 06-176 066 126                LLI 126                ;Set L to point to the MSW of the FPACC (Contains
 883 06-200 307                    LAM                    ;Result of the subtraction.) Fetch the MSW of the
 884 06-201 240                    NDA                    ;FPACC to the accumulator and test to see if result is
 885 06-202 150 242 006            JTZ CTRUE              ;Positive, Negative, or Equal. Set up the FPACC
 886 06-205 160 242 006            JTS CTRUE              ;As a function
 887 06-210 104 247 006            JMP CFALSE             ;Of the result obtained
 888 06-213 106 032 021 GE:        CAL FPSUB              ;Submit contents of FPACC from FPOP to compare
 889 06-216 066 126                LLI 126                ;Set L to point to the MSW of the FPACC (Contains
 890 06-220 307                    LAM                    ;Result of the subtraction.) Fetch the MSW of the
 891 06-221 240                    NDA                    ;FPACC to the accumulator and test to see if result is
 892 06-222 120 242 006            JFS CTRUE              ;Positive or Negative. Set up the FPACC
 893 06-225 104 247 006            JMP CFALSE             ;As a function of the result obtained
 894 06-230 106 032 021 NE:        CAL FPSUB              ;Subtract contents of FPACC from FPOP to compare
 895 06-233 066 126                LLI 126                ;Set L to point to the MSW of the FPACC (Contains
 896 06-235 307                    LAM                    ;Result of the subtraction.) Fetch the MSW of the
 897 06-236 240                    NDA                    ;FPACC to the accumulator and test to see if result is
 898 06-237 150 247 006            JTZ CFALSE             ;Equal. Set up the FPACC as a function of the result.
 899                    CTRUE:
 900 06-242 066 004     FPONE:     LLI 004                ;Load L with address of floating point value +1.0
 901 06-244 104 244 022            JMP FLOAD              ;Load FPACC with value +1.0 and exit to caller
 902 06-247 066 127     CFALSE:    LLI 127                ;Load L with address of FPACC Exponent register
 903 06-251 076 000                LMI 000                ;Set the FPACC Exponent to zero and then set the
 904 06-253 104 051 020            JMP FPZERO             ;Mantissa portion of the FPACC to zero. Exit to caller.
 905 06-256 304         AD4DE:     LAE                    ;Subroutine to add four to the value in register E.
 906 06-257 004 004                ADI 004                ;Move contents of E to the ACC and add four.
 907 06-261 340                    LEA                    ;Restore the updated value back to register E.
 908 06-262 007                    RET                    ;Return to the calling routine.
 909 06-263 066 126     INTEXP:    LLI 126                ;Load L with address of WSW of FPACC (Floating Point
 910 06-265 056 001                LHI \HB\OLDPG1         ;** ACCumulator). Load H with page of FPACC.
 911 06-267 307                    LAM                    ;Fetch MSW of the FPACC into the accumulator.
 912 06-270 066 003                LLI 003                ;Load L with address of EXP TEMP storage location
 913 06-272 370                    LMA                    ;Store the FPACC MSW value in EXP TEMP location
 914 06-273 240                    NDA                    ;Test contents of the MSW of the FPACC. ff zero, then
 915 06-274 150 242 006            JTZ FPONE              ;Set FPACC equal to +1.0 (any nr to zero power = 1.0!)
 916 06-277 162 202 020            CTS FPCOMP             ;If MSW indicates negative number, complement
 917 06-302 106 000 020            CAL FPFIX              ;The FPACC. Then convert floating point number to
 918 06-305 066 124                LLI 124                ;Fixed point. Load L with address of LSW of fixed nr
 919 06-307 317                    LBM                    ;Fetch the LSW into CPU register B.
 920 06-310 066 013                LLI 013                ;Set L to address of EXPONENT COUNTER
 921 06-312 371                    LMB                    ;Place the fixed value in the EXP CNTR to indicate
 922 06-313 066 134                LLI 134                ;Number of multiplications needed (power). Now set L
 923 06-315 046 014                LEI 014                ;To LSW of FPOP and E to address of FP TEMP (LSW)
 924 06-317 056 001                LHI \HB\OLDPG1         ;** Set H to floating point working area page.
 925 06-321 335                    LDH                    ;Set D to same page address.
 926 06-322 016 004                LBI 004                ;Set transfer (precision) counter. Call subroutine to move
 927 06-324 106 013 021            CAL MOVEIT             ;Contents of FPOP into FP TEMP registers to save
 928 06-327 106 242 006            CAL FPONE              ;Original value of FPOP. Now set FPACC to +1.0.
 929 06-332 066 003                LLI 003                ;Load L with pointer to original value of FPACC
 930 06-334 307                    LAM                    ;(Stored in FP TEMP) MSW and fetch contents to ACC.
 931 06-335 240                    NDA                    ;Test to see if raising to a negative power. If so, divide
 932 06-336 160 362 006            JTS DVLOOP             ;Instead of multiply!
 933 06-341 066 014     MULOOP:    LLI 014                ;Load L with address of LSW of FP TEMP (original
 934 06-343 106 277 022            CAL FACXOP             ;Value in FPOP). Move FP TEMP into FPOP.
 935 06-346 106 046 021            CAL FPMULT             ;Multiply FPACC by FPOP. Result left in FPACC.
 936 06-351 066 013                LLI 013                ;Load L with address of EXPONENT COUNTER.
 937 06-353 317                    LBM                    ;Fetch the counter value
 938 06-354 011                    DCB                    ;Decrement it
 939 06-355 371                    LMB                    ;Restore it to memory
 940 06-356 110 341 006            JFZ MULOOP             ;If counter not zero, continue exponentiation process
 941 06-361 007                    RET                    ;When have raised to proper power, return to caller.
 942 06-362 066 014     DVLOOP:    LLI 014                ;Load L with address of LSW of FP TEMP (original
 943 06-364 106 277 022            CAL FACXOP             ;Value in FPOP). Move FP TEMP into FPOP.
 944 06-367 106 322 021            CAL FPDIV              ;Divide FPACC by FPOP. Result left in FPACC.
 945 06-372 066 013                LLI 013                ;Load L with address of EXPONENT COUNTER
 946 06-374 317                    LBM                    ;Fetch the counter value
 947 06-375 011                    DCB                    ;Decrement it
 948 06-376 371                    LMB                    ;Restore to memory
 949 06-377 110 362 006            JFZ DVLOOP             ;If counter not zero, continue exponentiation process
 950 07-002 007                    RET                    ;When have raised to proper power, return to caller.
 951                    
 952                    ;;; The label PRIGHT: SHOULD BE UP TO 07 003
 953 07-003 066 230     PRIGHT:    LLI 230                ;Load L with address of F/A STACK pointer
 954 07-005 056 026                LHI \HB\OLDPG26        ;** Load H with page of F/A STACK pointer
 955 07-007 307                    LAM                    ;Fetch the pointer value into the ACC
 956 07-010 206                    ADL                    ;Form pointer to top of the F/A STACK
 957 07-011 360                    LLA                    ;Set L to point to top of the F/A STACK
 958 07-012 307                    LAM                    ;Fetch the contents of the top of the F/A STACK into
 959 07-013 076 000                LMI 000                ;The ACC then clear the top of the F/A STACK
 960 07-015 066 203                LLI 203                ;Load L with address of F /A STACK TEMP storage
 961 07-017 056 027                LHI \HB\OLDPG27        ;** Location. Set H to page of F/A STACK TEMP
 962 07-021 370                    LMA                    ;Store value from top of F/A STACK into temp loc.
 963 07-022 240                    NDA                    ;Test to see if token value in top of stack was zero
 964 07-023 053                    RTZ                    ;If so, just had simple grouping parenthesis!
 965 07-024 160 000 055            JTS PRIGH1             ;@@ If token value minus, indicates array subscript
 966 07-027 074 001                CPI 001                ;For positive token value, look for appropriate function
 967 07-031 150 243 007            JTZ INTX               ;If token value for INTeger function, go do it.
 968 07-034 074 002                CPI 002                ;Else, see if token value for SIGN function.
 969 07-036 150 360 007            JTZ SGNX               ;If so, go do it.
 970 07-041 074 003                CPI 003                ;Else, see if token value for ABSolute function
 971 07-043 150 346 007            JTZ ABSX               ;If so, go do it.
 972 07-046 074 004                CPI 004                ;If not, see if token value for SQuare Root function
 973 07-050 150 000 032            JTZ SQRX               ;If so, go do it.
 974 07-053 074 005                CPI 005                ;If not, see if token value for TAB function
 975 07-055 150 017 010            JTZ TABX               ;If so, go do it.
 976 07-060 074 006                CPI 006                ;If not, see if token value for RaNDom function
 977 07-062 150 240 032            JTZ RNDX               ;If so, go find a random number.
 978 07-065 074 007                CPI 007                ;If not, see if token value for CHaRacter function
 979 07-067 150 377 007            JTZ CHRX               ;If so, go perform the function.
 980 07-072 074 010                CPI 010                ;Else, see if token for user defined machine language
 981 07-074 150 135 000            JTZ UDEFX              ;# Function. If so, perform the User DEfined Function
 982 07-077 001                    HLT                    ;Safety halt. Program should not reach this location!
 983                    
 984                    ;;; The label FUNARR SHOULD BE AT 07 100
 985 07-100 066 120     FUNARR:    LLI 120                ;Load L with starting address of SYMBOL BUFFER
 986 07-102 056 026                LHI \HB\OLDPG26        ;** Load H with page of SYMBOL BUFFER
 987 07-104 307                    LAM                    ;Fetch the (cc) for contents of buffer to the ACC
 988 07-105 240                    NDA                    ;See if (cc) is zero, if so buffer is empty, return to
 989 07-106 053                    RTZ                    ;Caller as have simple grouping parenthesis sign
 990 07-107 066 202                LLI 202                ;Else set L to TEMP COUNTER location
 991 07-111 056 027                LHI \HB\OLDPG27        ;** Set H to TEMP COUNTER page
 992 07-113 076 000                LMI 000                ;Initialize TEMP COUNTER to zero
 993 07-115 066 202     FUNAR1:    LLI 202                ;Load L with address of TEMP COUNTER
 994 07-117 056 027                LHI \HB\OLDPG27        ;** Load H with page of TEMP COUNTER
 995 07-121 317                    LBM                    ;Fetch the counter value to register B
 996 07-122 010                    INB                    ;Increment the counter
 997 07-123 371                    LMB                    ;Restore the updated value to memory
 998 07-124 026 002                LCI 002                ;Initialize C to a value of two for future ops
 999 07-126 066 274                LLI 274                ;Load L with starting address (less four) of FUNCTION
1000 07-130 056 026                LHI \HB\OLDPG26        ;** LOOK-UP TABLE. Set H to table page.
1001 07-132 106 230 007            CAL TABADR             ;Find address of next entry in the table
1002 07-135 036 026                LDI \HB\OLDPG26        ;** Load D with page of SYMBOL BUFFER
1003 07-137 046 120                LEI 120                ;Load E with starting address of SYMBOL BUFFER
1004 07-141 106 332 002            CAL STRCP              ;Compare entry in FUNCTION LOOK-UP TABLE with
1005 07-144 150 207 007            JTZ FUNAR4             ;Contents of SYMBOL BUFFER. If find match, go set
1006 07-147 066 202                LLI 202                ;Up the function token value. Else, set L to the TEMP
1007 07-151 056 027                LHI \HB\OLDPG27        ;** COUNTER and set H to the proper page. Fetch the
1008 07-153 307                    LAM                    ;Current counter value and see if have tried all eight
1009 07-154 074 010                CPI 010                ;Possible functions in the table.
1010 07-156 110 115 007            JFZ FUNAR1             ;If not, go back and check the next entry.
1011 07-161 066 202                LLI 202                ;If have tried all of the entries in the table, set L
1012 07-163 056 027                LHI \HB\OLDPG27        ;** As well as H to the address of the TEMP COUI,.7ER
1013 07-165 076 000                LMI 000                ;And reset it to zero. Now go see if have subscripted
1014 07-167 104 054 055            JMP FUNAR2             ;@@ Array (unless array capability not in program).
1015 07-172 066 230     FAERR:     LLI 230                ;Load L with address of F/A STACK pointer
1016 07-174 056 026                LHI \HB\OLDPG26        ;** Load H with page of F/A STACK pointer
1017 07-176 076 000                LMI 000                ;Clear the F/A STACK pointer to reset on an error
1018 07-200 006 306                LAI 306                ;Load the ASCII code for letter F into the ACC
1019 07-202 026 301                LCI 301                ;Load the ASCII code for letter A into register C
1020 07-204 104 226 002            JMP ERROR              ;Go display the FA error message
1021 07-207 066 202     FUNAR4:    LLI 202                ;Load L with address of TEMP COUNTER
1022 07-211 056 027                LHI \HB\OLDPG27        ;** Set H to page of TEMP COUNTER
1023 07-213 317                    LBM                    ;Load value in counter to register B. This is FUNCTION
1024 07-214 066 230                LLI 230                ;TOKEN VALUE. Cbange- L to F/A STACK pointer.
1025 07-216 056 026                LHI \HB\OLDPG26        ;** Load H with page of F/A STACK pointer.
1026 07-220 327                    LCM                    ;Fetch the F/A STACK pointer value into register C.
1027 07-221 106 036 023            CAL INDEXC             ;Form the address to the top of the F/A STACK.
1028 07-224 371                    LMB                    ;Store the FUNCTION TOKEN VALUE in the F/A
1029 07-225 104 255 002            JMP CLESYM             ;STACK. Then exit by clearing the SYMBOL BUFFER.
1030 07-230 301         TABADR:    LAB                    ;Move the TEMP COUNTER value from B to ACC
1031 07-231 002         TABAD1:    RLC                    ;Multiply by four using this loop to form value equal
1032 07-232 021                    DCC                    ;To number of bytes per entry (4) times current entry
1033 07-233 110 231 007            JFZ TABAD1             ;In the FUNCTION LOOK-UP TABLE.
1034 07-236 206                    ADL                    ;Add this value to the starting address of the table.
1035 07-237 360                    LLA                    ;Form pointer to next entry in table
1036 07-240 003                    RFC                    ;If no carry return to caller
1037 07-241 050                    INH                    ;Else, increment H before
1038 07-242 007                    RET                    ;Returning to caller
1039                    
1040                    ;;; The label INTX SHOULD BE AT 07 243
1041 07-243 066 126     INTX:      LLI 126                ;Load L with address of MSW of the FPACC
1042 07-245 056 001                LHI \HB\OLDPG1         ;** Load H with the page of the PPACC
1043 07-247 307                    LAM                    ;Fetch the MSW of the FPACC into the accumulator
1044 07-250 240                    NDA                    ;Test the sign of the number in the FPACC. If
1045 07-251 120 327 007            JFS INT1               ;Positive jump ahead to integerize
1046 07-254 066 014                LLI 014                ;If negative, load L with address of FP TEMP registers
1047 07-256 106 255 022            CAL FSTORE             ;Store the value in the FPACC in FP TEMP
1048 07-261 106 000 020            CAL FPFIX              ;Convert the value in FPACC from floating point to
1049 07-264 066 123                LLI 123                ;Fixed point. Load L with address of FPACC
1050 07-266 076 000                LMI 000                ;Extension register and clear it.
1051 07-270 106 064 020            CAL FPFLT              ;Convert fixed binary back to FP to integerize
1052 07-273 066 014                LLI 014                ;Load L with address of FP TEMP registers
1053 07-275 106 266 022            CAL OPLOAD             ;Load the value in FP TEMP into FPOP
1054 07-300 106 032 021            CAL FPSUB              ;Subtract integerized value from original
1055 07-303 066 126                LLI 126                ;Set L to address of MSW of FPACC
1056 07-305 307                    LAM                    ;Fetch the MSW of the FPACC into the accumulator
1057 07-306 240                    NDA                    ;See if original value and integerized value the same
1058 07-307 150 341 007            JTZ INT2               ;If so, have integer value in FP TEMP
1059 07-312 066 014                LLI 014                ;Else, load L with address of FP TEMP registers
1060 07-314 106 244 022            CAL FLOAD              ;Restore FPACC to original (non-integerized) value
1061 07-317 066 024                LLI 024                ;Set L to register containing small value
1062 07-321 106 277 022            CAL FACXOP             ;Set up to add small value to original value in FPACC
1063 07-324 106 211 020            CAL FPADD              ;Perform the addition
1064 07-327 106 000 020 INT1:      CAL FPFIX              ;Convert the number in FPACC from floating point
1065 07-332 066 123                LLI 123                ;To fixed point. Load L with address of FPACC
1066 07-334 076 000                LMI 000                ;Extension register and clear it. Now convert the number
1067 07-336 104 064 020            JMP FPFLT              ;Back to floating point to integerize it and exit to caller
1068 07-341 066 014     INT2:      LLI 014                ;Load L with address of FP TEMP registers. Transfer
1069 07-343 104 244 022            JMP FLOAD              ;Number from FP TEMP (orig) to FPACC and return.
1070 07-346 066 126     ABSX:      LLI 126                ;Load L with address of MSW of the FPACC
1071 07-350 056 001                LHI \HB\OLDPG1         ;** Set H to page of the FPACC
1072 07-352 307                    LAM                    ;Fetch the MSW of the FPACC into the accumulator
1073 07-353 240                    NDA                    ;Test the sign of the number to see if it is positive.
1074 07-354 160 202 020            JTS FPCOMP             ;If negative, complement the number before returning.
1075 07-357 007                    RET                    ;Else, just return with absolute value in the FPACC.
1076 07-360 066 126     SGNX:      LLI 126                ;Load L with address of MSW of the FPACC
1077 07-362 056 001                LHI \HB\OLDPG1         ;** Load H with the page of the FPACC
1078 07-364 307                    LAM                    ;Fetch the MSW of the FPACC into the accumulator
1079 07-365 240                    NDA                    ;Test to see if the FPACC is zero
1080 07-366 053                    RTZ                    ;Return to caller if FPACC is zero
1081 07-367 120 242 006            JFS FPONE              ;If FPACC is positive, load +1.0 into FPACC and exit
1082 07-372 066 024                LLI 024                ;If FPACC is negative, set up to load -1.0 into the
1083 07-374 104 244 022            JMP FLOAD              ;FPACC and exit to caller
1084 07-377 106 000 020 CHRX:      CAL FPFIX              ;Convert contents of FPACC from floating point to
1085 10-002 066 124                LLI 124                ;Fixed point. Load L with address of LSW of fixed
1086 10-004 307                    LAM                    ;Value. Fetch this byte into the accumulator.
1087 10-005 106 202 003            CAL ECHO               ;Display the value.
1088 10-010 066 177                LLI 177                ;Set L to address of the TAB FLAG
1089 10-012 056 026                LHI \HB\OLDPG26        ;** Set H to page of the TAB FLAG
1090 10-014 076 377                LMI 377                ;Set TAB FLAG (to inhibit display of FP value)
1091 10-016 007                    RET                    ;Exit to caller.
1092 10-017 106 000 020 TABX:      CAL FPFIX              ;Convert contents of FPACC from floating point to
1093 10-022 066 124     TAB1:      LLI 124                ;Fixed point. Load L with address of 1,SW of fixed
1094 10-024 307                    LAM                    ;Value. Fetch this byte into the accumulator.
1095 10-025 066 043                LLI 043                ;Load L with address of COLUMN COUNTER
1096 10-027 227                    SUM                    ;Subtract value in C-OLUMN COUNTER from desired
1097 10-030 066 177                LLI 177                ;TAB position. Load L with address of the TAB FLAG.
1098 10-032 056 026                LHI \HB\OLDPG26        ;** Set H to page of the TAB FLAG.
1099 10-034 076 377                LMI 377                ;Set TAB FLAG (to inhibit display of FP value)
1100 10-036 160 217 031            JTS BACKSP             ;If beyond TAB point desired, simulate back spacing
1101 10-041 053                    RTZ                    ;Return to caller if at desired TAB location
1102 10-042 320         TABC:      LCA                    ;Else, put difference count in register C
1103 10-043 006 240                LAI 240                ;Place ASCII code for space in ACC
1104 10-045 106 202 003 TABLOP:    CAL ECHO               ;Display space on output device
1105 10-050 021                    DCC                    ;Decrement displacement counter
1106 10-051 110 045 010            JFZ TABLOP             ;If have not reached TAB position, continue to space
1107 10-054 007                    RET                    ;Else, return to calling routine.
1108                    
1109                    ;;; The label STOSYM should be AT 10 055
1110 10-055 066 201     STOSYM:    LLI 201                ;Load L with address of ARRAY FLAG
1111 10-057 056 027                LHI \HB\OLDPG27        ;** Load H with page of ARRAY FLAG
1112 10-061 307                    LAM                    ;Fetch the value of the ARRAY FLAG into the ACC
1113 10-062 240                    NDA                    ;Check to see if the flag is set indicating processing an
1114 10-063 150 100 010            JTZ STOSY1             ;Array variable value. Jump ahead if flag not set.
1115 10-066 076 000                LMI 000                ;If ARRAY FLAG was set, clear it for next time.
1116 10-070 066 204                LLI 204                ;Then load L with address of array address storage loc
1117 10-072 367                    LLM                    ;Fetch the array storage address as new pointer
1118 10-073 056 057                LHI \HB\OLDPG57        ;tt Set H to ARRAY VALUES page   ****************
1119 10-075 104 255 022            JMP FSTORE             ;Store the array variable value and exit to caller.
1120 10-100 066 370     STOSY1:    LLI 370                ;Load L with address of TEMP CNTR
1121 10-102 056 026                LHI \HB\OLDPG26        ;** Load H with page of TEMP CNTR
1122 10-104 076 000                LMI 000                ;Initialize the TEMP CNTR by clearing it
1123 10-106 066 120                LLI 120                ;Load L with starting address of SYMBOL BUFFER
1124 10-110 036 027                LDI \HB\OLDPG27        ;** Load D with page of VARIABLES LOOK-UP table
1125 10-112 046 210                LEI 210                ;Load E with starting addr of VARIABLES LOOK-UP
1126 10-114 307                    LAM                    ;Table. Fetch the (cc) for the SYMBOL BUFFER into
1127 10-115 074 001                CPI 001                ;The ACC and see if length of variable name is just one
1128 10-117 110 126 010            JFZ STOSY2             ;Character. If not, skip next couple of instructions.
1129 10-122 066 122                LLI 122                ;Else, set pointer to second character location in the
1130 10-124 076 000                LMI 000                ;SYMBOL BUFFER and set it to zero
1131 10-126 066 121     STOSY2:    LLI 121                ;load L with address of first character in the SYMBOL
1132 10-130 056 026                LHI \HB\OLDPG26        ;** BUFFER. Load H with page of the buffer.
1133 10-132 106 356 022            CAL SWITCH             ;Exchange pointer to buffer for pointer to VARIABLES
1134 10-135 307                    LAM                    ;LOOK-UP table. Fetch first char in a name from the
1135 10-136 060                    INL                    ;Table. Advance the pointer to second char in a name.
1136 10-137 317                    LBM                    ;Fetch the second character into register B.
1137 10-140 060                    INL                    ;Advance the pointer to first byte of a value in the table.
1138 10-141 106 356 022            CAL SWITCH             ;Exchange table pointer for pointer to SYMBOL BUFF
1139 10-144 277                    CPM                    ;Compare first character in buffer against first character
1140 10-145 110 156 010            JFZ STOSY3             ;In table entry. If no match, try next entry in the table.
1141 10-150 060                    INL                    ;If match, advance pointer to second character in buffer.
1142 10-151 301                    LAB                    ;Move second character obtained from table into ACC.
1143 10-152 277                    CPM                    ;Compare second characters in table and buffer.
1144 10-153 150 227 010            JTZ STOSY5             ;If same, have found the variable name in the table.
1145 10-156 106 256 006 STOSY3:    CAL AD4DE              ;Add four to pointer in registers D&E to skip over value
1146 10-161 066 370                LLI 370                ;Portion of entry in table. Load L with address of TEMP
1147 10-163 056 026                LHI \HB\OLDPG26        ;** CNTR. Load H with page of TEMP CNTR.
1148 10-165 317                    LBM                    ;Fetch the counter
1149 10-166 010                    INB                    ;Increment the counter
1150 10-167 371                    LMB                    ;Restore it to storage
1151 10-170 066 077                LLI 077                ;Set L to address of VARIABLES CNTR (indicates
1152 10-172 056 027                LHI \HB\OLDPG27        ;** Number of variables currently in table.) Set H too
1153 10-174 301                    LAB                    ;Move the TEMP CNTR value into the ACC. (Number of
1154 10-175 277                    CPM                    ;Entries checked.) Compare with number of entries in
1155 10-176 110 126 010            JFZ STOSY2             ;The table. If have not checked all entries, try next one.
1156 10-201 066 077                LLI 077                ;If have checked all entries, load L with address of the
1157 10-203 056 027                LHI \HB\OLDPG27        ;** VARIABLES CNTR. Set H too. Fetch the counter
1158 10-205 317                    LBM                    ;Value and incrernent it to account for
1159 10-206 010                    INB                    ;New variable nwne that will now be
1160 10-207 371                    LMB                    ;Added to the table. Save the new value.
1161 10-210 301                    LAB                    ;Place the new counter value into the accumulator
1162 10-211 074 025                CPI 025                ;And check to see that adding new variable name to the
1163 10-213 120 222 002            JFS BIGERR             ;Table will not cause table overflow. Big Error if it does!
1164 10-216 066 121                LLI 121                ;If room available in table, set L to address of first
1165 10-220 056 026                LHI \HB\OLDPG26        ;** Caracter in the SYMBOL BUFFER. Set H too.
1166 10-222 016 002                LBI 002                ;Set a counter for number of characters to transfer.
1167 10-224 106 013 021            CAL MOVEIT             ;Move the variable name from buffer to table.
1168 10-227 106 356 022 STOSY5:    CAL SWITCH             ;Exchange buffer pointer for table pointer.
1169 10-232 106 255 022            CAL FSTORE             ;Transfer new mathematical value into the table.
1170 10-235 104 255 002            JMP CLESYM             ;Clear the SYMBOL BUFFER and exit to calling routine.
1171                    
1172                                                      ;The subroutines below are used by some of the routines
1173                                                      ;in this chapter as well as other parts of the program.
1174                    
1175 10-240 066 120     SAVESY:    LLI 120                ;Load L with the address of the start of the SYMBOL
1176 10-242 056 026                LHI \HB\OLDPG26        ;** BUFFER. Load H with the page of the buffer.
1177 10-244 335                    LDH                    ;Load register D with the page of the AUX SYMBOL
1178 10-245 046 144                LEI 144                ;BUFFER and set register E to start of that buffer.
1179 10-247 104 261 010            JMP MOVECP             ;Transfer SYMBOL BF contents to AUX SYMBOL BF
1180                    
1181 10-252 066 144     RESTSY:    LLI 144                ;Load L with address of start of AUX SYMBOL BUFF
1182 10-254 056 026                LHI \HB\OLDPG26        ;** Load H with page of AUX SYMBOL BUFFER
1183 10-256 335                    LDH                    ;Set D to page of SYMBOL BUFFER (same as H)
1184 10-257 046 120                LEI 120                ;Load E with start of SYMBOL BUFFER
1185 10-261 317         MOVECP:    LBM                    ;Load (cc) for source string (first byte in source buffer)
1186 10-262 010                    INB                    ;Add one to (cc) to include (cc) byte itself
1187 10-263 104 013 021            JMP MOVEIT             ;Move the source string to destination buffer
1188                    
1189                    ;;; The label Exec SHOULD BE AT 10 266 (This is the start of the code)
1190 10-266 066 352     EXEC:      LLI 352                ;Load L with address of READY message
1191 10-270 056 001                LHI \HB\OLDPG1         ;** Load H with page of READY message
1192 10-272 106 121 003            CAL TEXTC              ;Call subroutine to display the READY message
1193                    
1194 10-275 066 000     EXEC1:     LLI 000                ;Load L with starting address of INPUT LINE BUFFER
1195 10-277 056 026                LHI \HB\OLDPG26        ;** Load H with page of INPUT LINE BUFFER
1196 10-301 106 014 003            CAL STRIN              ;Call subroutine to input a line into the buffer
1197 10-304 307                    LAM                    ;The STRIN subroutine will exit with pointer set to the
1198 10-305 240                    NDA                    ;CHARACTER COUNT for the line inputted. Fetch the
1199 10-306 150 275 010            JTZ EXEC1              ;Value of the counter, if it is zero then line was blank.
1200 10-311 066 335                LLI 335                ;Load L with address of LIST in look up table
1201 10-313 056 001                LHI \HB\OLDPG1         ;Load H with address of LIST in look up table
1202 10-315 036 026                LDI \HB\OLDPG26        ;Load D with page of line input buffer
1203 10-317 046 000                LEI 000                ;Load E with start of line input buffer
1204 10-321 106 332 002            CAL STRCP              ;Call string compare subroutine to see if first word in
1205 10-324 110 354 010            JFZ NOLIST             ;Input buffer is LIST. Jump 3 ahead if not LIST.
1206 10-327 066 000                LLI 000                ;If LIST, set up pointers to start of USER PROGRAM
1207 10-331 056 033                LHI BGNPGRAM           ;BUFFER. (Note user could alter this starting addr)   *****
1208                    
1209                                                      ;Next portion of program will LIST the contents of the
1210                                                      ;USER PROGRAM BUFFER until an end of buffer
1211                                                      ;(zero byte) indicator is detected.
1212                    
1213 10-333 307         LIST:      LAM                    ;Fetch the first byte of a line in the USER PROGRAM
1214 10-334 240                    NDA                    ;BUFFER and see if it is zero. If so, have finished LIST
1215 10-335 150 266 010            JTZ EXEC               ;So go back to start of Executive and display READY.
1216 10-340 106 121 003            CAL TEXTC              ;Else call subroutine to display a line of information
1217 10-343 106 377 002            CAL ADV                ;Now call subroutine to advance buffer pointer to
1218 10-346 106 141 003            CAL CRLF               ;Character count in next line. Also display a CR & LF.
1219 10-351 104 333 010            JMP LIST               ;Continue LISTing process
1220                    
1221                                                      ;If line inputted by operator did not contain a LIST comman
1222                                                      ;continue program to see if RUN or SCRatch command.
1223                    
1224 10-354 066 342     NOLIST:    LLI 342                ;Load L with address of RUN in look up table
1225 10-356 056 001                LHI \HB\OLDPG1         ;** Load H with address of RUN in look up table
1226 10-360 046 000                LEI 000                ;Load E with start of line input buffer
1227 10-362 036 026                LDI \HB\OLDPG26        ;** Load D with page of line input buffer
1228 10-364 046 000                LEI 000                ;(Reserve 2 locs in case of patching by duplicating above)
1229 10-366 106 332 002            CAL STRCP              ;Call string compare subroutine to see if first word in
1230 10-371 150 070 013            JTZ RUN                ;Input buffer is RUN. Go to RUN routine if match.
1231 10-374 036 026                LDI \HB\OLDPG26        ;** If not RUN command, reset address pointers back
1232 10-376 046 000                LEI 000                ;To the start of the line input buffer
1233 11-000 066 346                LLI 346                ;Load L with address of SCR in look up table
1234 11-002 056 001                LHI \HB\OLDPG1         ;** Load H with page of SCR in look up table
1235 11-004 106 332 002            CAL STRCP              ;Call string compare subroutine to see if first word in
1236 11-007 110 071 011            JFZ NOSCR              ;Input buffer is SCR. If not then jump ahead.
1237 11-012 056 026                LHI \HB\OLDPG26        ;** If found SCR command then load memory pointer
1238 11-014 066 364                LLI 364                ;With address of a pointer storage location. Set that
1239 11-016 076 033                LMI BGNPGRAM           ;tt Storage location to page of start of USER PRO-  *******
1240 11-020 060                    INL                    ;GRAM BUFFER. (Buffer start loc may be altered).
1241 11-021 076 000                LMI 000                ;Then adv pntr and do same for low addr portion of pntr
1242 11-023 066 077                LLI 077                ;Now set pointer to address of VARIABLES counter
1243 11-025 056 027                LHI \HB\OLDPG27        ;** Storage location. Initialize this counter by placing
1244 11-027 076 001                LMI 001                ;The count of one into it. Now change the memory pntr
1245                    ;MGA 3/31/12 put it back to 001; solves nested FOR/NEXT, but limits vars to 19
1246                    ;   as the letter from James Tucker (1/77) mentioned
1247                    ;   apparently, James didn't test FOR/NEXT; original Loboyko didn't have this
1248                    ;;;           LMI 001                ;The count of one into it. Now change the memory pntr
1249                    ;;; Apparently, in Page 3 of Issue 4 of Scelbal update (1/77) they say the above should change.
1250                    ;;; This makes the SCR command clear the whole variable space, otherwise one space is lost.  
1251 11-031 066 075                LLI 075                ;To storage location for number of dimensioned arrays
1252 11-033 076 000                LMI 000                ;@@ And initialize to zero. (@@ = Substitute NOPs if
1253 11-035 066 120                LLI 120                ;@@ DIMension capability not used in package.) Also
1254 11-037 076 000                LMI 000                ;@@ Initialize l'st byte of array name table to zero.
1255 11-041 066 210                LLI 210                ;Set pointer to storage location for the first byte of the
1256 11-043 076 000                LMI 000                ;VARIABLES symbol table. Initialize it to zero too.
1257 11-045 060                    INL                    ;Advance the pointer and zero the second location
1258 11-046 076 000                LMI 000                ;In the Variables table also.
1259 11-050 056 033                LHI BGNPGRAM           ;tt Load H with page of start of USER PROGRAM    **********
1260 11-052 066 000                LLI 000                ;BUFFER. (Buffer start location could be altered.)
1261 11-054 076 000                LMI 000                ;Clear first location to indicate end of user program.
1262 11-056 056 057                LHI \HB\OLDPG57        ;@@ Load H with page of ARRAYS storage
1263 11-060 076 000     SCRLOP:    LMI 000                ;@@ And form a loop to clear out all the locations
1264 11-062 060                    INL                    ;@@ On the ARRAYS storage page. (@@ These become
1265 11-063 110 060 011            JFZ SCRLOP             ;@@ NOPs if DIMension capability deleted fm package.)
1266 11-066 104 266 010            JMP EXEC               ;SCRatch operations completed, go back to EXEC.
1267                    
1268                                                      ;If line inputted did not contain RUN or SCRatch com-
1269                                                      ;mand, program continues by testing for SAVE or LOAD
1270                                                      ;commands. If it does not find either of these com-
1271                                                      ;mands, then operator did not input an executive com-
1272                                                      ;mand. Program then sets up to see if the first entry in
1273                                                      ;the line inputted is a LINE NUMBER.
1274                    
1275 11-071 046 272     NOSCR:     LEI 272                ;Load E with address of SAVE in look up table
1276 11-073 036 001                LDI \HB\OLDPG1         ;Load D with page of look up table
1277 11-075 056 026                LHI \HB\OLDPG26        ;Load H with page of input line buffer
1278 11-077 066 000                LLI 000                ;Set L to start of input line buffer
1279 11-101 106 332 002            CAL STRCP              ;Call string compare subroutine to see if first word in
1280 11-104 150 100 000            JTZ SAVE               ;tt Input buffer is SAVE. If so, go to user's SAVE rtn
1281 11-107 066 277                LLI 277                ;If not SAVE then load L with address of LOAD in look
1282 11-111 056 001                LHI \HB\OLDPG1         ;Up table and load H with page of look up table
1283 11-113 036 026                LDI \HB\OLDPG26        ;Load D with page of input line buffer
1284 11-115 046 000                LEI 000                ;And L to start of input line buffer
1285 11-117 106 332 002            CAL STRCP              ;Call string compare subroutine to see if first word in
1286 11-122 150 100 000            JTZ LOAD               ;tt Input buffer is LOAD. If so, go to user's LOAD rtn
1287 11-125 066 360                LLI 360                ;If not LOAD then set pointer to address of storage loc
1288 11-127 056 026                LHI \HB\OLDPG26        ;** For USER PROGRAM BUFFER pointer. Initialize this
1289 11-131 076 033                LMI BGNPGRAM           ;tt Pointer to the starting address of the program buffer.
1290 11-133 060                    INL                    ;Advance memory pntr. Since pointer storage requires
1291 11-134 076 000                LMI 000                ;Two locations, initialize the low addr portion also.
1292 11-136 106 000 002            CAL SYNTAX             ;Call the SYNTAX subroutine to obtain a TOKEN indi-
1293 11-141 066 203                LLI 203                ;Cator which will be stored in this location. Upon return
1294 11-143 056 026                LHI \HB\OLDPG26        ;** From SYNTAX subroutine set memory pointer to
1295 11-145 307                    LAM                    ;The TOKEN indicator storage location and fetch the
1296 11-146 240                    NDA                    ;Value of the TOKEN. If the value of the syntax TOKEN
1297 11-147 120 161 011            JFS SYNTOK             ;Is positive then have a valid entry.
1298 11-152 006 323     SYNERR:    LAI 323                ;However, if SYNTAX returns a negative value TOKEN
1299 11-154 026 331                LCI 331                ;Then have an error condition. Set up the letters SY in
1300 11-156 104 226 002            JMP ERROR              ;ASCII code and go to display error message to operator.
1301 11-161 066 340     SYNTOK:    LLI 340                ;Set pointer to start of LINE NUMBER storage area
1302 11-163 307                    LAM                    ;First byte there will contain the length of the line
1303 11-164 240                    NDA                    ;Number character string. Fetch that value (cc).
1304 11-165 150 211 013            JTZ DIRECT             ;DIRECT If line number blank, have a DIRECT statement!
1305 11-170 066 360                LLI 360                ;If have a line number must get line in input buffer into
1306 11-172 076 033                LMI BGNPGRAM           ;tt User program buffer. Initialize pointer to user buffer.
1307 11-174 060                    INL                    ;This is a two byte pointer so after initializing page addr
1308 11-175 076 000                LMI 000                ;Advance pointer and initialize location on page address
1309                    
1310                                                      ;If the line in the LINE INPUT BUFFER has a line num-
1311                                                      ;ber then the line is to be placed in the USER PRO-
1312                                                      ;GRAM BUFFER. It is now necessary to determine
1313                                                      ;where the new line is to be placed in the USER PRO-
1314                                                      ;GRAM BUFFER. This is dictated by the value of the
1315                                                      ;new line number in relation to the line numbers cur-
1316                                                      ;rently in the program buffer. The next portion of the
1317                                                      ;program goes through the contents of the USER PRO-
1318                                                      ;GRAM BUFFER comparing the values of the line num-
1319                                                      ;bers already stored against the value of the line number
1320                                                      ;currently being held in the LINE INPUT BUFFER.
1321                                                      ;Appropriate action is then taken to Insert or Append,
1322                                                      ;Change, or Delete a line in the program buffer.
1323                    
1324 11-177 066 201     GETAUX:    LLI 201                ;Set memory pointer to line character pointer storage
1325 11-201 056 026                LHI \HB\OLDPG26        ;** Location and then initialize that storage location
1326 11-203 076 001                LMI 001                ;To point to the 1'st character in a line
1327 11-205 066 350                LLI 350                ;Set memory pointer to addr of start of auxiliary line
1328 11-207 076 000                LMI 000                ;Number storage area and initialize first byte to zero
1329 11-211 066 201     GETAU0:    LLI 201                ;Set memory pointer to line character pointer storage loc
1330 11-213 106 123 012            CAL GETCHP             ;Fetch a char in line pointed to by line pointer
1331 11-216 150 242 011            JTZ GETAU1             ;If character is a space, skip it by going to advance pntrs
1332 11-221 074 260                CPI 260                ;If not a space check to see if character represents a
1333 11-223 160 267 011            JTS GETAU2             ;Valid decimal digit in the range 0 to 9 by testing the
1334 11-226 074 272                CPI 272                ;ASCII code value obtained. If not a deciznal digit then
1335 11-230 120 267 011            JFS GETAU2             ;Assume have obtained the line number. Go process.
1336 11-233 066 350                LLI 350                ;If valid decimal digit want to append the digit to the
1337 11-235 056 026                LHI \HB\OLDPG26        ;** Current string being built up in the auxiliary line
1338 11-237 106 314 002            CAL CONCT1             ;Number storage area so call sub to concat a character.
1339 11-242 066 201     GETAU1:    LLI 201                ;Reset memory pointer to line character pntr storage loc
1340 11-244 056 026                LHI \HB\OLDPG26        ;On the appropriate page.
1341 11-246 317                    LBM
1342 11-247 010                    INB                    ;Fetch the pointer, increment it, and restore new value
1343 11-250 371                    LMB
1344 11-251 066 360                LLI 360                ;Set memory pointer to pgm buff line pntr storage loc
1345 11-253 056 026                LHI \HB\OLDPG26
1346 11-255 327                    LCM                    ;Bring the high order byte of this double byte pointer
1347 11-256 060                    INL                    ;Into CPU register C. Then advance the memory pntr
1348 11-257 367                    LLM                    ;And bring the low order byte into register L. Now trans-
1349 11-260 352                    LHC                    ;Fer the higher order portion into memory pointer H.
1350 11-261 307                    LAM                    ;Obtain the char cntr (cc) which indicates the length of
1351 11-262 011                    DCB                    ;The line being pointed to by the user program line pntr
1352 11-263 271                    CPB                    ;Compare this with the value of the chars processed so
1353 11-264 110 211 011            JFZ GETAU0             ;Far in current line. If not equal, continue getting line n
1354 11-267 066 360     GETAU2:    LLI 360                ;Reset mem pntr to pgm buffer line pntr storage
1355 11-271 056 026                LHI \HB\OLDPG26        ;** On this page and place the high order byte
1356 11-273 337                    LDM                    ;Of this pointer into CPU register D
1357 11-274 060                    INL                    ;Advance the memory pointer, fetch the second
1358 11-275 367                    LLM                    ;Byte of the pgm buffer line pointer into register L
1359 11-276 353                    LHD                    ;Now make the memory pointer equal to this value
1360 11-277 307                    LAM                    ;Fetch the first byte of a line in the program buffer
1361 11-300 240                    NDA                    ;Test to see if end of contents of pgm buff (zero byte)
1362 11-301 110 336 011            JFZ NOTEND             ;If not zero continue processing. If zero have reached
1363 11-304 104 005 012            JMP NOSAME             ;End of buffer contents so go APPEND line to buffer.
1364                    ;;; there are some open addresses here.  Above JUMP starts at 11-304;
1365                    ;;; The below label patch3 should start at 11 307
1366 11-307 066 201     PATCH3:	   LLI 201		; ptr to A/V storage
1367 11-311 056 027     	   LHI \HB\OLDPG27      ; MGA 3/31/12 make relocatable; prev: LHI 027
1368 11-313 076 000     	   LMI 000		; clear A/V flag
1369 11-315 104 266 010 	   JMP EXEC
1370                    
1371                    	ORG 011#336		
1372 11-336 066 350     NOTEND:    LLI 350                ;Load L with addr of auxiliary line number storage loc
1373 11-340 056 026                LHI \HB\OLDPG26        ;Load H with addr of aux line number storage loc
1374 11-342 036 026                LDI \HB\OLDPG26        ;Load D with addr of line number buffer location
1375 11-344 046 340                LEI 340                ;Load E with address of line number buffer location
1376 11-346 106 332 002            CAL STRCP              ;Compare line nr in input buffer with line number in
1377 11-351 160 073 012            JTS CONTIN             ;User program buffer. If lesser in value keep looking.
1378 11-354 110 005 012            JFZ NOSAME             ;If greater in value then go to Insert line in pgm buffer
1379 11-357 066 360                LLI 360                ;If same values then must remove the line with the same
1380 11-361 056 026                LHI \HB\OLDPG26        ;** Line number from the user program buffer. Set up
1381 11-363 327                    LCM                    ;The CPU memory pointer to point to the current
1382 11-364 060                    INL                    ;Position in the user program buffer by retrieving that
1383 11-365 367                    LLM                    ;Pointer from its storage location. Then obtain the first
1384 11-366 352                    LHC                    ;Byte of data pointed to which will be the character
1385 11-367 317                    LBM                    ;Count for that line (cc). Add one to the cc value to take
1386 11-370 010                    INB                    ;Account of the (cc) byte itself and then remove that
1387 11-371 106 144 012            CAL REMOVE             ;Many bytes to effectively delete the line fm the user
1388 11-374 066 203                LLI 203                ;Program buffer. Now see if line in input buffer consists
1389 11-376 056 026                LHI \HB\OLDPG26        ;** Only of a line number by checking SYNTAX
1390 12-000 307                    LAM                    ;TOKEN value. Fetch the TOKEN value from its
1391 12-001 240                    NDA                    ;Storage location. If it is zero then input buffer only
1392 12-002 150 266 010            JTZ EXEC               ;Contains a line number. Action is a pure Delete.
1393 12-005 066 360     NOSAME:    LLI 360                ;Reset memory pointer to program buffer
1394 12-007 056 026                LHI \HB\OLDPG26        ;Line pointer storage location
1395 12-011 337                    LDM                    ;Load high order byte into CPU register D
1396 12-012 060                    INL                    ;Advance memory pointer
1397 12-013 347                    LEM                    ;Load low order byte into CPU register E
1398 12-014 066 000                LLI 000                ;Load L with address of start of line input buffer
1399 12-016 056 026                LHI \HB\OLDPG26        ;** Do same for CPU register H
1400 12-020 317                    LBM                    ;Get length of line input buffer
1401 12-021 010                    INB                    ;Advance length by one to include (cc) byte
1402 12-022 106 205 012            CAL INSERT             ;Go make room to insert line into user program buffer
1403 12-025 066 360                LLI 360                ;Reset memory pointer to program buffer
1404 12-027 056 026                LHI \HB\OLDPG26        ;** Line pointer storage location
1405 12-031 337                    LDM                    ;Load higher byte into CPU register D
1406 12-032 060                    INL                    ;Advance memory pointer
1407 12-033 347                    LEM                    ;Load low order byte into CPU register E
1408 12-034 066 000                LLI 000                ;Load L with address of start of line input buffer
1409 12-036 056 026                LHI \HB\OLDPG26        ;** Do same for CPU register H
1410 12-040 106 046 012            CAL MOVEC              ;Call subroutine to Insert line in input buffer into the
1411 12-043 104 275 010            JMP EXEC1              ;User program buffer then go back to start of EXEC.
1412 12-046 317         MOVEC:     LBM                    ;Fetch length of string in line input buffer
1413 12-047 010                    INB                    ;Increment that value to provide for (cc)
1414 12-050 307         MOVEPG:    LAM                    ;Fetch character from line input buffer
1415 12-051 106 377 002            CAL ADV                ;Advance pointer for line input buffer
1416 12-054 106 356 022            CAL SWITCH             ;Switch memory pointer to point to user pgm buffer
1417 12-057 370                    LMA                    ;Deposit character fm input buff into user pgm buff
1418 12-060 106 377 002            CAL ADV                ;Advance pointer for user program buffer
1419 12-063 106 356 022            CAL SWITCH             ;Switch memory pntr back to point to input buffer
1420 12-066 011                    DCB                    ;Decrement character counter stored in CPU register B
1421 12-067 110 050 012            JFZ MOVEPG             ;If counter does not go to zero continue transfer ops
1422 12-072 007                    RET                    ;When counter equals zero return to calling routine
1423 12-073 066 360     CONTIN:    LLI 360                ;Reset memory pointer to program buffer
1424 12-075 056 026                LHI \HB\OLDPG26        ;** Line pointer storage location
1425 12-077 337                    LDM                    ;Load high order byte into CPU register D
1426 12-100 060                    INL                    ;Advance memory pointer
1427 12-101 347                    LEM                    ;Load low order byte into CPU register E
1428 12-102 353                    LHD                    ;Now set CPU register H to high part of address
1429 12-103 364                    LLE                    ;And set CPU register L to low part of address
1430 12-104 317                    LBM                    ;Fetch the character counter (cc) byte fm line in
1431 12-105 010                    INB                    ;Program buffer and add one to compensate for (cc)
1432 12-106 106 305 012            CAL ADBDE              ;Add length of line value to old value to get new pointer
1433 12-111 066 360                LLI 360                ;Reset memory pointer to program buffer
1434 12-113 056 026                LHI \HB\OLDPG26        ;** Line pointer storage location
1435 12-115 373                    LMD                    ;Restore new high portion
1436 12-116 060                    INL                    ;Advance memory pointer
1437 12-117 374                    LME                    ;And restore new low portion
1438 12-120 104 177 011            JMP GETAUX             ;Continue til find point at which to enter new line
1439 12-123 056 026     GETCHP:    LHI \HB\OLDPG26        ;** Load H with pointer page (low portion set upon
1440 12-125 317                    LBM                    ;Entry). Now fetch pointer into CPU register B.
1441 12-126 066 360                LLI 360                ;Reset pntr to pgm buffer line pointer storage location
1442 12-130 337                    LDM                    ;Load high order byte into CPU register D
1443 12-131 060                    INL                    ;Advance memory pointer
1444 12-132 347                    LEM                    ;Load low order byte into CPU register E
1445 12-133 106 305 012            CAL ADBDE              ;Add pointer to pgm buffer pointer to obtain address of
1446 12-136 353                    LHD                    ;Desired character. Place high part of new addr in H.
1447 12-137 364                    LLE                    ;And low part of new address in E.
1448 12-140 307                    LAM                    ;Fetch character from position in line in user pgm buffer
1449 12-141 074 240                CPI 240                ;See if it is the ASCII code for space
1450 12-143 007                    RET                    ;Return to caller with flags set to indicate result
1451 12-144 106 174 003 REMOVE:    CAL INDEXB             ;Add (cc) plus one to addr of start of line
1452 12-147 327                    LCM                    ;Obtain byte from indexed location and
1453 12-150 106 113 003            CAL SUBHL              ;Subtract character count to obtain old location
1454 12-153 372                    LMC                    ;Put new byte in old location
1455 12-154 302                    LAC                    ;As well as in the Accumulator
1456 12-155 240                    NDA                    ;Test to see if zero byte to indicate end of user pgm buff
1457 12-156 150 167 012            JTZ REMOV1             ;If it is end of user pgm buffer, go complete process
1458 12-161 106 377 002            CAL ADV                ;Otherwise add one to the present pointer value
1459 12-164 104 144 012            JMP REMOVE             ;And continue removing chamcters from the user pgm bf
1460 12-167 066 364     REMOV1:    LLI 364                ;Load L with end of user pgm buffer pointer storage loc
1461 12-171 056 026                LHI \HB\OLDPG26        ;** Load H with page of that pointer storage location
1462 12-173 337                    LDM                    ;Get page portion of end of pgm buffer address
1463 12-174 060                    INL                    ;Advance memory pointer
1464 12-175 307                    LAM                    ;And get low portion of end of pgm buffer address into
1465 12-176 221                    SUB                    ;Accumulator then subtract displacement value in B
1466 12-177 370                    LMA                    ;Restore new low portion of end of pgm buffer address
1467 12-200 003                    RFC                    ;If subtract did not cause carry can return now
1468 12-201 061                    DCL                    ;Otherwise decrement memory pointer back to page
1469 12-202 031                    DCD                    ;Storage location, decrement page value to give new page
1470 12-203 373                    LMD                    ;And store new page value back in buffer pntr storage loc
1471 12-204 007                    RET                    ;Then return to calling routine
1472 12-205 066 364     INSERT:    LLI 364                ;Load L with end of user pgm buffer pointer storage loc
1473 12-207 056 026                LHI \HB\OLDPG26        ;** Load H with page of that pointer storage location
1474 12-211 307                    LAM                    ; Get page portion of end of program buffer address
1475 12-212 060                    INL                    ;Advance memory pointer
1476 12-213 367                    LLM                    ;Load low portion of end of program buffer address
1477 12-214 350                    LHA                    ;Into L and finish setting up memory pointer
1478 12-215 106 174 003            CAL INDEXB             ;Add (cc) of line in input buffer to form new end of
1479 12-220 305                    LAH                    ;Program buffer address. Fetch new end of buffer page
1480 12-221 074 055                CPI ENDPGRAM           ;tt Address and see if this value would exceed user's
1481 12-223 120 222 002            JFS BIGERR             ;System capabilit'y. Go display error message if so!
1482 12-226 106 113 003            CAL SUBHL              ;Else restore original value of end of buffer address
1483 12-231 327         INSER1:    LCM                    ;Bring byte pointed to by H & L into CPU register C
1484 12-232 106 174 003            CAL INDEXB             ;Add displacement value to current memory pointer
1485 12-235 372                    LMC                    ;Store the byte in the new location
1486 12-236 106 113 003            CAL SUBHL              ;Now subtract displacement value from H & L
1487 12-241 106 277 012            CAL CPHLDE             ;Compare this with the address stored in D & E
1488 12-244 150 255 012            JTZ INSER3             ;If same then go finish up Insert operation
1489 12-247 106 164 003            CAL DEC                ;Else set pointer to the byte before the byte just
1490 12-252 104 231 012            JMP INSER1             ;Processed and continue the Insert operation
1491                    INSER3:
1492 12-255 066 000     INCLIN:    LLI 000                ;Load L with start of line input buffer
1493 12-257 056 026                LHI \HB\OLDPG26        ;** Load H with page of start of line input buffer
1494 12-261 317                    LBM                    ;Fetch length of the line in line input buffer
1495 12-262 010                    INB                    ;Increment value by one to include (cc) byte
1496 12-263 066 364                LLI 364                ;Set memory pointer to end of user pgrn buffer pointer
1497 12-265 337                    LDM                    ;Storage location on same page and fetch page address
1498 12-266 060                    INL                    ;Of this pointer into D. Then advance memory pointer
1499 12-267 347                    LEM                    ;And get low part of this pointer into CPU register E.
1500 12-270 106 305 012            CAL ADBDE              ;Now add displacement (cc) of line in input buffer to
1501 12-273 374                    LME                    ;The end of program buffer pointer. Replace the updated
1502 12-274 061                    DCL                    ;Low portion of the new pointer value back in stomge
1503 12-275 373                    LMD                    ;And restore the new page value back into storage
1504 12-276 007                    RET                    ;Then return to calling routine
1505 12-277 305         CPHLDE:    LAH                    ;Subroutine to compare if the contents of CPU registers
1506 12-300 273                    CPD                    ;H & L are equal to registers D & E. First compare
1507 12-301 013                    RFZ                    ;Register H to D. Return with flags set if not equal. If
1508 12-302 306                    LAL                    ;Equal continue by comparing register L to E.
1509 12-303 274                    CPE                    ;IF L equals E then H & L equal to D & E so return to
1510 12-304 007                    RET                    ;Calling routines with flags set to equality status
1511 12-305 304         ADBDE:     LAE                    ;Subroutine to add the contents of CPU register B (single
1512 12-306 201                    ADB                    ;Byte value) to the double byte value in registers D & E.
1513 12-307 340                    LEA                    ;First add B to E to form new least significant byte
1514 12-310 003                    RFC                    ;Restore new value to E and exit if no carry resulted
1515 12-311 030                    IND                    ;If had a carry then must increment most significant byte
1516 12-312 007                    RET                    ;In register D before returning to calling routine
1517 12-313 006 336     CTRLC:     LAI 336                ;Set up ASCII code for t (up arrow) in Accumulator.
1518 12-315 026 303                LCI 303                ;Set up ASCII code for letter 'C' in CPU register C.
1519 12-317 104 226 002            JMP ERROR              ;Go display the 'Control C' condition message.
1520 12-322 066 340     FINERR:    LLI 340                ;Load L with starting address of line number storage area
1521 12-324 056 026                LHI \HB\OLDPG26        ;** Load H with page of line number storage area
1522 12-326 307                    LAM                    ;Get (cc) for line number string. If length is zero meaning
1523 12-327 240                    NDA                    ;There is no line number stored in the buffer then jump
1524 12-330 150 351 012            JTZ FINER1             ;Ahead to avoid displaying "AT LINE" message
1525 12-333 066 366                LLI 366                ;Else load L with address of start of "AT LINE" message
1526 12-335 056 001                LHI \HB\OLDPG1         ;** Stored on this page
1527 12-337 106 121 003            CAL TEXTC              ;Call subroutine to display the "AT LINE" message
1528 12-342 066 340                LLI 340                ;Now reset L to starting address of line number storage
1529 12-344 056 026                LHI \HB\OLDPG26        ;** Area and do same for CPU register H
1530 12-346 106 121 003            CAL TEXTC              ;Call subroutine to display the line number
1531 12-351 106 141 003 FINER1:    CAL CRLF               ;Call subroutine to provide a carriage-return and line-feed
1532 12-354 104 307 011 	   JMP PATCH3 
1533                    ;;; The following is the old code, before patch 3
1534                    ;;;           JMP EXEC               ;To the display device then return to EXECUTIVE.
1535 12-357 006 304     DVERR:     LAI 304                ;Set up ASCII code for letter 'D' in Accumulator
1536 12-361 026 332                LCI 332                ;Set up ASCII code for letter 'Z' in CPU register C
1537 12-363 104 226 002            JMP ERROR              ;Go display the 'DZ' (divide by zero) error message
1538 12-366 006 306     FIXERR:    LAI 306                ;Set up ASCII code for letter 'F' in Accumulator
1539 12-370 026 330                LCI 330                ;Set up ASCII code for letter 'X' in CPU register C
1540 12-372 104 226 002            JMP ERROR              ;Go display the 'FX' (FiX) error message
1541 12-375 006 311     NUMERR:    LAI 311                ;Set up ASCII code for letter 'I' in Accumulator
1542 12-377 026 316                LCI 316                ;Set up ASCII code for letter 'N' in CPU register C
1543 13-001 066 220                LLI 220                ;Load L with address of pointer used by DINPUT
1544 13-003 056 001                LHI \HB\OLDPG1         ;** Routine. Do same for register H.
1545 13-005 076 000                LMI 000                ;Clear the location
1546 13-007 104 226 002            JMP ERROR              ;Go display the'IN'(Illegal Number) error message
1547                    
1548                                                      ;The following subroutine, used by various sections of
1549                                                      ;SCELBAL, will search the LINE INPUT BUGGER for
1550                                                      ;a character string which is contained in a buffer starting
1551                                                      ;at the address pointed to by CPU registers H & L when
1552                                                      ;the subroutine is entered.
1553                    
1554 13-012 036 026     INSTR:     LDI \HB\OLDPG26        ;**Set D to starting page of LINE INPUT BUFFER
1555 13-014 046 000                LEI 000                ;Load E with starting location of LINE INPUT BUFFER
1556 13-016 106 064 013 INSTR1:    CAL ADVDE              ;Advancer D & E pointer to the next location (input
1557 13-021 106 317 022            CAL SAVEHL             ;Buffer). Now save contents of d, E, H & L vefore the
1558 13-024 317                    LBM                    ;Compare operations. Get length of TEST buffer in B.
1559 13-025 106 377 002            CAL ADV                ;Advance H & L buffer to first char in TEST buffer.
1560 13-030 106 370 002            CAL STRCPC             ;Compare contents of TEST buffer against input buffer
1561 13-033 150 337 022            JTZ RESTHL             ;For length B. If match, restore pntrs and exit to caller.
1562 13-036 106 337 022            CAL RESTHL             ;If no match, restore pointers for loop test.
1563 13-041 066 000                LLI 000                ;Load L with start of input buffer (to get the char cntr).
1564 13-043 056 026                LHI \HB\OLDPG26        ;**Load H with page of input buffer.
1565 13-045 307                    LAM                    ;Get length of buffer (cc) into the accumulator.
1566 13-046 274                    CPE                    ;Compare with current input buffer pointer value.
1567 13-047 150 061 013            JTZ INSTR2             ;If at end of buffer, jump ahead.
1568 13-052 106 337 022            CAL RESTHL             ;Else restore test string address (H&L) and input buffer
1569 13-055 104 016 013            JMP INSTR1             ;Address (D&E). Look gor occurrence of test string in ln.
1570 13-060 001                    HLT                    ;Safety halt. If program reaches here have system failure.
1571 13-061 046 000     INSTR2:    LEI 000                ;If reach end of input buffer without finding a match
1572 13-063 007                    RET                    ;Load E with 000 as an indicator and return to caller.
1573 13-064 040         ADVDE:     INE                    ;Subroutine to advance the pointer in the register
1574 13-065 013                    RFZ                    ;Pair D & E. Advance contents of E. Return if not zero.
1575 13-066 030                    IND                    ;If register E goes to 0 when advanced, then advance
1576 13-067 007                    RET                    ;Register D too. Exit to calling routine.
1577                    
1578                    ;;; The label RUN should start at 13-170
1579 13-070 066 073     RUN:       LLI 073                ;Load L with addr of GOSUB/RETURN stack pointer
1580 13-072 056 027                LHI \HB\OLDPG27        ;** Load H with page of same pointer
1581 13-074 076 000                LMI 000                ;Initialize the GOSUB/RETURN stack pointer to zero
1582 13-076 066 205                LLI 205                ;Load L with addr of FOR/NEXT stack pointer
1583 13-100 076 000                LMI 000                ;Initialize the FOR/NEXT stack pointer to zero
1584 13-102 066 360                LLI 360                ;Load L with addr of user pgm buffer line pointer
1585 13-104 056 026                LHI \HB\OLDPG26        ;** Load H with page of user pgm buffer line pointer
1586 13-106 076 033                LMI BGNPGRAM           ;tt Initialize pointer (may be altered by user)   *******
1587 13-110 060                    INL                    ;Advance memory pointer to low portion of user pgm
1588 13-111 076 000                LMI 000                ;Buffer pointer and initialize to start of buffer
1589 13-113 104 156 013            JMP SAMLIN             ;Start executing user program with first line in buffer
1590 13-116 066 360     NXTLIN:    LLI 360                ;Load L with addr of user program buffer line pointer
1591 13-120 056 026                LHI \HB\OLDPG26        ;** Load H with page of user pgm buffer line pointer
1592 13-122 337                    LDM                    ;Place page addr of pgm buffer line pointer in D
1593 13-123 060                    INL                    ;Advance the memory pointer
1594 13-124 347                    LEM                    ;Place low addr of pgm buffer line pointer in E
1595 13-125 353                    LHD                    ;Also put page addr of pgm buffer line pointer in H
1596 13-126 364                    LLE                    ;And low addr of pgm buffer line pointer in L
1597 13-127 317                    LBM                    ;Now fetch the (cc) of current line into register B
1598 13-130 010                    INB                    ;Add one to account for (cc) byte itself
1599 13-131 106 305 012            CAL ADBDE              ;Add value in B to D&E to point to next line in
1600 13-134 066 360                LLI 360                ;User program buffer. Reset L to addr of user logrn
1601 13-136 056 026                LHI \HB\OLDPG26        ;** Buffer pointer storage location. Store the new
1602 13-140 373                    LMD                    ;Updated user pgm line pointer in pointer storage
1603 13-141 060                    INL                    ;Location. Store both the high portion
1604 13-142 374                    LME                    ;And low portion. (Now points to next line to be
1605 13-143 066 340                LLI 340                ;Processed from user program buffer.) Change pointer
1606 13-145 056 026                LHI \HB\OLDPG26        ;** To address of line number buffer. Fetch the last
1607 13-147 307                    LAM                    ;Line number (length) processed. Test to see if it was
1608 13-150 240                    NDA                    ;Blank. If it was blank
1609 13-151 150 266 010            JTZ EXEC               ;Then stop processing and return to the Executive
1610 13-154 300                    LAA                    ;Insert two effective NOPs here
1611 13-155 300                    LAA                    ;In case of patching
1612 13-156 066 360     SAMLIN:    LLI 360                ;Load L with addr of user program buffer line pointer
1613 13-160 056 026                LHI \HB\OLDPG26        ;** Load H with page of same pointer
1614 13-162 327                    LCM                    ;Fetch the high portion of the pointer into register C
1615 13-163 060                    INL                    ;Advance the memory pointer
1616 13-164 367                    LLM                    ;Fetch the low portion of the pointer into register L
1617 13-165 352                    LHC                    ;Now move the high portion into register H
1618 13-166 036 026                LDI \HB\OLDPG26        ;** Set D to page of line input buffer
1619 13-170 046 000                LEI 000                ;Set E to address of start of line input buffer
1620 13-172 106 046 012            CAL MOVEC              ;Move the line ftom the user program buffer into the
1621 13-175 066 000                LLI 000                ;Line input buffer. Now reset the pointer to the start
1622 13-177 056 026                LHI \HB\OLDPG26        ;** Of the line input buffer.
1623 13-201 307                    LAM                    ;Fetch the first byte of the line input buffer (cc)
1624 13-202 240                    NDA                    ;Test (cc) value to see if fetched a blank line
1625 13-203 150 266 010            JTZ EXEC               ;If fetched a blank line, return to the Executive
1626 13-206 106 000 002            CAL SYNTAX             ;Else call subrtn to strip off line nr & set statement toke
1627                    
1628 13-211 066 203     DIRECT:    LLI 203                ;Load L with address of syntax TOKEN storage location
1629 13-213 056 026                LHI \HB\OLDPG26        ;** Load H with page of syntax TOKEN location
1630 13-215 307                    LAM                    ;Fetch the TOKEN value into the accumulator
1631 13-216 074 001                CPI 001                ;Is it token value for REM statement? If so, ignore the
1632 13-220 150 116 013            JTZ NXTLIN             ;Current line and go on to the next line in pgm buffer.
1633 13-223 074 002                CPI 002                ;Is it token value for IF statement?
1634 13-225 150 027 016            JTZ IF                 ;If yes, then go to the IF statement routine.
1635 13-230 074 003                CPI 003                ;Is it token value for LET statement? (Using keyword)
1636 13-232 150 031 015            JTZ LET                ;If yes, then go to the LET statement routine.
1637 13-235 074 004                CPI 004                ;Is it token value for GOTO statement?
1638 13-237 150 174 015            JTZ GOTO               ;If yes, then go to the GOTO statement routine.
1639 13-242 074 005                CPI 005                ;Is it token value for PRINT statement?
1640 13-244 150 345 013            JTZ PRINT              ;If yes, then go to the PRINT statement routine.
1641 13-247 074 006                CPI 006                ;Is it token value for INPUT statement?
1642 13-251 150 365 016            JTZ INPUT              ;If yes, then go to the INPUT statement routine.
1643 13-254 074 007                CPI 007                ;Is it token value for FOR statement?
1644 13-256 150 164 017            JTZ FOR                ;If yes, then go to the FOR statement routine.
1645 13-261 074 010                CPI 010                ;Is it token value for NEXT statement?
1646 13-263 150 013 030            JTZ NEXT               ;If yes, then go to the NEXT statement routine.
1647 13-266 074 011                CPI 011                ;Is it token value for GOSUB statement?
1648 13-270 150 236 016            JTZ GOSUB              ;If yes, then go to the GOSUB statement routine.
1649 13-273 074 012                CPI 012                ;Is it token value for RETURN statement?
1650 13-275 150 304 016            JTZ RETURN             ;If yes, then go to the RETURN statement routine.
1651 13-300 074 013                CPI 013                ;Is it token value for DIM statement?
1652 13-302 150 365 055            JTZ DIM                ;If yes, then go to the DIM statement routine.
1653 13-305 074 014                CPI 014                ;Is it token value for END statement?
1654 13-307 150 266 010            JTZ EXEC               ;If yes, then go back to the Executive, user pgm finished!
1655 13-312 074 015                CPI 015                ;Is it token value for IMPLIED LET statement?
1656 13-314 150 013 015            JTZ LET0               ;If yes, then go to special LET entry point.
1657 13-317 074 016                CPI 016                ;@@ Is it token value for ARRAY IMPLIED LET?
1658 13-321 110 152 011            JFZ SYNERR             ;If not, then assume a syntax error condition.
1659 13-324 106 153 055            CAL ARRAY1             ;@@ Else, perform array storage set up subroutine.
1660 13-327 066 206                LLI 206                ;@@ Set L to array pointer storage location.
1661 13-331 056 026                LHI \HB\OLDPG26        ;@@ * * Set H to array pointer storage location.
1662 13-333 317                    LBM                    ;@@ Fetch array pointer to register B.
1663 13-334 066 202                LLI 202                ;@@ Change memory pointer to syntax pntr storage loc.
1664 13-336 371                    LMB                    ;@@ Save array pointer value there.
1665 13-337 106 240 010            CAL SAVESY             ;@@ Save array name in auxiliary symbol buffer
1666 13-342 104 042 015            JMP LET1
1667 13-345 066 202     PRINT:     LLI 202                ;Load L with address of SCAN pointer storage location
1668 13-347 056 026                LHI \HB\OLDPG26        ;** Load H with page of SCAN pointer
1669 13-351 307                    LAM                    ;Fetch the pointer value (last character scanned by the
1670 13-352 066 000                LLI 000                ;SYNTAX routine). Change pointer to line buffer (cc).
1671 13-354 277                    CPM                    ;Compare pointer value to buffer length. If not equal
1672 13-355 160 366 013            JTS PRINT1             ;Then line contains more than stand alone PRINT state-
1673 13-360 106 141 003            CAL CRLF               ;Ment. However, if just have PRINT statement then issue
1674 13-363 104 116 013            JMP NXTLIN             ;A carriage-return & line-feed combination, then exit.
1675 13-366 106 255 002 PRINT1:    CAL CLESYM             ;Initialize the SYMBOL buffer for new entry.
1676 13-371 066 202                LLI 202                ;Load L with address of SCAN buffer pointer
1677 13-373 056 026                LHI \HB\OLDPG26        ;** Load H with page of SCAN pointer
1678 13-375 317                    LBM                    ;Pointer points to last char scanned by SYNTAX. Need
1679 13-376 010                    INB                    ;To increment it to point to next char in statement line.
1680 13-377 066 203                LLI 203                ;Load L with address of former TOKEN value. Use it as
1681 14-001 371                    LMB                    ;Storage location for a PRINT statement pointer.
1682 14-002 066 203     PRINT2:    LLI 203                ;Set memory pointer to PRINT pointer storage location
1683 14-004 106 240 002            CAL GETCHR             ;Fetch character in input buffer pointed to by PRINT
1684 14-007 074 247                CPI 247                ;Pointer. See if it is ASCII code for single quote mark.
1685 14-011 150 203 014            JTZ QUOTE              ;If so, go to QUOTE section to process text string.
1686 14-014 074 242                CPI 242                ;If not, see if it is ASCII code for double quote mark.
1687 14-016 150 203 014            JTZ QUOTE              ;If so, go to QUOTE section to process text string.
1688 14-021 074 254                CPI 254                ;If not, see if it is ASCII code for comma sign.
1689 14-023 150 043 014            JTZ PRINT3             ;If so, go evaluate expression.
1690 14-026 074 273                CPI 273                ;If not, see if it is ASCII code for semi-colon sign.
1691 14-030 150 043 014            JTZ PRINT3             ;If so, go evaluate expression.
1692 14-033 066 203                LLI 203                ;Load L with address of PRINT pointer storage location.
1693 14-035 106 003 003            CAL LOOP               ;Increment pointer and test for end of line.
1694 14-040 110 002 014            JFZ PRINT2             ;If not end of line, fetch the next character.
1695 14-043 066 202     PRINT3:    LLI 202                ;Load L with address of SCAN pointer storage location
1696 14-045 317                    LBM                    ;Fetch value of the pointer (last letter of KEYWORD)
1697 14-046 010                    INB                    ;Add one to point to first character of expression
1698 14-047 066 276                LLI 276                ;Load L with addr of EVAL pointer storage location
1699 14-051 371                    LMB                    ;Store addr at which EVAL should start scanning
1700 14-052 066 203                LLI 203                ;Load L with address of PRINT pointer
1701 14-054 317                    LBM                    ;Which points to field terminator
1702 14-055 011                    DCB                    ;Decrement pointer value to last character of expression
1703 14-056 066 277                LLI 277                ;Load L with address of EVAL FINISH pntr storage loc.
1704 14-060 371                    LMB                    ;Place address value of last char in PRINT field there
1705 14-061 066 367                LLI 367                ;Load L with address of QUOTE flag
1706 14-063 307                    LAM                    ;Fetch the value of the QUOTE flag into the ACC
1707 14-064 240                    NDA                    ;Test the QUOTE flag status
1708 14-065 150 075 014            JTZ PRINT4             ;If field not quoted, proceed to evaluate expression
1709 14-070 076 000                LMI 000                ;If field quoted, then clear the QUOTE flag for next field
1710 14-072 104 125 014            JMP PRINT6             ;And skip the evaluation procedure
1711 14-075 106 224 003 PRINT4:    CAL EVAL               ;Evaluate the current PRINT field
1712 14-100 066 177                LLI 177                ;Then load L,with address of the TAB flag
1713 14-102 056 026                LHI \HB\OLDPG26        ;** Load H with the page of the TAB flag
1714 14-104 307                    LAM                    ;Fetch the value of the TAB flag into the accumulator
1715 14-105 240                    NDA                    ;Test the TAB flag
1716 14-106 066 110                LLI 110                ;Change L to the FIXED/FLOAT flag location
1717 14-110 056 001                LHI \HB\OLDPG1         ;** Change H to the FIXED/FLOAT flag page
1718 14-112 076 377                LMI 377                ;Set FIXED/FLOAT flag to fixed point
1719 14-114 152 314 014 PRINT5:    CTZ PFPOUT             ;If TAB flag not set, display value of expression
1720 14-117 066 177                LLI 177                ;Load L with address of TAB flag
1721 14-121 056 026                LHI \HB\OLDPG26        ;** Load H with page of TAB flag
1722 14-123 076 000                LMI 000                ;Reset TAB flag for next PRINT field
1723 14-125 066 203     PRINT6:    LLI 203                ;Load L with address of PRINT pointer stomge location
1724 14-127 106 240 002            CAL GETCHR             ;Fetch the character pointed to by the PRINT pointer
1725 14-132 074 254                CPI 254                ;See if the last character scanned was a comma sign
1726 14-134 152 357 014            CTZ PCOMMA             ;If so, then display spaces to next TA.B location
1727 14-137 066 203                LLI 203                ;Reset L to address of PRINT pointer storage location
1728 14-141 056 026                LHI \HB\OLDPG26        ;** Reset H to page of PRINT pointer stomge location
1729 14-143 317                    LBM                    ;Fetch the value of the pointer into register B
1730 14-144 066 202                LLI 202                ;Change L to SCAN pointer storage location
1731 14-146 371                    LMB                    ;Place end of last field processed into SCAN pointer
1732 14-147 066 000                LLI 000                ;Change pointer to start of line input buffer
1733 14-151 301                    LAB                    ;Place pntr to last char scanned into the accumulator
1734 14-152 277                    CPM                    ;Compare this value to the (cc) for the line buffer
1735 14-153 160 366 013            JTS PRINT1             ;If not end of line, continue to process next field
1736 14-156 066 000                LLI 000                ;If end of line, fetch the last character in the line
1737 14-160 106 240 002            CAL GETCHR             ;And check to see if it
1738 14-163 074 254                CPI 254                ;Was a comma. If it was, go on to the next line in the
1739 14-165 150 116 013            JTZ NXTLIN             ;User program buffer without displaying a CR & LF.
1740 14-170 074 273                CPI 273                ;If not a comma, check to see if it was a semi-colon.
1741 14-172 150 116 013            JTZ NXTLIN             ;If so, do not provide a CR & LF combination.
1742 14-175 106 141 003            CAL CRLF               ;If not comma or semi-colon, provide CR & LF at end
1743 14-200 104 116 013            JMP NXTLIN             ;Of a PRINT statement. Go process next line of pgrm.
1744 14-203 066 367     QUOTE:     LLI 367                ;Load L with address of QUOTE flag
1745 14-205 370                    LMA                    ;Store type of quote in flag storage location
1746 14-206 106 255 002            CAL CLESYM             ;Initialize the SYMBOL buffer for new entry
1747 14-211 066 203                LLI 203                ;Load L with address of PRINT pointer
1748 14-213 317                    LBM                    ;Fetch the PRINT pointer into register B
1749 14-214 010                    INB                    ;Add one to advance over quote character
1750 14-215 066 204                LLI 204                ;Load L with address of QUOTE pointer
1751 14-217 371                    LMB                    ;Store the beginning of the QUOTE field pointer
1752 14-220 066 204     QUOTE1:    LLI 204                ;Load L with address of QUOTE pointer
1753 14-222 106 240 002            CAL GETCHR             ;Fetch the next character in the TEXT field
1754 14-225 066 367                LLI 367                ;Load L with the QUOTE flag (type of quote)
1755 14-227 277                    CPM                    ;Compare to see if latest character this quote mark
1756 14-230 150 263 014            JTZ QUOTE2             ;If so, finish up this quote field
1757 14-233 106 202 003            CAL ECHO               ;If not, display the character as part of TEXT
1758 14-236 066 204                LLI 204                ;Reset L to QUOTE pointer storage location
1759 14-240 106 003 003            CAL LOOP               ;Increment QUOTE pointer and test for end of line
1760 14-243 110 220 014            JFZ QUOTE1             ;If not end of line, continue processing TEXT field
1761 14-246 006 311     QUOTER:    LAI 311                ;If end of line before closing quote mark have an error
1762 14-250 026 321                LCI 321                ;So load ACC with I and register C with Q
1763 14-252 066 367                LLI 367                ;Load L with the address of the QUOTE flag
1764 14-254 056 026                LHI \HB\OLDPG26        ;** Load H with the page of the QUOTE flag
1765 14-256 076 000                LMI 000                ;Clear the QUOTE flag for future use
1766 14-260 104 226 002            JMP ERROR              ;Go display the IQ (Illegal Quote) error message
1767 14-263 066 204     QUOTE2:    LLI 204                ;Load L with address of QUOTE pointer
1768 14-265 317                    LBM                    ;Fetch the QUOTE pointer into register B
1769 14-266 066 202                LLI 202                ;Load L with address of SCAN pointer storage location
1770 14-270 371                    LMB                    ;Store former QUOTE vointer as start of next field
1771 14-271 301                    LAB                    ;Place QUOTE pointer into the accumulator
1772 14-272 066 000                LLI 000                ;Change L to point to start of the input line buffer
1773 14-274 277                    CPM                    ;Compare QUOTE pointer value with (cc) value
1774 14-275 110 366 013            JFZ PRINT1             ;If not end of line, process next PRINT field
1775 14-300 106 141 003            CAL CRLF               ;Else display a CR & LF combination at the end of line
1776 14-303 066 367                LLI 367                ;Load L with the address of the TAB flag
1777 14-305 056 026                LHI \HB\OLDPG26        ;** Load H with the page of the TAB flag
1778 14-307 076 000                LMI 000                ;Clear the TAB flag for future use
1779 14-311 104 116 013            JMP NXTLIN             ;Go process next line of the program.
1780                    
1781                                                      ;The following subroutines are utilized by the PRINT
1782                                                      ;routine.
1783                    ;;; The label PFPOUT SHOULD BE AT 14 314
1784 14-314 066 126     PFPOUT:    LLI 126                ;Load L with the address of the FPACC MSW (Floating
1785 14-316 056 001                LHI \HB\OLDPG1         ;** Point ACC). Load H with page of the FPACC MSW.
1786 14-320 307                    LAM                    ;Fetch the FPACC MSW into the accumulator. Test to
1787 14-321 240                    NDA                    ;See if the FPACC MSW is zero. If so, then simply go and
1788 14-322 150 336 014            JTZ ZERO               ;Display the value "0"
1789 14-325 060                    INL                    ;Else advance the pointer to the FPACC Exponent
1790 14-326 307                    LAM                    ;Fetch the FPACC Exponent into the accumulator
1791 14-327 240                    NDA                    ;See if any exponent value. If not, mantissa is in range
1792 14-330 150 350 014            JTZ FRAC               ;0.5 to 1.0. Treat number as a fraction.
1793 14-333 104 165 024            JMP FPOUT              ;Else perform regular numerical output routine.
1794 14-336 006 240     ZERO:      LAI 240                ;Load ASCII code for space into the ACC
1795 14-340 106 202 003            CAL ECHO               ;Display the space
1796 14-343 006 260                LAI 260                ;Load ASCII code for 0 into the ACC
1797 14-345 104 202 003            JMP ECHO               ;Display 0 and exit to calling routine
1798 14-350 066 110     FRAC:      LLI 110                ;Load L with address of FIXED/FLOAT flag
1799 14-352 076 000                LMI 000                ;Reset it to indicate floating point mode
1800 14-354 104 165 024            JMP FPOUT              ;Display floating point number and return to caller
1801 14-357 066 000     PCOMMA:    LLI 000                ;Load L with address of (cc) in line input buffer
1802 14-361 307                    LAM                    ;Fetch the (cc) for the line into the ACC
1803 14-362 066 203                LLI 203                ;Change pointer to PRINT pointer storage location
1804 14-364 227                    SUM                    ;Subtract value of PRINT pointer from line (cc)
1805 14-365 063                    RTS                    ;If at end of buffer, do not TAB
1806 14-366 066 043                LLI 043                ;If not end, load L with address of COLUMN COUNTER
1807 14-370 056 001                LHI \HB\OLDPG1         ;** Set H to page of COLUMN COUNTER
1808 14-372 307                    LAM                    ;Fetch COLUMN COUNTER into the accumulator
1809 14-373 044 360                NDI 360                ;Find the last TAB position (multiple of 16 decimal)
1810 14-375 004 020                ADI 020                ;Add 16 (decimal) to get new TAB position
1811 14-377 227                    SUM                    ;Subtract current position from next TAB position
1812 15-000 320                    LCA                    ;Store this value in register C as a counter
1813 15-001 006 240                LAI 240                ;Load the ACC with the ASCII code for space
1814 15-003 106 202 003 PCOM1:     CAL ECHO               ;Display the space
1815 15-006 021                    DCC                    ;Decrement the loop counter
1816 15-007 110 003 015            JFZ PCOM1              ;Continue displaying spaces until loop counter is zero
1817 15-012 007                    RET                    ;Then return to calling routine
1818 15-013 106 240 010 LET0:      CAL SAVESY             ;Entry point for IMPLIED LET statement. Save the
1819 15-016 066 202                LLI 202                ;Variable (to left of the equal sign). Set L to the SCAN
1820 15-020 056 026                LHI \HB\OLDPG26        ;** Pointer. Set H to the page of the SCAN pointer.
1821 15-022 317                    LBM                    ;Fetch value of SCAN pointer. (Points to = sign in In bf)
1822 15-023 066 203                LLI 203                ;Change pointer to LET pointer (was TOKEN value)
1823 15-025 371                    LMB                    ;Place the SCAN pointer value into the LET pointer
1824 15-026 104 141 015            JMP LET5               ;Continue processing the LET statement line
1825 15-031 106 255 002 LET:       CAL CLESYM             ;Initialize the SYMBOL BUFFER for new entry
1826 15-034 066 144                LLI 144                ;Load L with address of start of AUX SYMBOL BUFF
1827 15-036 056 026                LHI \HB\OLDPG26        ;** Load H with page of AUX SYMBOL BUFFER
1828 15-040 076 000                LMI 000                ;Initialize AUX SYMBOL BUFFER
1829 15-042 066 202     LET1:      LLI 202                ;Entry point for ARRAY IMPLIED LET statement.
1830 15-044 056 026                LHI \HB\OLDPG26        ;** Set pointer to SCAN pointer storage location
1831 15-046 317                    LBM                    ;Fetch the SCAN pointer value (last letter scanned by
1832 15-047 010                    INB                    ;SYNTAX subroutine) and add one to next character
1833 15-050 066 203                LLI 203                ;Change L to LET pointer storage location
1834 15-052 371                    LMB                    ;Store former SCAN value (updated) in LET pointer
1835 15-053 066 203     LET2:      LLI 203                ;Set L to gtorage location of LET pointer
1836 15-055 106 240 002            CAL GETCHR             ;Fetch the character pointed to by the LET pointer
1837 15-060 150 122 015            JTZ LET4               ;If character is a space, ignore it
1838 15-063 074 275                CPI 275                ;See if character is the equal (=) sign
1839 15-065 150 141 015            JTZ LET5               ;If so, go process other side of the statement (after
1840 15-070 074 250                CPI 250                ;@@ If not, see if character is a right parenthesis
1841 15-072 110 113 015            JFZ LET3               ;If not, continue looking for equal sign
1842 15-075 106 145 055            CAL ARRAY              ;@@ If so, have subscript. Call array set up subroutine.
1843 15-100 066 206                LLI 206                ;@@ Load L with address of ARRAY pointer
1844 15-102 056 026                LHI \HB\OLDPG26        ;@@ ** Load H with page of ARRAY pointer
1845 15-104 317                    LBM                    ;@@ Fetch value (points to ")" character of subscript)
1846 15-105 066 203                LLI 203                ;@@ Load L with address of LET pointer
1847 15-107 371                    LMB                    ;@@ Place ARRAY pointer value as new LET pointer
1848 15-110 104 122 015            JMP LET4               ;@@ Continue to look for = sign in statement line
1849 15-113 066 144     LET3:      LLI 144                ;Reset L to start of AUX SYMBOL BUFFER
1850 15-115 056 026                LHI \HB\OLDPG26        ;** Load H with page of AUX SYMBOL BUFFER
1851 15-117 106 314 002            CAL CONCT1             ;Concatenate character to the AUX SYMBOL BUFFER
1852 15-122 066 203     LET4:      LLI 203                ;Load L with address of LET pointer storage location
1853 15-124 106 003 003            CAL LOOP               ;Add one to pointer and test for end of line input buffer
1854 15-127 110 053 015            JFZ LET2               ;If not end of line, continue looking for the equal sign
1855 15-132 006 314     LETERR:    LAI 314                ;If do not find an equal sign in the LET statement line
1856 15-134 026 305                LCI 305                ;Then have a LE (Let Error). Load the code for L and E
1857 15-136 104 226 002            JMP ERROR              ;Into registers ACC and C and go display the error msg.
1858 15-141 066 203     LET5:      LLI 203                ;When find the equal sign, reset L to point to the LET
1859 15-143 056 026                LHI \HB\OLDPG26        ;** Pointer and H to the proper page. Fetch the pointer
1860 15-145 317                    LBM                    ;Value into register B and add one to advance pointer
1861 15-146 010                    INB                    ;Over the equal sign to first char in the expression.
1862 15-147 066 276                LLI 276                ;Set L to point to the address of the EVAL pointer
1863 15-151 371                    LMB                    ;Set EVAL pointer to start evaluating right after the
1864 15-152 066 000                LLI 000                ;Equal sign. Now change L to start of line input buffer.
1865 15-154 317                    LBM                    ;Fetch the (cc) value into register B. (Length of line.)
1866 15-155 066 277                LLI 277                ;Load L with EVAL FINISH pointer storage location.
1867 15-157 371                    LMB                    ;Set it to stop evaluating at end of the line.
1868 15-160 106 224 003            CAL EVAL               ;Call the subroutine to evaluate the expression.
1869 15-163 106 252 010            CAL RESTSY             ;Restore the name of the variable to receive new value.
1870 15-166 106 055 010            CAL STOSYM             ;Store the new value for the variable in variables table.
1871 15-171 104 116 013            JMP NXTLIN             ;Go process next line of the program.
1872 15-174 066 350     GOTO:      LLI 350                ;Load L with start of AUX LINE NR BUFFER
1873 15-176 056 026                LHI \HB\OLDPG26        ;** Load H with page of AUX LINE NR BUFFER
1874 15-200 076 000                LMI 000                ;Initialize the AUX LINE NR BUFFER to zero
1875 15-202 066 202                LLI 202                ;Load L with address of SCAN pointer storage location
1876 15-204 317                    LBM                    ;Fetch pointer value (last char scanned by SYNTAX)
1877 15-205 010                    INB                    ;Add one to skip over the last 0 in GOTO keyword
1878 15-206 066 203                LLI 203                ;Change pointer to GOTO pointer (formerly TOKEN)
1879 15-210 371                    LMB                    ;Store the updated SCAN pointer as the GOTO pointer
1880 15-211 066 203     GOTO1:     LLI 203                ;Load L with address of GOTO pointer
1881 15-213 106 240 002            CAL GETCHR             ;Fetch the character pointed to by the GOTO pointer
1882 15-216 150 240 015            JTZ GOTO2              ;If character was a space, ignore it
1883 15-221 074 260                CPI 260                ;See if character is in the range of a decimal digit
1884 15-223 160 250 015            JTS GOTO3              ;If not, must have end of the line number digit string
1885 15-226 074 272                CPI 272                ;Continue to test for decitnal digit
1886 15-230 120 250 015            JFS GOTO3              ;If not, mugt have end of the line number digit string
1887 15-233 066 350                LLI 350                ;If valid decimal digit, load L with addr of AUX LINE
1888 15-235 106 314 002            CAL CONCT1             ;NR BUFFER and concatenate digit to the buffer.
1889 15-240 066 203     GOTO2:     LLI 203                ;Reset pointer to GOTO pointer storage location
1890 15-242 106 003 003            CAL LOOP               ;Advance the pointer value and test for end of line
1891 15-245 110 211 015            JFZ GOTO1              ;If not end of line, fetch next digit in GOTO line number
1892 15-250 066 360     GOTO3:	   LLI 360                ;Set L to user program buffer pointer storage location
1893 15-252 056 026                LHI \HB\OLDPG26        ;** Set H to page of program buffer pointer
1894 15-254 076 033                LMI BGNPGRAM           ;Initialize high part of pointer to start of pgm buffer
1895 15-256 060                    INL                    ;Advance the memory point
1896 15-257 076 000                LMI 000                ;Initialize the low part of pointer to start of pgm buffer
1897 15-261 106 255 002 GOTO4:     CAL CLESYM             ;Clear the SYMBOL BUFFER
1898 15-264 066 204                LLI 204                ;Load L with address of GOTO SEARCH pointer
1899 15-266 076 001                LMI 001                ;Initialize to one for first char of line
1900 15-270 066 204     GOTO5:     LLI 204                ;Load L with address of GOTO SEARCH pointer
1901 15-272 106 123 012            CAL GETCHP             ;Fetch character pointed to by GOTO SEARCH pointer
1902 15-275 150 315 015            JTZ GOTO6              ;From line pointed to in user program buffer. Ignore
1903 15-300 074 260                CPI 260                ;Spaces. Check to see if character is a decirnal digit.
1904 15-302 160 340 015            JTS GOTO7              ;If not, then have processed line number at the start of
1905 15-305 074 272                CPI 272                ;The current line. Continue the check for a valid decimal
1906 15-307 120 340 015            JFS GOTO7              ;Digit. If have a decirnal digit then concatenate the digit
1907 15-312 106 310 002            CAL CONCTS             ;Onto the current string in the SYMBOL BUFFER,
1908 15-315 066 204     GOTO6:     LLI 204                ;Change L to the address of the GOTO SEARCH pointer
1909 15-317 056 026                LHI \HB\OLDPG26        ;** And H to the proper page of the pointer
1910 15-321 317                    LBM                    ;Fetch the GOTO SEARCH pointer value
1911 15-322 010                    INB                    ;Increment the GOTO SEARCH pointer
1912 15-323 371                    LMB                    ;And restore it back to memory
1913 15-324 066 360                LLI 360                ;Change L to address of user program buffer pointer
1914 15-326 327                    LCM                    ;Save the high part of this pointer value in register C
1915 15-327 060                    INL                    ;Advance L to the low part of the pgrn buffer pointer
1916 15-330 367                    LLM                    ;Now load it into L
1917 15-331 352                    LHC                    ;And transfer C into H to point to start of the line
1918 15-332 307                    LAM                    ;Fetch the (cc) of the current line being pointed to in the
1919 15-333 011                    DCB                    ;User pgm buff. Decrernent B to previous value. Compare
1920 15-334 271                    CPB                    ;GOTO SEARCH pointer value to length of current line.
1921 15-335 110 270 015            JFZ GOTO5              ;If not end of line then continue getting current line nr.
1922 15-340 066 120     GOTO7:     LLI 120                ;Load L with address of start of the SYMBOL BUFFER
1923 15-342 056 026                LHI \HB\OLDPG26        ;Set H to the page of the SYMBOL BUFFER
1924 15-344 036 026                LDI \HB\OLDPG26        ;Set D to the page of the AUX LINE NR BUFFER
1925 15-346 046 350                LEI 350                ;Set E to the start of the AUX LINE NR BUFFER
1926 15-350 106 332 002            CAL STRCP              ;Compare GOTO line number against current line nr.
1927 15-353 150 156 013            JTZ SAMLIN             ;If they match, found GOTO line. Pick up ops there!
1928 15-356 066 360                LLI 360                ;Else, set L to user program buffer pntr storage location
1929 15-360 056 026                LHI \HB\OLDPG26        ;** Set H to page of user program buffer pointer
1930 15-362 337                    LDM                    ;Fetch the high part of this pointer into register D
1931 15-363 060                    INL                    ;Advance the memory pointer
1932 15-364 347                    LEM                    ;Fetch the low part into register E
1933 15-365 353                    LHD                    ;Transfer the pointer to H
1934 15-366 364                    LLE                    ;And L. Fetch the (cc) of the current line into register
1935 15-367 317                    LBM                    ;B and then add one to account for the (cc) byte to get
1936 15-370 010                    INB                    ;Total length of the current line in the user pgm buffer
1937 15-371 106 305 012            CAL ADBDE              ;Add the total length to the pointer value in D & E
1938 15-374 066 360                LLI 360                ;To get the starting address of the next line in the user
1939 15-376 056 026                LHI \HB\OLDPG26        ;** User program buffer. Place the new value for the user
1940 16-000 373                    LMD                    ;Program buffer pointer back into the user program
1941 16-001 060                    INL                    ;Buffer pointer storage locations so that it points to the
1942 16-002 374                    LME                    ;Next line to be processed in the user program buffer.
1943 16-003 066 364                LLI 364                ;Load L with address of end of user pgm buffer storage
1944 16-005 303                    LAD                    ;Location (page address) and fetch end of buffer page.
1945 16-006 277                    CPM                    ;Compare this with next line pointer (updated).
1946 16-007 110 261 015            JFZ GOTO4              ;If not end of buffer, keep looking for the specified line
1947 16-012 060                    INL                    ;If have same page addresses, check the low address
1948 16-013 304                    LAE                    ;Portions to see if
1949 16-014 277                    CPM                    ;Have reached end of user program buffer
1950 16-015 110 261 015            JFZ GOTO4              ;If not, continue looking. If end of buffer without
1951 16-020 006 325     GOTOER:    LAI 325                ;Finding specified line, then have an error condition.
1952 16-022 026 316                LCI 316                ;Load ACC and register C with code for "UN" and go
1953 16-024 104 226 002            JMP ERROR              ;Display "Undefined Line" error message.
1954 16-027 066 202     IF:        LLI 202                ;Set L to SCAN pointer storage location.
1955 16-031 056 026                LHI \HB\OLDPG26        ;** Load H to page of SCAN pointer storage location.
1956 16-033 317                    LBM                    ;Fetch the SCAN pointer value to register B.
1957 16-034 010                    INB                    ;Add one to advance pointer over last char scanned.
1958 16-035 066 276                LLI 276                ;Change L to address of EVAL pointer. Set up EVAL
1959 16-037 371                    LMB                    ;Pointer to begin evaluation with next char in the line.
1960 16-040 106 255 002            CAL CLESYM             ;Clear the SYMBOL BUFFER.
1961 16-043 066 320                LLI 320                ;Set L to starting address of THEN in look-up table.
1962 16-045 056 001                LHI \HB\OLDPG1         ;** Set H to page of the look-up table.
1963 16-047 106 012 013            CAL INSTR              ;Search for occurrence of THEN in the line input buffer.
1964 16-052 304                    LAE                    ;Transfer register E to ACC. If THEN not found
1965 16-053 240                    NDA                    ;The value in E will be zero.
1966 16-054 110 102 016            JFZ IF1                ;If THEN found, can evaluate the IF expression.
1967 16-057 066 013                LLI 013                ;If THEN not found, set L to Auting address of GOTO
1968 16-061 056 027                LHI \HB\OLDPG27        ;** In the KEYWORD look-up table. Set H to table
1969 16-063 106 012 013            CAL INSTR              ;Search for occurrence of GOTO in the line input buffer.
1970 16-066 304                    LAE                    ;Transfer E to ACC. If GOTO not found
1971 16-067 240                    NDA                    ;The value in E will be zero.
1972 16-070 110 102 016            JFZ IF1                ;If GOTO found, can evaluate the IF expression.
1973 16-073 006 311     IFERR:     LAI 311                ;Set ASCII code for letter I in ACC
1974 16-075 026 306                LCI 306                ;And code for letter F in register C
1975 16-077 104 226 002            JMP ERROR              ;Go display the IF error message
1976 16-102 066 277     IF1:       LLI 277                ;Load L with addr of EVAL FINISH pointer storage loc
1977 16-104 056 026                LHI \HB\OLDPG26        ;** Load H with page of storage location
1978 16-106 041                    DCE                    ;Subtract one from pointer in E and set the EVAL
1979 16-107 374                    LME                    ;FINISH pointer so that it will evaluate up to the THEN
1980 16-110 106 224 003            CAL EVAL               ;Or GOTO directive. Evaluate the expression.
1981 16-113 066 126                LLI 126                ;Load L with address of FPACC Most Significant Word
1982 16-115 056 001                LHI \HB\OLDPG1         ;** Load H with page of FPACC MSW
1983 16-117 307                    LAM                    ;Fetch the FPACC MSW into the accumulator
1984 16-120 240                    NDA                    ;Test the value of the FPACC MSW
1985 16-121 150 116 013            JTZ NXTLIN             ;If it is zero, IF condition failed, ignore rest of line.
1986 16-124 066 277                LLI 277                ;If not, load L with addr of EVAL FINISH pointer
1987 16-126 056 026                LHI \HB\OLDPG26        ;** Set H to the appmpriate page
1988 16-130 307                    LAM                    ;Fetch the value in the EVAL FINISH pointer
1989 16-131 004 005                ADI 005                ;Add five to skip over THEN or GOTO directive
1990 16-133 066 202                LLI 202                ;Change L to SCAN pointer stomge location
1991 16-135 370                    LMA                    ;Set up the SCAN pointer to location after THEN or
1992 16-136 310                    LBA                    ;GOTO directive. Also put this value in register B.
1993 16-137 010                    INB                    ;Add one to the value in B to point to next character
1994 16-140 066 204                LLI 204                ;After THEN or GOTO. Change L to addr of THEN pntr
1995 16-142 371                    LMB                    ;Storage location and store the pointer value.
1996 16-143 066 204     IF2:       LLI 204                ;Load L with the address of the THEN pointer
1997 16-145 106 240 002            CAL GETCHR             ;Fetch the character pointed to by the THEN pointer
1998 16-150 110 166 016            JFZ IF3                ;If character is not a space, exit this loop
1999 16-153 066 204                LLI 204                ;If fetch a space, ignore. Reset L to the THEN pointer
2000 16-155 106 003 003            CAL LOOP               ;Add one to the THEN pointer and test for end of line
2001 16-160 110 143 016            JFZ IF2                ;If not end of line, keep looking for a character other
2002 16-163 104 073 016            JMP IFERR              ;Than a space. If reach end of line first, then error
2003 16-166 074 260     IF3:       CPI 260                ;When find a character see if it is numeric.
2004 16-170 160 200 016            JTS IF4                ;If not numeric, then should have a new type of
2005 16-173 074 272                CPI 272                ;Statement. If numeric, then should have a line number.
2006 16-175 160 174 015            JTS GOTO               ;So process as though have a GOTO statement!
2007 16-200 066 000     IF4:       LLI 000                ;Load L with addr of start of line input buffer.
2008 16-202 307                    LAM                    ;Fetch the (cc) byte to get length of line value.
2009 16-203 066 204                LLI 204                ;Change L to current value of THEN pointer (where first
2010 16-205 227                    SUM                    ;Non-space char. found after THEN or GOTO). Subtract
2011 16-206 310                    LBA                    ;This value from length of line to get remainder. Now
2012 16-207 010                    INB                    ;Have length of second statement portion. Add one for
2013 16-210 327                    LCM                    ;(cc) count. Save THEN pointer value in register C.
2014 16-211 066 000                LLI 000                ;Reset L to start of line input buffer. Now put length of
2015 16-213 371                    LMB                    ;Second statement into (cc) position of input buffer.
2016 16-214 362                    LLC                    ;Set L to where second statement starts.
2017 16-215 036 026                LDI \HB\OLDPG26        ;** Set D to page of line input buffer.
2018 16-217 046 001                LEI 001                ;Set E to first character position of line input buffer.
2019 16-221 106 013 021            CAL MOVEIT             ;Move the second statement up in line to become first!
2020 16-224 066 202                LLI 202                ;Load L with address of new SCAN pointer. Load
2021 16-226 076 001                LMI 001                ;It with starting position for SYNTAX scan.
2022 16-230 106 067 002            CAL SYNTX4             ;Use special entry to SYNTAX to get new TOKEN value.
2023 16-233 104 211 013            JMP DIRECT             ;Process the second statement in the original line.
2024 16-236 066 340     GOSUB:     LLI 340                ;Load L with start of LINE NUMBER BUFFER
2025 16-240 056 026                LHI \HB\OLDPG26        ;Fetch (cc) of cuffent line number into register D
2026 16-242 337                    LDM                    ;Fetch high value (page) of pgm line pointer to D
2027 16-243 030                    IND                    ;Test contents of register by first incrementing
2028 16-244 031                    DCD                    ;And then decrementing the value in the register
2029 16-245 150 255 016            JTZ GOSUB1             ;If no line number, then processing a DIRECT statement
2030 16-250 066 360                LLI 360                ;Else, load L with address of user pgm buff line pointer
2031 16-252 337                    LDM                    ;Fetch high value (page) of pgm line pointer to D
2032 16-253 060                    INL                    ;Advance the memory pointer
2033 16-254 347                    LEM                    ;Fetch the low part of pgm line pointer to E
2034 16-255 066 073     GOSUB1:    LLI 073                ;Set L to address of GOSUB STACK POINTER
2035 16-257 056 027                LHI \HB\OLDPG27        ;** Set H to page of GOSUB STACK POINTER
2036 16-261 307                    LAM                    ;Fetch value in GOSUB stack pointer to ACC
2037 16-262 004 002                ADI 002                ;Add two to current stack pointer for new data to be
2038 16-264 074 021                CPI 021                ;Placed on the stack and see if stack overflows
2039 16-266 120 347 016            JFS GOSERR             ;If stack filled, have an error condition
2040 16-271 370                    LMA                    ;Else, store updated stack pointer
2041 16-272 066 076                LLI 076                ;Load L with address of start of stack less offset (2)
2042 16-274 206                    ADL                    ;Add GOSUB stack pointer to base address
2043 16-275 360                    LLA                    ;To get pointer to top of stack (page byte)
2044 16-276 373                    LMD                    ;Store page part of pgm buffer line pointer in stack
2045 16-277 060                    INL                    ;Advance pointer to next byte in stack
2046 16-300 374                    LME                    ;Store low part of pgm buffer line pointer in stack
2047 16-301 104 174 015            JMP GOTO               ;Proceed from here as though processing a GOTO
2048 16-304 066 073     RETURN:    LLI 073                ;Set L to address of GOSUB STACK POINTER
2049 16-306 056 027                LHI \HB\OLDPG27        ;** Set H to page of GOSUB STACK POINTER
2050 16-310 307                    LAM                    ;Fetch the value of GOSUB stack pointer to ACC
2051 16-311 024 002                SUI 002                ;Subtract two for data to be removed from stack
2052 16-313 160 356 016            JTS RETERR             ;If stack underflow, then have an error condition
2053 16-316 370                    LMA                    ;Restore new stack pointer to memory
2054 16-317 004 002                ADI 002                ;Add two to point to previous top of stack
2055 16-321 066 076                LLI 076                ;Load L with address of start of GOSUB stack less two
2056 16-323 206                    ADL                    ;Add address of previous top of stack to base value
2057 16-324 360                    LLA                    ;Set pointer to high address value in the stack
2058 16-325 337                    LDM                    ;Fetch the high address value from stack to register D
2059 16-326 030                    IND                    ;Exercise the register contents to see if high address
2060 16-327 031                    DCD                    ;Obtained is zero. If so, original GOSUB statement was
2061 16-330 150 266 010            JTZ EXEC               ;A DIRECT statement. Must return to Executive!
2062 16-333 060                    INL                    ;Else, advance pointer to get low address value from the
2063 16-334 347                    LEM                    ;Stack into CPU register E.
2064 16-335 066 360                LLI 360                ;Load L with address of user pgm line pointer storage
2065 16-337 056 026                LHI \HB\OLDPG26        ;** Location. Load H with page of user pgm line pntr.
2066 16-341 373                    LMD                    ;Put high address from stack into pgm line pointer.
2067 16-342 060                    INL                    ;Advance the memory pointer
2068 16-343 374                    LME                    ;Put low address from stack into pgrn line pointer.
2069 16-344 104 116 013            JMP NXTLIN             ;Execute the next line after originating GOSUB line!
2070 16-347 006 307     GOSERR:    LAI 307                ;Load ASCII code for letter G into accumulator
2071 16-351 026 323                LCI 323                ;Load ASCII code for letter S into register C
2072 16-353 104 226 002            JMP ERROR              ;Go display GoSub (GS) error message.
2073 16-356 006 322     RETERR:    LAI 322                ;Load ASCII code for letter R into accumulator
2074 16-360 026 324                LCI 324                ;Load ASCII code for letter T into register C
2075 16-362 104 226 002            JMP ERROR              ;Go display ReTurn (RT) error message.
2076 16-365 106 255 002 INPUT:     CAL CLESYM             ;Clear the SYMBOL BUFFER
2077 16-370 066 202                LLI 202                ;Load L with address of SCAN pointer storage location
2078 16-372 317                    LBM                    ;Fetch value of SCAN pointer to register B
2079 16-373 010                    INB                    ;Increment value to point to next chamcter
2080 16-374 066 203                LLI 203                ;Change L to point to INPUT pointer (formerly TOKEN)
2081 16-376 371                    LMB                    ;Updated SCAN pointer becomes INPUT pointer
2082 16-377 066 203     INPUT1:    LLI 203                ;Load L with address of INPUT pointer
2083 17-001 106 240 002            CAL GETCHR             ;Fetch a character from the line input buffer
2084 17-004 150 042 017            JTZ INPUT3             ;If character is a space, ignore it. Else,
2085 17-007 074 254                CPI 254                ;See if character is a comma. If so, process the
2086 17-011 150 063 017            JTZ INPUT4             ;Variable that preceeds the comma.
2087 17-014 074 250                CPI 250                ;If not, see if character is a left parenthesis.
2088 17-016 110 037 017            JFZ INPUT2             ;If not, continue processing to build up symbolic variable
2089 17-021 106 160 055            CAL ARRAY2             ;@@ If so, call array subscripting subroutine
2090 17-024 066 206                LLI 206                ;@@ Load L with address of array set up pointer
2091 17-026 056 026                LHI \HB\OLDPG26        ;@@ ** Load H with page of array set up pointer
2092 17-030 317                    LBM                    ;@@ Fetch pointer value (point to ")" of subscript)
2093 17-031 066 203                LLI 203                ;@@ Change pointer to address of INPUT pointer
2094 17-033 371                    LMB                    ;@@ Update INPUT pointer
2095 17-034 104 042 017            JMP INPUT3             ;@@ Jump over concatenate instruction below
2096 17-037 106 310 002 INPUT2:    CAL CONCTS             ;Concatenate character to SYMBOL BUFFER
2097 17-042 066 203     INPUT3:    LLI 203                ;Load L with address of INPUT pointer
2098 17-044 106 003 003            CAL LOOP               ;Increment INPUT pointer and test for end of line
2099 17-047 110 377 016            JFZ INPUT1             ;If not end of line, go get next character
2100 17-052 106 104 017            CAL INPUTX             ;If end of buffer, get input for variable in the SYMBOL
2101 17-055 106 055 010            CAL STOSYM             ;BUFFER and store the value in the VARIABLES table
2102 17-060 104 116 013            JMP NXTLIN             ;Then continue to interpret next statement line
2103 17-063 106 104 017 INPUT4:    CAL INPUTX             ;Get input from user for variable in SYMBOL BUFFER
2104 17-066 106 055 010            CAL STOSYM             ;Store the inputted value in the VARIABLES table
2105 17-071 056 026                LHI \HB\OLDPG26        ;** Set H to page of INPUT pointer
2106 17-073 066 203                LLI 203                ;Set L to location of INPUT pointer
2107 17-075 317                    LBM                    ;Fetch pointer value for last character examined
2108 17-076 066 202                LLI 202                ;Change L to point to SCAN pointer storage location
2109 17-100 371                    LMB                    ;Update the SCAN pointer
2110 17-101 104 365 016            JMP INPUT              ;Continue processing statement line for next variable
2111 17-104 066 120     INPUTX:    LLI 120                ;Load L with start of SYMBOL BUFFER (contains cc)
2112 17-106 307                    LAM                    ;Fetch the (cc) (length of symbol in the buffer) to ACC
2113 17-107 206                    ADL                    ;Add (cc) to base address to set up
2114 17-110 360                    LLA                    ;Pointer to last character in the SYMBOL BUFFER
2115 17-111 307                    LAM                    ;Fetch the last character in the SYMBOL BUFFER
2116 17-112 074 244                CPI 244                ;See if the last chamcter was a $ sign
2117 17-114 110 140 017            JFZ INPUTN             ;If not a $ sign, get variable value as a numerical entry
2118 17-117 066 120                LLI 120                ;If $ sign, reset L to start of the SYMBOL BUFFER
2119 17-121 317                    LBM                    ;Fetch the (cc) for the variable in the SYMBOL BUFF
2120 17-122 011                    DCB                    ;Subtract one from (cc) to chop off the $ sign
2121 17-123 371                    LMB                    ;Restore the new (cc) for the SYMBOL BUFFER
2122 17-124 106 157 017            CAL FP0                ;Call subroutine to zero the floating point accumulator
2123 17-127 106 221 003            CAL CINPUT             ;Input one character from system input device
2124 17-132 066 124                LLI 124                ;Load L with address of the LSW of the FPACC
2125 17-134 370                    LMA                    ;Place the ASCII code for the character inputted there
2126 17-135 104 064 020            JMP FPFLT              ;Convert value to floating point format in FPACC
2127 17-140 066 144     INPUTN:    LLI 144                ;Load L with address of start of AUX SYMBOL BUFF
2128 17-142 056 026                LHI \HB\OLDPG26        ;** Load H with page of AUX SYMBOL BUFFER
2129 17-144 006 277                LAI 277                ;Load accumulator with ASCII code for ? mark
2130 17-146 106 202 003            CAL ECHO               ;Call output subroutine to display the ? mark
2131 17-151 106 014 003            CAL STRIN              ;Input string of characters (number) fm input device
2132 17-154 104 044 023            JMP DINPUT             ;Convert decimal string into binary floating point nr.
2133 17-157 056 001     FP0:       LHI \HB\OLDPG1         ;** Load H with floating point working registers page
2134 17-161 104 247 006            JMP CFALSE             ;Zero the floating point accumulator & exit to caller
2135 17-164 066 144     FOR:       LLI 144                ;Load L with address of AUX SYMBOL BUFFER
2136 17-166 056 026                LHI \HB\OLDPG26        ;** Load H with page of AUX SYMBOL BUFFER
2137 17-170 076 000                LMI 000                ;Initialize buffer by clearing first byte
2138 17-172 066 146                LLI 146                ;Load L with location of second character in buffer
2139 17-174 076 000                LMI 000                ;Clear that location in case of single character variable
2140 17-176 066 205                LLI 205                ;Load L with address of FOR/NEXT STACK pointer
2141 17-200 056 027                LHI \HB\OLDPG27        ;** Load H with page of FOR/NEXT STACK pointer
2142 17-202 317                    LBM                    ;Fetch the FOR/NEXT STACK pointer
2143 17-203 010                    INB                    ;Increment it in preparation for pushing operation
2144 17-204 371                    LMB                    ;Restore it back to its storage location
2145 17-205 066 360                LLI 360                ;Load L with address of user pgrn buffer line pointer
2146 17-207 056 026                LHI \HB\OLDPG26        ;** Set H to page of line pointer
2147 17-211 337                    LDM                    ;Fetch page address of pgm buffer line pntr into D
2148 17-212 060                    INL                    ;Advance the memory pointer to pick up low part
2149 17-213 347                    LEM                    ;Fetch low address of pgm buffer line pntr into E
2150 17-214 301                    LAB                    ;Restore updated FOR/NEXT STACK pointer to ACC
2151 17-215 002                    RLC                    ;Rotate it left to multiply by two, then rotate it again to
2152 17-216 002                    RLC                    ;Multiply by four. Add this value to the base address of
2153 17-217 004 134                ADI 134                ;The FOR/NEXT STACK to point to the new top of
2154 17-221 360                    LLA                    ;The FOR/NEXT STACK and set up to point to stack
2155 17-222 056 027                LHI \HB\OLDPG27        ;** Set H for page of the FOR/NEXT STACK
2156 17-224 373                    LMD                    ;Store the page portion of the user pgrn buffer line pntr
2157 17-225 060                    INL                    ;In the FORINEXT STACK, advance register 4 then
2158 17-226 374                    LME                    ;Store the low portion of the pgrn line pntr on the stack
2159 17-227 066 325                LLI 325                ;Change L to point to start of TO string which is stored
2160 17-231 056 001                LHI \HB\OLDPG1         ;** In a text strings storage area on this page
2161 17-233 106 012 013            CAL INSTR              ;Search the statement line for the occurrence of TO
2162 17-236 304                    LAE                    ;Register E wiU be zero if TO not found. Move E to ACC
2163 17-237 240                    NDA                    ;To make a test
2164 17-240 110 252 017            JFZ FOR1               ;If TO found then proceed with FOR statement
2165 17-243 006 306     FORERR:    LAI 306                ;Else have a For Error. Load ACC with ASCII code for
2166 17-245 026 305                LCI 305                ;Letter F and register C with code for letter E.
2167 17-247 104 226 002            JMP ERROR              ;Then go display the FE message.
2168 17-252 066 202     FOR1:      LLI 202                ;Load L with address of SCAN pointer storage location
2169 17-254 056 026                LHI \HB\OLDPG26        ;** Set H to page of the SCAN pointer
2170 17-256 317                    LBM                    ;Fetch pointer value to ACC (points to letter R in the
2171 17-257 010                    INB                    ;For directive). Increment it to point to next character
2172 17-260 066 204                LLI 204                ;In the line. Change register L and set this value up
2173 17-262 371                    LMB                    ;As an updated FOR pointer.
2174 17-263 066 203                LLI 203                ;Set L to address of TO pointer (formerly TOKEN)
2175 17-265 374                    LME                    ;Save pointer to TO in the TO pointer!
2176 17-266 066 204     FOR2:      LLI 204                ;Load L with address of the FOR pointer
2177 17-270 106 240 002            CAL GETCHR             ;Fetch a character from the statement line
2178 17-273 150 310 017            JTZ FOR3               ;If it is a space, ignore it
2179 17-276 074 275                CPI 275                ;Test to see if character is the "=" sign
2180 17-300 150 323 017            JTZ FOR4               ;If so, variable name is in the AUX SYMBOLBUFFER
2181 17-303 066 144                LLI 144                ;If not, then set L to point to start of the AUX SYMBOL
2182 17-305 106 314 002            CAL CONCT1             ;BUFFER and concatenate the character onto the buffer
2183 17-310 066 204     FOR3:      LLI 204                ;Reset L to address of the FOR pointer
2184 17-312 106 003 003            CAL LOOP               ;Increment the pointer and see if end of line
2185 17-315 110 266 017            JFZ FOR2               ;If not end of line, continue looking for the "=" sign
2186 17-320 104 243 017            JMP FORERR             ;If reach end of line before "=" sign, then have error
2187 17-323 066 204     FOR4:      LLI 204                ;Set L with address of the FOR pointer
2188 17-325 317                    LBM                    ;Fetch pointer value to ACC (pointing to sign)
2189 17-326 010                    INB                    ;Increment it to skip over the "=" sign
2190 17-327 066 276                LLI 276                ;Set L to address of the EVAL pointer
2191 17-331 371                    LMB                    ;Restore the updated pointer to storage
2192 17-332 066 203                LLI 203                ;Set L to the address of the TO pointer
2193 17-334 317                    LBM                    ;Fetch pointer value to ACC (pointing to letter T in TO)
2194 17-335 011                    DCB                    ;Decrement it to point to character before the T in TO
2195 17-336 066 277                LLI 277                ;Set L to EVAL FINISH pointer storage location
2196 17-340 371                    LMB                    ;Store the EVAL FINISH pointer value
2197 17-341 106 224 003            CAL EVAL               ;Evaluate the expression between the "=" sign and TO
2198 17-344 106 252 010            CAL RESTSY             ;Directive. Place the variable name in the variables table.
2199 17-347 066 144                LLI 144                ;Load L with starting address of the AUX SYMBOL BF
2200 17-351 056 026                LHI \HB\OLDPG26        ;** Load H with the page of the AUX SYMBOL BUFF
2201 17-353 307                    LAM                    ;Fetch the (cc) for the name in the buffer
2202 17-354 074 001                CPI 001                ;See if the symbol (name) length is just one character
2203 17-356 110 246 031            JFZ FOR5               ;If not, go directly to place name in FOR/NEXT STACK
2204 17-361 066 146                LLI 146                ;If so, set L to point to second character location in the
2205 17-363 076 000                LMI 000                ;AUX SYMBOL BUFFER and set it equal to zero.
2206 17-365 104 246 031            JMP FOR5               ;This jump directs program over ontrs/cntrs/table area
2207                    ;;; LAST LINE SHOULD START AT 17 365
2208                    ;;; PATCH AREA FOLLOWS THIS
2209                    	
2210                    	ORG 020#000
2211 20-000 066 126     FPFIX:     LLI 126                ;Set L to point to MSW of FPACC
2212 20-002 056 001                LHI \HB\OLDPG1         ;** Set H to point to page of FPACC
2213 20-004 307                    LAM                    ;Fetch MSW of FPACC
2214 20-005 066 100                LLI 100                ;Change pointer to SIGN indicator on same page
2215 20-007 370                    LMA                    ;Place MSW of FPACC into SIGN indicator
2216 20-010 240                    NDA                    ;Now test sign bit of MSW of FPACC
2217 20-011 162 202 020            CTS FPCOMP             ;Two's complement value in FPACC if negative
2218 20-014 066 127                LLI 127                ;Change pointer to FPACC Exponent register
2219 20-016 006 027                LAI 027                ;Set accumulator to 23 (decimal) for number of bits
2220 20-020 317                    LBM                    ;Load FPACC Exponent into CPU register B
2221 20-021 010                    INB                    ;Exercise the value in register B
2222 20-022 011                    DCB                    ;To set CPU flags
2223 20-023 160 051 020            JTS FPZERO             ;If FPACC Exponent is negative set FPACC to zero
2224 20-026 221                    SUB                    ;Subtract value of FPACC Exponent from 23 decimal
2225 20-027 160 366 012            JTS FIXERR             ;If Exp larger than 23 decimal cannot convert
2226 20-032 320                    LCA                    ;Else place result in register C as counter for number
2227 20-033 066 126     FPFIXL:    LLI 126                ;Of rotate ops. Set pointer to MSW of FPACC
2228 20-035 016 003                LBI 003                ;Set precision counter (number of bytes in mantissa)
2229 20-037 106 211 022            CAL ROTATR             ;Rotate FPACC right the number of places indicated
2230 20-042 021                    DCC                    ;By count in register C to effectively rotate all the
2231 20-043 110 033 020            JFZ FPFIXL             ;Significant bits to the left of the floating point decimal
2232 20-046 104 175 020            JMP RESIGN             ;Point. Go check original sign & negate answer if req'd.
2233                    
2234                                                      ;Following subroutine clears the FPACC to the zero
2235                                                      ;condition.
2236                    
2237 20-051 066 126     FPZERO:    LLI 126                ;Set L to point to MSW of FPACC
2238 20-053 250                    XRA                    ;Clear the accumulator
2239 20-054 370                    LMA                    ;Set the MSW of FPACC to zero
2240 20-055 061                    DCL                    ;Decrement the pointer
2241 20-056 370                    LMA                    ;Set the next significant word of FPACC to zero
2242 20-057 061                    DCL                    ;Decrement the pointer
2243 20-060 370                    LMA                    ;Set the LSW of FPACC to zero
2244 20-061 061                    DCL                    ;Decrement the pointer
2245 20-062 370                    LMA                    ;Set the auxiliary FPACC byte to zero
2246 20-063 007                    RET                    ;Exit to calling routine
2247                    
2248                                                      ;The next instruction is a special entry point to
2249                                                      ;the FPNORM subroutine that is used when a number is
2250                                                      ;converted from fixed to floating point. The FPNORM
2251                                                      ;label is the entry point when a number already in float-
2252                                                      ;ing point fonnat is to be normalized.
2253                    
2254 20-064 016 027     FPFLT:     LBI 027                ;For fixed to float set CPU register B to 23 decimal
2255 20-066 301         FPNORM:    LAB                    ;Get CPU register B into ACC to check for special case
2256 20-067 056 001                LHI \HB\OLDPG1         ;** Set H to page of FPACC
2257 20-071 066 127                LLI 127                ;Set L to FPACC Exponent byte
2258 20-073 240                    NDA                    ;Set CPU flags to test what was in CPU register B
2259 20-074 150 100 020            JTZ NOEXC0             ;If B was zero then do standard normalization
2260 20-077 371                    LMB                    ;Else set Exponent of FPACC to 23 decimal
2261 20-100 061         NOEXC0:    DCL                    ;Change pointer to MSW of FPACC
2262 20-101 307                    LAM                    ;Fetch MSW of FPACC into accumulator
2263 20-102 066 100                LLI 100                ;Change pointer to SIGN indicator storage location
2264 20-104 370                    LMA                    ;Place the MSW of FPACC there for future reference
2265 20-105 240                    NDA                    ;Set CPU flags to test MSW of FPACC
2266 20-106 120 120 020            JFS ACZERT             ;If sign bit not set then jump ahead to do next test
2267 20-111 016 004                LBI 004                ;If sign bit set, number in FPACC is negative. Set up
2268 20-113 066 123                LLI 123                ;For two's complement operation
2269 20-115 106 150 022            CAL COMPLM             ;And negate the value in the FPACC to make it positive
2270 20-120 066 126     ACZERT:    LLI 126                ;Reset pointer to MSW of FPACC
2271 20-122 016 004                LBI 004                ;Set precision counter to number of bytes in FPACC
2272 20-124 307         LOOK0:     LAM                    ;Plus one. Fetch a byte of the FPACC.
2273 20-125 240                    NDA                    ;Set CPU flags
2274 20-126 110 143 020            JFZ ACNONZ             ;If find anything then FPACC is not zero
2275 20-131 061                    DCL                    ;Else decrement pointer to NSW of FPACC
2276 20-132 011                    DCB                    ;Decrement precision counter
2277 20-133 110 124 020            JFZ LOOK0              ;Continue checking to see if FPACC contains anything
2278 20-136 066 127                LLI 127                ;Until precision counter is zero. If reach here then
2279 20-140 250                    XRA                    ;Reset pointer to FPACC Exponent. Clear the ACC and
2280 20-141 370                    LMA                    ;Clear out the FPACC Exponent. Value of FPACC is zip!
2281 20-142 007                    RET                    ;Exit to calling routine
2282 20-143 066 123     ACNONZ:    LLI 123                ;If FPACC has any value set pointer to LSW minus one
2283 20-145 016 004                LBI 004                ;Set precision counter to number of bytes in FPACC
2284 20-147 106 177 022            CAL ROTATL             ;Plus one for special cases. Rotate the contents of the
2285 20-152 307                    LAM                    ;FPACC to the LEFT. Pointer will be set to MSW after
2286 20-153 240                    NDA                    ;Rotate ops. Fetch MSW and see if have anything in
2287 20-154 160 166 020            JTS ACCSET             ;Most significant bit position. If so, have rotated enough
2288 20-157 060                    INL                    ;If not, advance pointer to FPACC Exponent. Fetch
2289 20-160 317                    LBM                    ;The value of the Exponent and decrement it by one
2290 20-161 011                    DCB                    ;To compensate for the rotate left of the mantissa
2291 20-162 371                    LMB                    ;Restore the new value of the Exponent
2292 20-163 104 143 020            JMP ACNONZ             ;Continue rotating ops to normalize the FPACC
2293 20-166 066 126     ACCSET:    LLI 126                ;Set pntr to FPACC MSW. Now must provide room for
2294 20-170 016 003                LBI 003                ;Sign bit in nonnalized FPACC. Set precision counter.
2295 20-172 106 211 022            CAL ROTATR             ;Rotate the FPACC once to the right now.
2296 20-175 066 100     RESIGN:    LLI 100                ;Set the pointer to SIGN indicator storage location
2297 20-177 307                    LAM                    ;Fetch the original sign of the FPACC
2298 20-200 240                    NDA                    ;Set CPU flags
2299 20-201 023                    RFS                    ;If original sign of FPACC was positive, can exit now.
2300                    
2301 20-202 066 124     FPCOMP:    LLI 124                ; However, if original sign was negative, must now restore
2302 20-204 016 003                LBI 003                ;The FPACC to negative by performing two's comple-
2303 20-206 104 150 022            JMP COMPLM             ;Ment on FPACC. Return to caring rtn via COMPLM.
2304                    
2305                                                      ;Floating point ADDITION. Adds contents of FPACC to
2306                                                      ;FPOP and leaves result in FPACC. Routine first checks
2307                                                      ;to see if either register contains zero. If so addition
2308                                                      ;result is already present!
2309                    
2310 20-211 066 126     FPADD:     LLI 126                ;Set L to point to MSW of FPACC
2311 20-213 056 001                LHI \HB\OLDPG1         ;** Do same for register H
2312 20-215 307                    LAM                    ;Fetch MSW of FPACC to accumulator
2313 20-216 240                    NDA                    ;Set CPU flags after loading op
2314 20-217 110 235 020            JFZ NONZAC             ;If accumulator non-zero then FPACC has some value
2315 20-222 066 124     MOVOP:     LLI 124                ;But, if accumulator was zero then normalized FPACC
2316 20-224 335                    LDH                    ;Must also be zero. Thus answer to addition is simply the
2317 20-225 346                    LEL                    ;Value in FPOP. Set up pointers to transfer contents of
2318 20-226 066 134                LLI 134                ;FPOP to FPACC by pointing to the LSW of both
2319 20-230 016 004                LBI 004                ;Registers and perform the transfer. Then exit to calling
2320 20-232 104 013 021            JMP MOVEIT             ;Routine with answer in FPACC via MOVEIT.
2321 20-235 066 136     NONZAC:    LLI 136                ;If FPACC was non-zero then check to see if FPOP has
2322 20-237 307                    LAM                    ;Some value by obtaining MSW of FPOP
2323 20-240 240                    NDA                    ;Set CPU flags after loading op. If MSW zero then
2324 20-241 053                    RTZ                    ;Normalized FPOP must be zero. Answer is in FPACC!
2325                    
2326                                                      ;If neither FPACC or FPOP was zero then must perform
2327                                                      ;addition operation. Must first check to see if two num-
2328                                                      ;bers are within significant mnge. If not, largest number
2329                                                      ;is answer. If numbers within range, then must align ex-
2330                                                      ;ponents before perforrning the addition of the man-
2331                                                      ;tissa.
2332                    
2333 20-242 066 127     CKEQEX:    LLI 127                ;Set pointer to FPACC Exponent storage location.
2334 20-244 307                    LAM                    ;Fetch the Exponent value to the accumulator.
2335 20-245 066 137                LLI 137                ;Change the pointer to the FPOP Exponent
2336 20-247 277                    CPM                    ;Compare the values of the exponents. If they are the
2337 20-250 150 341 020            JTZ SHACOP             ;Same then can immediately proceed to add operations.
2338 20-253 310                    LBA                    ;If not the same, store FPACC Exponent size in regis B
2339 20-254 307                    LAM                    ;Fetch the FPOP Exponent size into the ACC
2340 20-255 231                    SBB                    ;Subtract the FPACC Exponent from the FPOP Exp.
2341 20-256 120 264 020            JFS SKPNEG             ;If result is positive jump over the next few instructions
2342 20-261 310                    LBA                    ;If result was negative, store the result in B
2343 20-262 250                    XRA                    ;Clear the accumulator
2344 20-263 231                    SBB                    ;Subtract register B to negate the original value
2345 20-264 074 030     SKPNEG:    CPI 030                ;See if difference is less than 24 decimal.
2346 20-266 160 303 020            JTS LINEUP             ;If so, can align exponents. Go do it.
2347 20-271 307                    LAM                    ;If not, find out which number is largest. Fetch FPOP
2348 20-272 066 127                LLI 127                ;Exponent into ACC. Change pointer to FPACC Exp.
2349 20-274 227                    SUM                    ;Subtract FPACC from FPOP. If result is negative then
2350 20-275 063                    RTS                    ;was larger. Return with answer in FPACC.
2351 20-276 066 124                LLI 124                ;If result was positive, larger value in FPOP. Set pointers
2352 20-300 104 222 020            JMP MOVOP              ;To transfer FPOP into FPACC and then exit to caller.
2353 20-303 307         LINEUP:    LAM                    ;Fetch FPOP Exponent into accumulator.
2354 20-304 066 127                LLI 127                ;Change pointer to FPACC Exponent.
2355 20-306 227                    SUM                    ;Subtract FPACC Exponent from FPOP Exponent. If
2356 20-307 160 327 020            JTS SHIFT0             ;Result is negative FPACC is larger. Go shift FPOP.
2357 20-312 320                    LCA                    ;If result positive FPOP larger, must shift FPACC. Store
2358 20-313 066 127     MORACC:    LLI 127                ;Difference count in C. Reset pointer to FPACC Exp
2359 20-315 106 374 020            CAL SHLOOP             ;Call the SHift LOOP to rotate FPACC mantissa RIGHT
2360 20-320 021                    DCC                    ;And INCREMENT Exponent. Decr difference counter
2361 20-321 110 313 020            JFZ MORACC             ;Continue rotate operations until diff counter is zero
2362 20-324 104 341 020            JMP SHACOP             ;Go do final alignment and perform addition process
2363 20-327 320         SHIFT0:    LCA                    ;Routine to shift FPOP. Set difference count into reg. C
2364 20-330 066 137     MOROP:     LLI 137                ;Set pointer to FPOP Exponent.
2365 20-332 106 374 020            CAL SHLOOP             ;Call the SHift LOOP to rotate FPOP mantissa RIGHT
2366 20-335 020                    INC                    ;And INCREMENT Exponent. Then incr difference cntr
2367 20-336 110 330 020            JFZ MOROP              ;Continue rotate opemtions until diff counter is zero
2368                    ;;; The below two instructions are changed by PATCH NR.1
2369                    ;;;SHACOP:    LLI 123                ;Set pointer to FPACC LSW minus one to provide extra
2370                    ;;;           LMI 000                ;Byte for addition ops. Clear that location to zero.
2371 20-341 106 000 030 SHACOP:	   CAL PATCH1		; patch 1 inserts a few lines at 30-000
2372 20-344 300         	   LAA
2373                    	
2374                    ;;;           LLI 133
2375                    ;;;           LMI 000                ;THIS IS PATCH #1
2376 20-345 066 127                LLI 127                ;Change pointer to FPACC Exponent
2377 20-347 106 374 020            CAL SHLOOP             ;Rotate FPACC mantissa RIGHT & Increment Exponent
2378 20-352 066 137                LLI 137                ;Change pointer to FPOP Exponent
2379 20-354 106 374 020            CAL SHLOOP             ;Rotate FPOP mantissa RIGHT & Increment Exponent
2380 20-357 335                    LDH                    ;Rotate ops provide room for overflow. Now set up
2381 20-360 046 123                LEI 123                ;Pointers to LSW minus one for both FPACC & FPOP
2382 20-362 016 004                LBI 004                ;(FPOP already set after SHLOOP). Set precision counter
2383 20-364 106 127 022            CAL ADDER              ;Call quad precision ADDITION subroutine.
2384 20-367 016 000                LBI 000                ;Set CPU register B to indicate standard normalization
2385 20-371 104 066 020            JMP FPNORM             ;Go normalize the result and exit to caller.
2386 20-374 317         SHLOOP:    LBM                    ;Shifting loop. First fetch Exponent currently being
2387 20-375 010                    INB                    ;Pointed to and Increment the value by one.
2388 20-376 371                    LMB                    ;Return the updated Exponent value to memory.
2389 20-377 061                    DCL                    ;Decrement the pointer to mantissa portion MSW
2390 21-000 016 004                LBI 004                ;Set precision counter
2391 21-002 307         FSHIFT:    LAM                    ;Fetch MSW of mantissa
2392 21-003 240                    NDA                    ;Set CPU flags after load ops
2393 21-004 120 211 022            JFS ROTATR             ;If MSB not a one can do normal rotate ops
2394 21-007 022         BRING1:    RAL                    ;If MSB is a one need to set up carrv bit for the negative
2395 21-010 104 212 022            JMP ROTR               ;Number case. Then make special entry to ROTATR sub
2396                    
2397                                                      ;The following subroutine moves the contents of a string
2398                                                      ;of memory locations from the address pointed to by
2399                                                      ;CPU registers H & L to the address specified by the con-
2400                                                      ;tents of registers D & E when the routine is entered. The
2401                                                      ;process continues until the counter in register B is zero.
2402                    
2403 21-013 307         MOVEIT:    LAM                    ;Fetch a word from memory string A
2404 21-014 060                    INL                    ;Advance A string pointer
2405 21-015 106 356 022            CAL SWITCH             ;Switch pointer to string B
2406 21-020 370                    LMA                    ;Put word from string A into string B
2407 21-021 060                    INL                    ;Advance B string pointer
2408 21-022 106 356 022            CAL SWITCH             ;Switch pointer back to string A
2409 21-025 011                    DCB                    ;Decrement loop counter
2410 21-026 053                    RTZ                    ;Return to calling routine when counter reaches zero
2411 21-027 104 013 021            JMP MOVEIT             ;Else continue transfer operations
2412                    
2413                                                      ;The following subroutine SUBTRACTS the
2414                                                      ;contents of the FLOATING POINT ACCUMULATOR from the
2415                                                      ;contents of the FLOATING POINT OPERAND and
2416                                                      ;leaves the result in the FPACC. The routine merely
2417                                                      ;negates the value in the FPACC and then goes to the
2418                                                      ;FPADD subroutine just presented.
2419                    
2420 21-032 066 124     FPSUB:     LLI 124                ;Set L to address of LSW of FPACC
2421 21-034 056 001                LHI \HB\OLDPG1         ;** Set H to page of FPACC
2422 21-036 016 003                LBI 003                ;Set precision counter
2423 21-040 106 150 022            CAL COMPLM             ;Two's complement the value in the FPACC
2424 21-043 104 211 020            JMP FPADD              ;Now go add the negated value to perform subtraction!
2425                    
2426                                                      ;The first part of the FLOATING POINT MULTIPLI-
2427                                                      ;CATION subroutine calls a subroutine to check the
2428                                                      ;original signs of the numbers that are to be multi-
2429                                                      ;plied and perform working register clearing functions.
2430                                                      ;Next the exponents of the numbers to be multiplied
2431                                                      ;are added together.
2432                    
2433 21-046 106 166 021 FPMULT:    CAL CKSIGN             ;Call routine to set up registers & ck signs of numbers
2434 21-051 066 137     ADDEXP:    LLI 137                ;Set pointer to FPOP Exponent
2435 21-053 307                    LAM                    ;Fetch FPOP Exponent into the accumulator
2436 21-054 066 127                LLI 127                ;Change pointer to FPACC Exponent
2437 21-056 207                    ADM                    ;Add FPACC Exponent to FPOP Exponent
2438 21-057 004 001                ADI 001                ;Add one more to total for algorithm compensation
2439 21-061 370                    LMA                    ;Store result in FPACC Exponent location
2440 21-062 066 102     SETMCT:    LLI 102                ;Change pointer to bit counter storage location
2441 21-064 076 027                LMI 027                ;Initialize bit counter to 23 decimal
2442                    
2443                                                      ;Next portion of the FPMULT routine is the iinplernen-
2444                                                      ;tation of the algorithm illustrated in the flow chart
2445                                                      ;above. This portion multiplies the values of the two
2446                                                      ;mantissas. The final value is rounded off to leave the
2447                                                      ;23 most significant bits as the answer that is stored
2448                                                      ;back in the FPACC.
2449                    
2450 21-066 066 126     MULTIP:    LLI 126                ;Set pointer to MSW of FPACC mantissa
2451 21-070 016 003                LBI 003                ;Set precision counter
2452 21-072 106 211 022            CAL ROTATR             ;Rotate FPACC (multiplier) RIGHT into carry bit
2453 21-075 142 270 021            CTC ADOPPP             ;If carry is a one, add multiplicand to partial-product
2454 21-100 066 146                LLI 146                ;Set pointer to partial-product most significant byte
2455 21-102 016 006                LBI 006                ;Set precision counter (p-p register is double length)
2456 21-104 106 211 022            CAL ROTATR             ;Shift partial-product RIGHT
2457 21-107 066 102                LLI 102                ;Set pointer to bit counter storage location
2458 21-111 327                    LCM                    ;Fetch current value of bit counter
2459 21-112 021                    DCC                    ;Decrement the value of the bit counter
2460 21-113 372                    LMC                    ;Restore the updated bit counter to its storage location
2461 21-114 110 066 021            JFZ MULTIP             ;If have not multiplied for 23 (deciinal) bits, keep going
2462 21-117 066 146                LLI 146                ;If have done 23 (decimal) bits, set pntr to p-p MSW
2463 21-121 016 006                LBI 006                ;Set precision counter (for double length)
2464 21-123 106 211 022            CAL ROTATR             ;Shift partial-product once more to the RIGHT
2465 21-126 066 143                LLI 143                ;Set pointer to access 24'th bit in partial-product
2466 21-130 307                    LAM                    ;Fetch the byte containing the 24'th bit
2467 21-131 022                    RAL                    ;Position the 24'th bit to be MSB in the accumulator
2468 21-132 240                    NDA                    ;Set the CPU flags after to rotate operation and test to
2469 21-133 162 302 021            CTS MROUND             ;See if 24'th bit of p-p is a ONE. If so, must round-off
2470 21-136 066 123                LLI 123                ;Now set up pointers
2471 21-140 346                    LEL                    ;To perform transfer
2472 21-141 335                    LDH                    ;Of the multiplication results
2473 21-142 066 143                LLI 143                ;From the partial-product location
2474 21-144 016 004                LBI 004                ;To the FPACC
2475                    
2476                    	
2477 21-146 106 013 021 EXMLDV:    CAL MOVEIT             ;Perform the transfer from p-p to FPACC
2478 21-151 016 000                LBI 000                ;Set up CPU register B to indicate regular normalization
2479 21-153 106 066 020            CAL FPNORM             ;Normalize the result of multiplication
2480 21-156 066 101                LLI 101                ;Now set the pointer to the original SIGNS indicator
2481 21-160 307                    LAM                    ;Fetch the indicator
2482 21-161 240                    NDA                    ;Exercise the CPU flags
2483 21-162 013                    RFZ                    ;If indicator is non-zero, answer is positive, can exit her
2484 21-163 104 202 020            JMP FPCOMP             ;If not, answer must be negated, exit via 2's complement.
2485                    
2486                                                      ;The following portions of the FPMULT
2487                                                      ;routine set up working locations in memory by clearing
2488                                                      ;locations for an expanded FPOP area and the partial-produc
2489                                                      ;area. Next, the signs of the two numbers to be multiplied
2490                                                      ;are examined. Negative numbers are negated
2491                                                      ;in preparation for the multiplication
2492                                                      ;algorithm. A SIGNS indicator register is set up during
2493                                                      ;this process to indicate whether the final result of the
2494                                                      ;multiplication should be positive or negative. (Negative
2495                                                      ;if original signs of the two numbers to be multiplied are
2496                                                      ;different.)
2497                    
2498 21-166 066 140     CKSIGN:    LLI 140                ;Set pointer to start of partial-product working area
2499 21-170 056 001                LHI \HB\OLDPG1         ;** Set H to proper page
2500 21-172 016 010                LBI 010                ;Set up a loop counter in CPU register B
2501 21-174 250                    XRA                    ;Clear the accumulator
2502                    
2503 21-175 370         CLRNEX:    LMA                    ;Now clear out locations for the partial-product
2504 21-176 060                    INL                    ;Working registers
2505 21-177 011                    DCB                    ;Until the loop counter
2506 21-200 110 175 021            JFZ CLRNEX             ;Is zero
2507 21-203 016 004     CLROPL:    LBI 004                ;Set a loop counter
2508 21-205 066 130                LLI 130                ;Set up pointer
2509 21-207 370         CLRNX1:    LMA                    ;Clear out some extra registers so that the
2510 21-210 060                    INL                    ;FPOP may be extended in length
2511 21-211 011                    DCB                    ;Perform clearing ops until loop counter
2512 21-212 110 207 021            JFZ CLRNX1             ;Is zero
2513 21-215 066 101                LLI 101                ;Set pointer to M/D SIGNS indicator storage location
2514 21-217 076 001                LMI 001                ;Set initial value of SIGNS indicator to plus one
2515 21-221 066 126                LLI 126                ;Change pointer to MSW of FPACC
2516 21-223 307                    LAM                    ;Fetch MSW of mantissa into accumulator
2517 21-224 240                    NDA                    ;Test flags
2518 21-225 160 251 021            JTS NEGFPA             ;If MSB in MSW of FPACC is a one, number is negative
2519 21-230 066 136     OPSGNT:    LLI 136                ;Set pointer to MSW of FPOP
2520 21-232 307                    LAM                    ;Fetch MSW of mantissa into accumulator
2521 21-233 240                    NDA                    ;Test flags
2522 21-234 023                    RFS                    ;Return to caller if number in FPOP is positive
2523 21-235 066 101                LLI 101                ;Else change pointer to M/D SIGNS indicator
2524 21-237 327                    LCM                    ;Fetch the value in the SIGNS indicator
2525 21-240 021                    DCC                    ;Decrement the value by one
2526 21-241 372                    LMC                    ;Restore the new value back to storage location
2527 21-242 066 134                LLI 134                ;Set pointer to LSW of FPOP
2528 21-244 016 003                LBI 003                ;Set precision counter
2529 21-246 104 150 022            JMP COMPLM             ;Two's complement value of FPOP & return to caller
2530 21-251 066 101     NEGFPA:    LLI 101                ;Set pointer to M/D SIGNS indicator
2531 21-253 327                    LCM                    ;Fetch the value in the SIGNS indicator
2532 21-254 021                    DCC                    ;Decrement the value by one
2533 21-255 372                    LMC                    ;Restore the new value back to storage location
2534 21-256 066 124                LLI 124                ;Set pointer to LSW of FPACC
2535 21-260 016 003                LBI 003                ;Set precision counter
2536 21-262 106 150 022            CAL COMPLM             ;Two's complement value of FPACC
2537 21-265 104 230 021            JMP OPSGNT             ;Proceed to check sign of FPOP
2538                    
2539                                                      ;The following subroutine adds the double length (six regis
2540                                                      ;multiplicand in FPOP to the partial-product register when
2541                                                      ;called on by the multiplication algorithm.
2542                    
2543 21-270 046 141     ADOPPP:    LEI 141                ;Pointer to LSW of partial-product
2544 21-272 335                    LDH                    ;On same page as FPOP
2545 21-273 066 131                LLI 131                ;LSIV of FPOP which contains extended multiplicand
2546 21-275 016 006                LBI 006                ;Set precision counter (double length working registers)
2547 21-277 104 127 022            JMP ADDER              ;Add multiplicand to partial-product & return to caller
2548                    
2549 21-302 016 003     MROUND:    LBI 003                ;Set up precision counter
2550 21-304 006 100                LAI 100                ;Prepare to add one to 24'th bit of partial-product
2551 21-306 207                    ADM                    ;Add one to the 24'th bit of the partial-product
2552 21-307 370         CROUND:    LMA                    ;Restore the updated byte to memory
2553 21-310 060                    INL                    ;Advance the memory pointer to next most significant
2554 21-311 006 000                LAI 000                ;Byte of partial-product, then clear ACC without
2555 21-313 217                    ACM                    ;Disturbing carry bit. Now perform add with carry to
2556 21-314 011                    DCB                    ;Propagate any rounding in the partial-product registers.
2557 21-315 110 307 021            JFZ CROUND             ;If cotinter is not zero continue propagating any carry
2558 21-320 370                    LMA                    ;Restore final byte to memory
2559 21-321 007                    RET                    ;Exit to calling routine
2560                    
2561 21-322 106 166 021 FPDIV:     CAL CKSIGN             ;Call routine to set up registers & ck signs of numbers
2562 21-325 066 126                LLI 126                ;Set pointer to MSW of FPACC (divisor)
2563 21-327 307                    LAM                    ;Fetch MSW of FPACC to accumulator
2564 21-330 240                    NDA                    ;Exercise CPU flags
2565 21-331 150 357 012            JTZ DVERR              ;If MSW of FPACC is zero go display 'DZ' error message
2566 21-334 066 137     SUBEXP:    LLI 137                ;Set pointer to FPOP (dividend) Exponent
2567 21-336 307                    LAM                    ;Get FPOP Exponent into accumulator
2568 21-337 066 127                LLI 127                ;Change pointer to FPACC (divisor) Exponent
2569 21-341 227                    SUM                    ;Subtract divisor exponent from dividend exponent
2570 21-342 004 001                ADI 001                ;Add one for algorithm compensation
2571 21-344 370                    LMA                    ;Place result in FPACC Exponent
2572 21-345 066 102     SETDCT:    LLI 102                ;Set pointer to bit counter storage location
2573 21-347 076 027                LMI 027                ;Initialize bit counter to 23 decimal
2574                    
2575                                                      ;Main division algorithm for mantissas
2576                    
2577 21-351 106 101 022 DIVIDE:    CAL SETSUB             ;Go subtmct divisor from dividend
2578 21-354 160 376 021            JTS NOGO               ;If result is negative then place a zero bit in quotient
2579 21-357 046 134                LEI 134                ;If result zero or positive then move remainder after
2580 21-361 066 131                LLI 131                ;Subtraction from working area to become new dividend
2581 21-363 016 003                LBI 003                ;Set up moving pointers and initialize precision counter
2582 21-365 106 013 021            CAL MOVEIT             ;Perform the transfer
2583 21-370 006 001                LAI 001                ;Place a one into least significant bit of accumulator
2584 21-372 032                    RAR                    ;And rotate it out into the carry bit
2585 21-373 104 377 021            JMP QUOROT             ;Proceed to rotate the carry bit into the current quotient
2586 21-376 250         NOGO:      XRA                    ;When result is negative, put a zero in the carry bit, then
2587 21-377 066 144     QUOROT:    LLI 144                ;Set up pointer to LSW of quotient register
2588 22-001 016 003                LBI 003                ;Set precision counter
2589 22-003 106 200 022            CAL ROTL               ;Rotate carry bit into quotient by using special entry to
2590 22-006 066 134                LLI 134                ;ROTATL subroutine. Now set up pointer to dividend
2591 22-010 016 003                LBI 003                ;LSW and set precision counter
2592 22-012 106 177 022            CAL ROTATL             ;Rotate the current dividend to the left
2593 22-015 066 102                LLI 102                ;Set pointer to bit counter storage location
2594 22-017 327                    LCM                    ;Fetch the value of the bit counter
2595 22-020 021                    DCC                    ;Decrement the value by one
2596 22-021 372                    LMC                    ;Restore the new counter value to storage
2597 22-022 110 351 021            JFZ DIVIDE             ;If bit counter is not zero, continue division process
2598 22-025 106 101 022            CAL SETSUB             ;After 23 (decimal) bits, do subtraction once more for
2599 22-030 160 070 022            JTS DVEXIT             ;Possible rounding. Jump ahead if no rounding required.
2600 22-033 066 144                LLI 144                ;If rounding required set pointer to LSW of quotient
2601 22-035 307                    LAM                    ;Fetch LSW of quotient to accumulator
2602 22-036 004 001                ADI 001                ;Add one to 23rd bit of quotient
2603 22-040 370                    LMA                    ;Restore updated LSW of quotient
2604 22-041 006 000                LAI 000                ;Clear accumulator without disturbing carry bit
2605 22-043 060                    INL                    ;Advance pointer to next significant byte of quotient
2606 22-044 217                    ACM                    ;Propagate any carry as part of rounding process
2607 22-045 370                    LMA                    ;Restore the updated byte of quotient
2608 22-046 006 000                LAI 000                ;Clear ACC again without disturbing carry bit
2609 22-050 060                    INL                    ;Advance pointer to MSW of quotient
2610 22-051 217                    ACM                    ;Propagate any carry to finish rounding process
2611 22-052 370                    LMA                    ;Restore the updated byte of quotient
2612 22-053 120 070 022            JFS DVEXIT             ;If most significant bit of quotient is zero, go finish up
2613 22-056 016 003                LBI 003                ;If not, set precision counter
2614 22-060 106 211 022            CAL ROTATR             ;And rotate quotient to the right to clear the sign bit
2615 22-063 066 127                LLI 127                ;Set pointer to FPACC Exponent
2616 22-065 317                    LBM                    ;Fetch FPACC exponent
2617 22-066 010                    INB                    ;Increment the value to compensate for the rotate right
2618 22-067 371                    LMB                    ;Restore the updated exponent value
2619 22-070 066 143     DVEXIT:    LLI 143                ;Set up pointers
2620 22-072 046 123                LEI 123                ;To transfer the quotient into the FPACC
2621 22-074 016 004                LBI 004                ;Set precision counter
2622                                                      ;THIS IS A CORRECTION FOUND IN THE NOTES
2623 22-076 104 146 021            JMP EXMLDV             ;And exit through FPMULT routine at EXMLDV
2624                    
2625                                                      ;Subroutine to subtract divisor from dividend. Used by
2626                                                      ;main DIVIDE subroutine.
2627                    
2628 22-101 046 131     SETSUB:    LEI 131                ;Set pointer to LSW of working area
2629 22-103 335                    LDH                    ;On same page as FPACC
2630 22-104 066 124                LLI 124                ;Set pointer to LSW of FPACC (divisor)
2631 22-106 016 003                LBI 003                ;Set precision counter
2632 22-110 106 013 021            CAL MOVEIT             ;Perform transfer
2633 22-113 046 131                LEI 131                ;Reset pointer to LSW of working area (now divisor)
2634 22-115 066 134                LLI 134                ;Reset pointer to LSW of FPOP (dividend)
2635 22-117 016 003                LBI 003                ;Set precision counter
2636 22-121 106 223 022            CAL SUBBER             ;Subtract divisor from dividend
2637 22-124 307                    LAM                    ;Get MSW of the result of the subtraction operations
2638 22-125 240                    NDA                    ;Exercise CPU flags
2639 22-126 007                    RET                    ;Return to caller with status
2640 22-127 240         ADDER:     NDA                    ;Initialize the carry bit to zero upon entry
2641 22-130 307         ADDMOR:    LAM                    ;Fetch byte from register group A
2642 22-131 106 356 022            CAL SWITCH             ;Switch memory pointer to register group B
2643 22-134 217                    ACM                    ;Add byte from A to byte from B with carry
2644 22-135 370                    LMA                    ;Leave result in register group B
2645 22-136 011                    DCB                    ;Decrement number of bytes (precision) counter
2646 22-137 053                    RTZ                    ;Return to caller when all bytes in group processed
2647 22-140 060                    INL                    ;Else advance pointer for register group B
2648 22-141 106 356 022            CAL SWITCH             ;Switch memory pointer back to register group A
2649 22-144 060                    INL                    ;Advance the pointer for register group A
2650 22-145 104 130 022            JMP ADDMOR             ;Continue the multi-byte addition operation
2651                    
2652                                                      ;N'th precision two's complement (negate)
2653                                                      ;subroutine. Performs a two's complement on the multi-byte
2654                                                      ;registers tarting at the address pointed
2655                                                      ; to by H & L (least significant byte) upon entry.
2656                    
2657 22-150 307         COMPLM:    LAM                    ;Fetch the least significant byte of the number to ACC
2658 22-151 054 377                XRI 377                ;Exclusive OR to complement the byte
2659 22-153 004 001                ADI 001                ;Add one to form two's complement of byte
2660 22-155 370         MORCOM:    LMA                    ;Restore the negated byte to memory
2661 22-156 032                    RAR                    ;Save the carry bit
2662 22-157 330                    LDA                    ;In CPU register D
2663 22-160 011                    DCB                    ;Decrement number of bytes (precision) counter
2664 22-161 053                    RTZ                    ;Return to caller when all bytes in number processed
2665 22-162 060                    INL                    ;Else advance the pointer
2666 22-163 307                    LAM                    ;Fetch the next byte of the number to ACC
2667 22-164 054 377                XRI 377                ;Exclusive OR to complement the byte
2668 22-166 340                    LEA                    ;Save complemented value in register E temporarily
2669 22-167 303                    LAD                    ;Restore previous carry status to ACC
2670 22-170 022                    RAL                    ;And rotate it out to the carry bit
2671 22-171 006 000                LAI 000                ;Clear ACC without disturbing carry status
2672 22-173 214                    ACE                    ;Add in any carry to complemented value
2673 22-174 104 155 022            JMP MORCOM             ;Continue the two's complement procedure as req'd
2674                    
2675                                                      ;N'th precision rotate left subroutine. Rotates a multi-
2676                                                      ;byte number left starting at the address initially
2677                                                      ;specified by the contents of CPU registers H & L upon
2678                                                      ;subroutine entry (LSW). First entry point will clear
2679                                                      ;the carry bit before beginning rotate operations. Second
2680                                                      ;entry point does not clear the carry bit.
2681                    
2682 22-177 240         ROTATL:    NDA                    ;Clear the carry bit at this entry point
2683 22-200 307         ROTL:      LAM                    ;Fetch a byte from memory
2684 22-201 022                    RAL                    ;Rotate it left (bring carry into LSB, push MSB to carry)
2685 22-202 370                    LMA                    ;Restore rotated word to memory
2686 22-203 011                    DCB                    ;Decrement precision counter
2687 22-204 053                    RTZ                    ;Exit to caller when finished
2688 22-205 060                    INL                    ;Else advance pointer to next byte
2689 22-206 104 200 022            JMP ROTL               ;Continue rotate left operations
2690                    
2691                    
2692                                                      ;N'th precision rotate
2693                                                      ;right subroutine. Opposite of
2694                                                      ;above subroutine.
2695                    
2696 22-211 240         ROTATR:    NDA                    ;Clear the carry bit at this entry point
2697 22-212 307         ROTR:      LAM                    ;Fetch a byte from memory
2698 22-213 032                    RAR                    ;Rotate it right (carry into MSB, LSB to carry)
2699 22-214 370                    LMA                    ;Restore rotated word to memory
2700 22-215 011                    DCB                    ;Decrement precision counter
2701 22-216 053                    RTZ                    ;Exit to caller when finished
2702 22-217 061                    DCL                    ;Else decrement pointer to next byte
2703 22-220 104 212 022            JMP ROTR               ;Continue rotate right operations
2704                    
2705                                                      ;N'th precision subtraction subroutine.
2706                                                      ;Number starting at location pointed to by D & E (least
2707                                                      ;significant byte) is subtracted from number starting at
2708                                                      ;address specified by contents of H & L.
2709                    
2710 22-223 240         SUBBER:    NDA                    ;Initialize the carry bit to zero upon entry
2711 22-224 307         SUBTRA:    LAM                    ;Fetch byte from register group A
2712 22-225 106 356 022            CAL SWITCH             ;Switch memory pointer to register group B
2713 22-230 237                    SBM                    ;Subtract byte from group B ftom that in group A
2714 22-231 370                    LMA                    ;Leave result in register group B
2715 22-232 011                    DCB                    ;Decrement number of bytes (precision) counter
2716 22-233 053                    RTZ                    ;Return to caller when all bytes in group processed
2717 22-234 060                    INL                    ;Else advance pointer for register group B
2718 22-235 106 356 022            CAL SWITCH             ;Switch memory pointer back to register group A
2719 22-240 060                    INL                    ;Advance the pointer for register group A
2720 22-241 104 224 022            JMP SUBTRA             ;Continue the multi-byte subtraction operation
2721                    
2722                                                      ;The next subroutine will transfer the four byte
2723                                                      ;register string (generally a number in floating point
2724                                                      ;format) from the starting address pointed to by CPU
2725                                                      ;registers H & L when the subroutine is entered to
2726                                                      ;the FPACC (floating point accumulator registers).
2727                    
2728 22-244 036 001     FLOAD:     LDI \HB\OLDPG1         ;** Set page address of FPACC
2729 22-246 046 124                LEI 124                ;Set address of least signficant byte of FPACC
2730 22-250 016 004                LBI 004                ;Set precision counter to four bytes (mantissa bytes
2731 22-252 104 013 021            JMP MOVEIT             ;Plus Exponent) and exit via the transfer routine
2732                    
2733                                                      ;The next several subroutines are used to perform
2734                                                      ;floating pojnt register loading and transfer operations.
2735                    
2736 22-255 346         FSTORE:    LEL                    ;Transfer contents of register L to E
2737 22-256 335                    LDH                    ;Transfer contents of register H to D
2738 22-257 066 124                LLI 124                ;Set L to least significant byte of FPACC mantissa
2739 22-261 056 001                LHI \HB\OLDPG1         ;** Set page to FPACC storage area
2740 22-263 104 272 022            JMP SETIT              ;Go transfer FPACC contents to area pointed to by D&E
2741 22-266 036 001     OPLOAD:    LDI \HB\OLDPG1         ;** Set page to FPOP storage area
2742 22-270 046 134                LEI 134                ;Set pointer to least significant byte of FPOP
2743 22-272 016 004     SETIT:     LBI 004                ;Set precision counter. Transfer from H & L area to
2744 22-274 104 013 021            JMP MOVEIT             ;Locations pointed to by D & E
2745                    
2746                                                      ;The next subroutine perforins a double transfer opera-
2747                                                      ;tion. It first transfers the contents of the FPACC into
2748                                                      ;the FPOP. It then transfers new data (as pointed to by
2749                                                      ;H & L upon entry to the subroutine) into the FPACC.
2750                    
2751 22-277 106 317 022 FACXOP:    CAL SAVEHL             ;Save contents of H & L upon entry to subroutine
2752 22-302 066 124                LLI 124                ;Set pointer to FPACC LSW
2753 22-304 056 001                LHI \HB\OLDPG1         ;** Set pointer to page of FPACC
2754 22-306 106 266 022            CAL OPLOAD             ;Transfer FPACC to FPOP
2755 22-311 106 337 022            CAL RESTHL             ;Recover original subroutine entry values for H & L
2756 22-314 104 244 022            JMP FLOAD              ;Transfer registers pointed to by H & L into the FPACC
2757                    
2758                                                      ;Subroutine to save the contents of CPU registers D, E, H
2759                                                      ;and L in a temporary storage area in memory.
2760                    
2761 22-317 305         SAVEHL:    LAH                    ;Transfer value in H to ACC
2762 22-320 316                    LBL                    ;And value in L to B
2763 22-321 066 200                LLI 200                ;Now set L to start of tempomry storage locations
2764 22-323 056 001                LHI \HB\OLDPG1         ;** And set H to storage area page
2765 22-325 370                    LMA                    ;Save A (entry value of H) in memory
2766 22-326 060                    INL                    ;Advance pointer
2767 22-327 371                    LMB                    ;Save B (entry value of L) in memory
2768 22-330 060                    INL                    ;Advance pointer
2769 22-331 373                    LMD                    ;Save D in memory
2770 22-332 060                    INL                    ;Advance pointer
2771 22-333 374                    LME                    ;Save E in memory
2772 22-334 350                    LHA                    ;Restore entry value of H
2773 22-335 361                    LLB                    ;Restore entry value of L
2774 22-336 007                    RET                    ;Exit to calling routine
2775                    
2776                                                      ;Subroutine to restore the contents of CPU registers D,
2777                                                      ;E, H and L from temporary storage in memory.
2778                    
2779 22-337 066 200     RESTHL:    LLI 200                ;Set L to start of temporary storage locations
2780 22-341 056 001                LHI \HB\OLDPG1         ;** Set H to storage area page
2781 22-343 307                    LAM                    ;Fetch stored value for li iii ACC
2782 22-344 060                    INL                    ;Advance pointer
2783 22-345 317                    LBM                    ;Fetch stored value for L into B
2784 22-346 060                    INL                    ;Advance pointer
2785 22-347 337                    LDM                    ;Fetch stored value for T.)
2786 22-350 060                    INL                    ;Advance pointer
2787 22-351 347                    LEM                    ;Fetch stored value for
2788 22-352 350                    LHA                    ;Restore  saved value for H
2789 22-353 361                    LLB                    ;Restore saved value for L
2790 22-354 307                    LAM                    ;Leave stored value for E in ACC
2791 22-355 007                    RET                    ;Exit to calling routine
2792                    
2793                                                      ;Subroutine to exchange the contents of H & L with
2794                                                      ;D & E.
2795                    
2796 22-356 325         SWITCH:    LCH                    ;Transfer register H to C temporarily
2797 22-357 353                    LHD                    ;Place value of D into H
2798 22-360 332                    LDC                    ;Now put former H from C into D
2799 22-361 326                    LCL                    ;Transfer register L to C temporarily
2800 22-362 364                    LLE                    ;Place value of E into L
2801 22-363 342                    LEC                    ;Now put former L from C into E
2802 22-364 007                    RET                    ;Exit to calling routine
2803 22-365 056 001     GETINP:    LHI \HB\OLDPG1         ;** Set H to page of GETINP character counter
2804 22-367 066 220                LLI 220                ;Set L to address of GETINP character counter
2805 22-371 327                    LCM                    ;Load counter value into CPU register C
2806 22-372 020                    INC                    ;Exercise the counter in order
2807 22-373 021                    DCC                    ;To set CPU flags. If counter is non-zero, then indexing
2808 22-374 110 010 023            JFZ NOT0               ;Register (GETINP counter) is all set so jump ahead.
2809 22-377 364                    LLE                    ;But, if counter zero, then starting to process a new
2810 23-000 353                    LHD                    ;Character string. Transfer char string buffer pointer into
2811 23-001 327                    LCM                    ;H & L and fetch the string's character count value (cc)
2812 23-002 020                    INC                    ;Increment the (cc) by one to take account of (cc) byte
2813 23-003 106 036 023            CAL INDEXC             ;Add contents of regis C to H & L to point to end of the
2814 23-006 076 000                LMI 000                ;Character string in buffer and place a zero byte marker
2815 23-010 066 220     NOT0:      LLI 220                ;Set L back to address of GETINP counter which is used
2816 23-012 056 001                LHI \HB\OLDPG1         ;** As an indexing value. Set H to correct page.
2817 23-014 327                    LCM                    ;Fetch the value of GETINP counter into register C
2818 23-015 020                    INC                    ;Increment the value in C
2819 23-016 372                    LMC                    ;Restore the updated value for future use
2820 23-017 364                    LLE                    ;Bring the base address of the character string buffer into
2821 23-020 353                    LHD                    ;CPU registers H & L
2822 23-021 106 036 023            CAL INDEXC             ;Add contents of register C to form indexed address of
2823 23-024 307                    LAM                    ;Next character to be fetched as input. Fetch the next
2824 23-025 240                    NDA                    ;Character. Exercise the CPU flags.
2825 23-026 056 001                LHI \HB\OLDPG1         ;** Restore page pointer to floating point working area
2826 23-030 013                    RFZ                    ;If character is non-zero, not end of string, exit to calle
2827 23-031 066 220                LLI 220                ;If zero character, must reset GETINP counter for next
2828 23-033 076 000                LMI 000                ;String. Reset pointer and clear GETINP counter to zero
2829 23-035 007                    RET                    ;Then exit to calling routine
2830                    
2831                                                      ;Following subroutine causes register C to be used as an
2832                                                      ;indexing register. Value in C is added to address in H
2833                                                      ;and L to form new address.
2834                    
2835 23-036 306         INDEXC:    LAL                    ;Place value from register L into accumulator
2836 23-037 202                    ADC                    ;Add quantity in register C
2837 23-040 360                    LLA                    ;Restore updated value back to L
2838 23-041 003                    RFC                    ;Exit to caller if no carry from addition
2839 23-042 050                    INH                    ;But, if have carry then must increment register H
2840 23-043 007                    RET                    ;Before returning to calling routine
2841                    
2842                                                      ;Main Decimal INPUT subroutine to convert strings of
2843                                                      ;ASCII characters representing decimal fixed or floating
2844                                                      ;point numbers to binary floating point numbers.
2845                    
2846 23-044 346         DINPUT:    LEL                    ;Save entry value of register L in E. (Pointer to buffer
2847 23-045 335                    LDH                    ;Containing ASCII character string.) Do same for H to D.
2848 23-046 056 001                LHI \HB\OLDPG1         ;** Set H to page of floating point working registers
2849 23-050 066 150                LLI 150                ;Set L to start of decirnal-to-binary working area
2850 23-052 250                    XRA                    ;Clear the accumulator
2851 23-053 016 010                LBI 010                ;Set up a loop counter
2852 23-055 370         CLRNX2:    LMA                    ;Deposit zero in working area to initialize
2853 23-056 060                    INL                    ;Advance the memory pointer
2854 23-057 011                    DCB                    ;Decrement the loop counter
2855 23-060 110 055 023            JFZ CLRNX2             ;Clear working area until loop counter is zero
2856 23-063 066 103                LLI 103                ;Set pointer to floating point temporary registers and
2857 23-065 016 004                LBI 004                ;Indicators working area. Set up a loop counter.
2858 23-067 370         CLRNX3:    LMA                    ;Deposit zero in working area to initialize
2859 23-070 060                    INL                    ;Advance the memory pointer
2860 23-071 011                    DCB                    ;Decrement the loop counter
2861 23-072 110 067 023            JFZ CLRNX3             ;Clear working area until loop counter is zero
2862 23-075 106 365 022            CAL GETINP             ;Fetch a character from the ASCII chax string buffer
2863 23-100 074 253                CPI 253                ;(Typically the SYMBOL/TOKEN buffer). See if it is
2864 23-102 150 115 023            JTZ NINPUT             ;Code for + sign. Jump ahead if code for + sign.
2865 23-105 074 255                CPI 255                ;See if code for minus (-) sign.
2866 23-107 110 120 023            JFZ NOTPLM             ;Jump ahead if not code for minus sign. If code for
2867 23-112 066 103                LLI 103                ;Minus sign, set pointer to MINUS flag storage location.
2868 23-114 370                    LMA                    ;Set the MINUS flag to indicate a minus number
2869 23-115 106 365 022 NINPUT:    CAL GETINP             ;Fetch another character from the ASCII char string
2870 23-120 074 256     NOTPLM:    CPI 256                ;See if character represents a period (decimal point) in
2871 23-122 150 201 023            JTZ PERIOD             ;Input string. Jump ahead if yes.
2872 23-125 074 305                CPI 305                ;If not period, see if code for E as in Exponent
2873 23-127 150 221 023            JTZ FNDEXP             ;Jump ahead if yes.
2874 23-132 074 240                CPI 240                ;Else see if code for space.
2875 23-134 150 115 023            JTZ NINPUT             ;Ignore space character, go fetch another character.
2876 23-137 240                    NDA                    ;If none of the above see if zero byte
2877 23-140 150 311 023            JTZ ENDINP             ;Indicating end of input char string. If yes, jumn ahead.
2878 23-143 074 260                CPI 260                ;If not end of string, check to see
2879 23-145 160 375 012            JTS NUMERR             ;If character represents
2880 23-150 074 272                CPI 272                ;A valid decimal number (0 to 9)
2881 23-152 120 375 012            JFS NUMERR             ;Display error message if not a valid digit at this point!
2882 23-155 066 156                LLI 156                ;For valid digit, set pointer to MSW of temporary
2883 23-157 320                    LCA                    ;Decimal to binary holding registers. Save character in C.
2884 23-160 006 370                LAI 370                ;Form mask for sizing in accumulator. Now see if
2885 23-162 247                    NDM                    ;Holding register has enough room for the conversion of
2886 23-163 110 115 023            JFZ NINPUT             ;Another digit. Ignore the input if no more room.
2887 23-166 066 105                LLI 105                ;If have room in register then set pointer to input digit
2888 23-170 317                    LBM                    ;Counter location. Fetch the present value.
2889 23-171 010                    INB                    ;Increment it to account for incoming digit.
2890 23-172 371                    LMB                    ;Restore updated count to storage location.
2891 23-173 106 056 024            CAL DECBIN             ;Call the DECimal to BINary conversion routine to add
2892 23-176 104 115 023            JMP NINPUT             ;In the new digit in holding registers. Continue inputting.
2893 23-201 310         PERIOD:    LBA                    ;Save character code in register B
2894 23-202 066 106                LLI 106                ;Set pointer to PERIOD indicator storage location
2895 23-204 307                    LAM                    ;Fetch value in PERIOD indicator
2896 23-205 240                    NDA                    ;Exercise CPU flags
2897 23-206 110 375 012            JFZ NUMERR             ;If already have a period then display error message
2898 23-211 066 105                LLI 105                ;If not, change pointer to digit counter storage location
2899 23-213 370                    LMA                    ;Clear the digit counter back to zero
2900 23-214 060                    INL                    ;Advance pointer to PERIOD indicator
2901 23-215 371                    LMB                    ;Set the PERIOD indicator
2902 23-216 104 115 023            JMP NINPUT             ;Continue processing the input character string
2903 23-221 106 365 022 FNDEXP:    CAL GETINP             ;Get next character in Exponent
2904 23-224 074 253                CPI 253                ;See if it is code for + sign
2905 23-226 150 241 023            JTZ EXPINP             ;Jump ahead if yes.
2906 23-231 074 255                CPI 255                ;If not + sign, see if minus sign
2907 23-233 110 244 023            JFZ NOEXPS             ;If not minus sign then jump ahead
2908 23-236 066 104                LLI 104                ;For minus sign, set pointer to EXP SIGN indicator
2909 23-240 370                    LMA                    ;Set the EXP SIGN indicator for a minus exponent
2910 23-241 106 365 022 EXPINP:    CAL GETINP             ;Fetch the next character in the decimal exponent
2911 23-244 240         NOEXPS:    NDA                    ;Exercise the CPU flags
2912 23-245 150 311 023            JTZ ENDINP             ;If character inputted was zero, then end of input string
2913 23-250 074 260                CPI 260                ;If not end of string, check to see
2914 23-252 160 375 012            JTS NUMERR             ;If character represents
2915 23-255 074 272                CPI 272                ;A valid decimal number (0 to 9)
2916 23-257 120 375 012            JFS NUMERR             ;Display error message if not a valid digit at this point!
2917 23-262 044 017                NDI 017                ;Else trim the ASCII code to BCD
2918 23-264 310                    LBA                    ;And save in register B
2919 23-265 066 157                LLI 157                ;Set pointer to input exponent storage location
2920 23-267 006 003                LAI 003                ;Set accumulator equal to three
2921 23-271 277                    CPM                    ;See if any previous digit in exponent greater than three
2922 23-272 160 375 012            JTS NUMERR             ;Display error message if yes
2923 23-275 327                    LCM                    ;Else save any previous value in register C
2924 23-276 307                    LAM                    ;And also place any previous value in accumulator
2925 23-277 240                    NDA                    ;Clear the carry bit with this instruction
2926 23-300 022                    RAL                    ;Single precision multiply by ten algorithm
2927 23-301 022                    RAL                    ;Two rotate lefts equals times four
2928 23-302 202                    ADC                    ;Adding in the digit makes total times five
2929 23-303 022                    RAL                    ;Rotating left again equals times ten
2930 23-304 201                    ADB                    ;now add in digit just inputted
2931 23-305 370                    LMA                    ;Restore the value to exponent storage location
2932 23-306 104 241 023            JMP EXPINP             ;Go get any additional exponent int)ut
2933 23-311 066 103     ENDINP:    LLI 103                ;Set pointer to mantissa SIGN indicator
2934 23-313 307                    LAM                    ;Fetch the SIGN indicator to the acclimulator
2935 23-314 240                    NDA                    ;Exercise the CPU flags
2936 23-315 150 327 023            JTZ FININP             ;If SIGN indicator is zero, go finish up as nr is positive
2937 23-320 066 154                LLI 154                ;But, if indicator is non-zero, number is negative
2938 23-322 016 003                LBI 003                ;Set pntr to LSW of storage registers, set precision entr
2939 23-324 106 150 022            CAL COMPLM             ;Negate the triple-precision number in holding registers
2940 23-327 066 153     FININP:    LLI 153                ;Set pointer to input storage LS~V minus one
2941 23-331 250                    XRA                    ;Clear the accumulator
2942 23-332 370                    LMA                    ;Clear the LSW minus one location
2943 23-333 335                    LDH                    ;Set register D to floating point working page
2944 23-334 046 123                LEI 123                ;Set E to address of FPACC LSW minus one
2945 23-336 016 004                LBI 004                ;Set precision counter
2946 23-340 106 013 021            CAL MOVEIT             ;Move number from input register to FPACC
2947 23-343 106 064 020            CAL FPFLT              ;Now convert the binary fixed point to floating point
2948 23-346 066 104                LLI 104                ;Set pointer to Exponent SIGN indicator location
2949 23-350 307                    LAM                    ;Fetch the value of the EXP SIGN indicator
2950 23-351 240                    NDA                    ;Exercise the CPU flags
2951 23-352 066 157                LLI 157                ;Reset pointer to input exponent storage location
2952 23-354 150 365 023            JTZ POSEXP             ;If EXP SIGN indicator zero, exponent is positive
2953 23-357 307                    LAM                    ;Else, exponent is negative so must negate
2954 23-360 054 377                XRI 377                ;The value in the input exponent storage location
2955 23-362 004 001                ADI 001                ;By performing this two's complement
2956 23-364 370                    LMA                    ;Restore the negated value to exponent storage location
2957 23-365 066 106     POSEXP:    LLI 106                ;Set pointer to PERIOD indicator storage location
2958 23-367 307                    LAM                    ;Fetch the contents of the PERIOD indicator
2959 23-370 240                    NDA                    ;Exercise the CPU flags
2960 23-371 150 000 024            JTZ EXPOK              ;If PERIOD indicator clear, no decimal point involved
2961 23-374 066 105                LLI 105                ;If have a decimal point, set pointer to digit counter
2962 23-376 250                    XRA                    ;Storage location. Clear the accumulator.
2963 23-377 227                    SUM                    ;And get a negated value of the digit counter in ACC
2964 24-000 066 157     EXPOK:     LLI 157                ;Change pointer to input exponent storage location
2965 24-002 207                    ADM                    ;Add this value to negated digit counter value
2966 24-003 370                    LMA                    ;Restore new value to storage location
2967 24-004 160 033 024            JTS MINEXP             ;If new value is minus, skip over next subroutine
2968 24-007 053                    RTZ                    ;If new value is zero, no further processing required
2969                    
2970                                                      ;Following subroutine will multiply the floating point
2971                                                      ;binary number stored in FPACC by ten tirnes the
2972                                                      ;value stored in the deciinal exponent storage location.
2973                    
2974 24-010 066 210     FPX10:     LLI 210                ;Set pointer to registers containing floating point
2975 24-012 056 001                LHI \HB\OLDPG1         ;** Binary representation of 10 (decimal).
2976 24-014 106 277 022            CAL FACXOP             ;Transfer FPACC to FPOP and 10 (dec) to FPACC
2977 24-017 106 046 021            CAL FPMULT             ;Multiply FPOP (formerly FPACC) by 10 (decimal)
2978 24-022 066 157                LLI 157                ;Set pointer to decimal exponent storage location
2979 24-024 327                    LCM                    ;Fetch the exponent value
2980 24-025 021                    DCC                    ;Decrement
2981 24-026 372                    LMC                    ;Restore to storage
2982 24-027 110 010 024            JFZ FPX10              ;If exponent value is not zero, continue multiplication
2983 24-032 007                    RET                    ;When exponent is zero can exit. Conversion completed.
2984                    
2985                                                      ;Following subroutine will multiply the floating point
2986                                                      ;binary number stored in PPACC by 0.1 times the value
2987                                                      ;(negative) stored in the decimal exponent storage location
2988                    
2989                    MINEXP:
2990 24-033 066 214     FPD10:     LLI 214                ;Set pointer to registers containing floating point
2991 24-035 056 001                LHI \HB\OLDPG1         ;** Binary representation of 0.1 (decimal).
2992 24-037 106 277 022            CAL FACXOP             ;Transfer FPACC to FPOP and 0.1 (dec) to FPACC
2993 24-042 106 046 021            CAL FPMULT             ;Multitply FPOP (formerly FPACC) by 0.1 (decimal)
2994 24-045 066 157                LLI 157                ;Set pointer to decimal exponent storage location
2995 24-047 317                    LBM                    ;Fetch the exponent value
2996 24-050 010                    INB                    ;Increment
2997 24-051 371                    LMB                    ;Restore to storage
2998 24-052 110 033 024            JFZ FPD10              ;If exponent value is not zero, continue multiplication
2999 24-055 007                    RET                    ;When exponent is zero can exit. Conversion completed.
3000                    
3001                                                      ;Following subroutine is used
3002                                                      ;to convert decimal charac-
3003                                                      ;ters to binary fixed point forinat
3004                                                      ;in a triple-precision format.
3005                    
3006 24-056 106 317 022 DECBIN:    CAL SAVEHL             ;Save entry value of D, E, H and L in memory
3007 24-061 066 153                LLI 153                ;Set pointer to temporary storage location
3008 24-063 302                    LAC                    ;Restore character inputted to accumulator
3009 24-064 044 017                NDI 017                ;Trim ASCII code to BCD
3010 24-066 370                    LMA                    ;Store temporarily
3011 24-067 046 150                LEI 150                ;Set pointer to working area LSW of multi-byte register
3012 24-071 066 154                LLI 154                ;Set another pointer to LSW of conversion register
3013 24-073 335                    LDH                    ;Make sure D set to page of working area
3014 24-074 016 003                LBI 003                ;Set precision counter
3015 24-076 106 013 021            CAL MOVEIT             ;Move original value of conversion register to working
3016 24-101 066 154                LLI 154                ;Register. Reset pointer to LSW of conversion register.
3017 24-103 016 003                LBI 003                ;Set precision counter
3018 24-105 106 177 022            CAL ROTATL             ;Rotate register left, (Multiplies value by two.)
3019 24-110 066 154                LLI 154                ;Reset pointer to LSW.
3020 24-112 016 003                LBI 003                ;Set precision counter
3021 24-114 106 177 022            CAL ROTATL             ;Multiply by two again (total now times four).
3022 24-117 046 154                LEI 154                ;Set pointer to LSW of conversion register.
3023 24-121 066 150                LLI 150                ;Set pointer to LSW of working register (original value).
3024 24-123 016 003                LBI 003                ;Set precision counter.
3025 24-125 106 127 022            CAL ADDER              ;Add original value to rotated value (now times five).
3026 24-130 066 154                LLI 154                ;Reset pointer to LSW
3027 24-132 016 003                LBI 003                ;Set precision counter
3028 24-134 106 177 022            CAL ROTATL             ;Multiply by two once more (total now times ten).
3029 24-137 066 152                LLI 152                ;Set pointer to clear working register locatiotis
3030 24-141 250                    XRA                    ;Clear the accumulator
3031 24-142 370                    LMA                    ;Clear MSW of working register
3032 24-143 061                    DCL                    ;Decrement pointer
3033 24-144 370                    LMA                    ;Clear next byte
3034 24-145 066 153                LLI 153                ;Set pointer to current digit storage location
3035 24-147 307                    LAM                    ;Fetch the current digit
3036 24-150 066 150                LLI 150                ;Change pointer to LSW of working register
3037 24-152 370                    LMA                    ;Deposit the current digit in LSW of working register
3038 24-153 046 154                LEI 154                ;Set pointer to conversion register LSW
3039 24-155 016 003                LBI 003                ;Set precision counter
3040 24-157 106 127 022            CAL ADDER              ;Add current digit to conversion register to complete
3041 24-162 104 337 022            JMP RESTHL             ;Conversion. Exit to caller by restoring CPU registers.
3042 24-165 056 001     FPOUT:     LHI \HB\OLDPG1         ;** Set H to working area for floating point routines
3043 24-167 066 157                LLI 157                ;Set pointer to decimal exponent storage location
3044 24-171 076 000                LMI 000                ;Initialize storage location to zero
3045 24-173 066 126                LLI 126                ;Change pointer to FPACC (number to be outputted)
3046 24-175 307                    LAM                    ;And fetch MSW of FPACC
3047 24-176 240                    NDA                    ;Test the contents of MSW of FPACC
3048 24-177 160 207 024            JTS OUTNEG             ;If most significant bit of MSW is a one, have a minus nr.
3049 24-202 006 240                LAI 240                ;Else number is positive, set ASCII code for space for a
3050 24-204 104 220 024            JMP AHEAD1             ;Positive number and go display a space
3051 24-207 066 124     OUTNEG:    LLI 124                ;If number in FPACC is negative must negate in order
3052 24-211 016 003                LBI 003                ;To display. Set pntr to LSW of FPACC & set prec. cntr.
3053 24-213 106 150 022            CAL COMPLM             ;Negate the number in the FPACC to make it positive
3054 24-216 006 255                LAI 255                ;But load ACC with ASCII code for minus sign
3055 24-220 106 202 003 AHEAD1:    CAL ECHO               ;Call user display driver to output space or minus sign
3056 24-223 066 110                LLI 110                ;Set pointer to FIXED/FLOAT indicator
3057 24-225 307                    LAM                    ;Fetch value of FIXED/FLOAT indicator
3058 24-226 240                    NDA                    ;Test contents of indicator. If contents are zero, calling
3059 24-227 150 253 024            JTZ OUTFLT             ;Routine has directed floating point output format.
3060 24-232 066 127                LLI 127                ;If indicator non-zero, fixed point fonnat requested if
3061 24-234 006 027                LAI 027                ;Possible. Point to FPACC Exponent. Put 23 decimal in
3062 24-236 317                    LBM                    ;Accumulator. Fetch FPACC Exponent into register B
3063 24-237 010                    INB                    ;And exercise the register to test its
3064 24-240 011                    DCB                    ;Original contents. If FPACC Exponent is negative in
3065 24-241 160 253 024            JTS OUTFLT             ;Value then go to floating point output forrnat. If value
3066 24-244 221                    SUB                    ;Is positive, subtract value from 23 (decimal). If result
3067 24-245 160 253 024            JTS OUTFLT             ;Negative, number is too big to use fixed format.
3068 24-250 104 271 024            JMP OUTFIX             ;Else, can use fixed format so skip next routine
3069 24-253 066 110     OUTFLT:    LLI 110                ;Set pointer to FIXED/FLOAT indicator.
3070 24-255 076 000                LMI 000                ;Clear indicator to indicate floating point output format
3071 24-257 006 260                LAI 260                ;Load ASCII code for '0' into accumulator
3072 24-261 106 202 003            CAL ECHO               ;Call user display driver to output '0' as first character
3073 24-264 006 256                LAI 256                ;Number string. Now load ASCII code for decimal point.
3074 24-266 106 202 003            CAL ECHO               ;Call user display driver to output '.'as second character.
3075 24-271 066 127     OUTFIX:    LLI 127                ;Set pointer to FPACC Exponent
3076 24-273 006 377                LAI 377                ;Load accumulator with minus one
3077 24-275 207                    ADM                    ;Add value in FPACC Exponent
3078 24-276 370                    LMA                    ;Restore compensated exponent value
3079                    
3080                                                      ;Next portion of routine establishes the value for the
3081                                                      ;decimal exponent that will be outputted by processing
3082                                                      ;the binary exponent value in the FPACC.
3083                    
3084 24-277 120 336 024 DECEXT:    JFS DECEXD             ;If compensated exponent value is zero or positive
3085 24-302 006 004                LAI 004                ;Then go multiply FPACC by 0.1 (decimal). Else,
3086 24-304 207                    ADM                    ;Add four to the exponent value.
3087 24-305 120 360 024            JFS DECOUT             ;If exponent now zero or positive, ready to output
3088 24-310 066 210                LLI 210                ;If exponent negative, multiply FPACC by 10 (decimal)
3089 24-312 056 001                LHI \HB\OLDPG1         ;** Set pointer to registers holding 10 (dec) in binary
3090 24-314 106 277 022            CAL FACXOP             ;Floating point format. Set up for multiplication.
3091 24-317 106 046 021            CAL FPMULT             ;Perform the multiplication. Answer in FPACC.
3092 24-322 066 157                LLI 157                ;Set pointer to decimal exponent storage location.
3093 24-324 327                    LCM                    ;Each time the FPACC is multiplied by ten, need to
3094 24-325 021                    DCC                    ;Decrement the value in the decinial exponent storage
3095 24-326 372                    LMC                    ;Location. (This establishes decimal exponent value!)
3096 24-327 066 127     DECREP:    LLI 127                ;Reset pointer to FPACC Exponent
3097 24-331 307                    LAM                    ;Fetch value in exponent
3098 24-332 240                    NDA                    ;Test value
3099 24-333 104 277 024            JMP DECEXT             ;Repeat process as required
3100 24-336 066 214     DECEXD:    LLI 214                ;If exponent is positive, multiply FPACC by 0.1
3101 24-340 056 001                LHI \HB\OLDPG1         ;** Set pointer to registers holding 0.1 dec in binary
3102 24-342 106 277 022            CAL FACXOP             ;Floating point format. Set up for multipli(-ation.
3103 24-345 106 046 021            CAL FPMULT             ;Perform the multiplication. Answer in FPACC.
3104 24-350 066 157                LLI 157                ;Set pointer to decimal exponent storage location.
3105 24-352 317                    LBM                    ;Each time the FPACC is multiplied by one tenth, need
3106 24-353 010                    INB                    ;To increment the value in the decimal exponent storage
3107 24-354 371                    LMB                    ;Location. (This establishes decimal exponent value!)
3108 24-355 104 327 024            JMP DECREP             ;Repeat process as required
3109                    
3110                                                      ;The next section outputs the mantissa
3111                                                      ;(or fixed point number) by converting the value remaining
3112                                                      ;in the FPACC (after the decimal exponent equivalent has
3113                                                      ;been extracted from the original value if required by the
3114                                                      ;previous routines) to a string of decirnal digits.
3115 24-360 046 164     DECOUT:    LEI 164                ;Set pointer to LSW of output working register
3116 24-362 335                    LDH                    ;Set D to same page value as H
3117 24-363 066 124                LLI 124                ;Set pointer to LSW of FPACC
3118 24-365 016 003                LBI 003                ;Set precision counter
3119 24-367 106 013 021            CAL MOVEIT             ;Move value in FPACC to output working register
3120 24-372 066 167                LLI 167                ;Set pointer to MSW plus one of output working register
3121 24-374 076 000                LMI 000                ;Clear that location to 0
3122 24-376 066 164                LLI 164                ;Set pointer to LSW of output working register
3123 25-000 016 003                LBI 003                ;Set precision counter
3124 25-002 106 177 022            CAL ROTATL             ;Rotate register left once to compensate for sign bit
3125 25-005 106 223 025            CAL OUTX10             ;Multiply output register by 10, overflow into N4SW+ 1
3126 25-010 066 127     COMPEN:    LLI 127                ;Set pointer back to FPACC Exponent
3127 25-012 317                    LBM                    ;Compensate for any remainder in the binary exponent
3128 25-013 010                    INB                    ;By performing a rotate right on the output working
3129 25-014 371                    LMB                    ;Register until the binary exponent becomes zero
3130 25-015 150 032 025            JTZ OUTDIG             ;Go output decimal digits when this loop is finished
3131 25-020 066 167                LLI 167                ;Binary exponent compensating loop. Setpointe'r to
3132 25-022 016 004                LBI 004                ;Working register MSW+L. Set precision counter.
3133 25-024 106 211 022            CAL ROTATR             ;Rotate working register to the right.
3134 25-027 104 010 025            JMP COMPEN             ;Repeat loop as required.
3135 25-032 066 107     OUTDIG:    LLI 107                ;Set pointer to output digit counter storage location
3136 25-034 076 007                LMI 007                ;Initialize to value of seven
3137 25-036 066 167                LLI 167                ;Change pointer to output working register MSW+L
3138 25-040 307                    LAM                    ;Fetch MSW+L byte containing BCD of digit to be
3139 25-041 240                    NDA                    ;Displayed. Test the contents of this byte.
3140 25-042 150 165 025            JTZ ZERODG             ;If zero jump to ZERODG routine.
3141 25-045 066 167     OUTDGS:    LLI 167                ;Reset pointer to working register MSW+L
3142 25-047 307                    LAM                    ;Fetch BCD of digit to be outputted
3143 25-050 240                    NDA                    ;Exercise CPU flags
3144 25-051 110 105 025            JFZ OUTDGX             ;If not zero, go display the digit
3145 25-054 066 110                LLI 110                ;If zero, change pointer to FIXED/FLOAT indicator
3146 25-056 307                    LAM                    ;Fetch the indicator into the accumulator
3147 25-057 240                    NDA                    ;Test value of indicator
3148 25-060 150 104 025            JTZ OUTZER             ;If in floating point mode, go display the digit
3149 25-063 066 157                LLI 157                ;Else change pointer to decimal exponent storage
3150 25-065 327                    LCM                    ;Location, which, for fixed point, will have a positive
3151 25-066 021                    DCC                    ;Value for all digits before the decimal point. Decrement
3152 25-067 020                    INC                    ;And increment to exercise flags. See if count is positive.
3153 25-070 120 104 025            JFS OUTZER             ;If positive, must display any zero digit.
3154 25-073 066 166                LLI 166                ;If not, change pointer to MSW of working register
3155 25-075 307                    LAM                    ;And test to see if any significant digits coming up
3156 25-076 044 340                NDI 340                ;By forming a mask and testing for presence of bits
3157 25-100 110 104 025            JFZ OUTZER             ;If more significant digits coming up soon, display the
3158 25-103 007                    RET                    ;Zero digit. Else, exit to calling routine. Finished.
3159 25-104 250         OUTZER:    XRA                    ;Clear the accumulator to restore zero digit value
3160 25-105 004 260     OUTDGX:    ADI 260                ;Add 260 (octal) to BCD code in ACC to form ASCII
3161 25-107 106 202 003            CAL ECHO               ;Code and call the user's display driver subroutine
3162 25-112 066 110     DECRDG:    LLI 110                ;Set pointer to FIXED/FLOAT indicator storage
3163 25-114 307                    LAM                    ;Fetch the indicator to the accumulator
3164 25-115 240                    NDA                    ;Exercise the CPU flags
3165 25-116 110 137 025            JFZ CKDECP             ;If indicator non-zero, doing fixed point output
3166 25-121 066 107                LLI 107                ;Else, get output digit counter
3167 25-123 327                    LCM
3168 25-124 021                    DCC                    ;Decrement the digit counter & restore to storage
3169 25-125 372                    LMC
3170 25-126 150 300 025            JTZ EXPOUT             ;When digit counter is zero, go take care of exponent
3171 25-131 106 223 025 PUSHIT:    CAL OUTX10             ;Else push next BCD digit out of working register
3172 25-134 104 045 025            JMP OUTDGS             ;And continue the outputting process
3173 25-137 066 157     CKDECP:    LLI 157                ;For fixed point output, decimal exponent serves as
3174 25-141 327                    LCM                    ;Counter for number of digits before decimal point
3175 25-142 021                    DCC                    ;Fetch the counter and decrement it to account for
3176 25-143 372                    LMC                    ;Current digit being processed. Restore to storage.
3177 25-144 110 154 025            JFZ NODECP             ;If count does not go to zero, jump ahead.
3178 25-147 006 256                LAI 256                ;When count reaches zero, load ASCII code for period
3179 25-151 106 202 003            CAL ECHO               ;And call user's display driver to display decimal point
3180 25-154 066 107     NODECP:    LLI 107                ;Set pointer to output digit counter storage location
3181 25-156 327                    LCM                    ;Fetch the digit counter
3182 25-157 021                    DCC                    ;Decrement the value
3183 25-160 372                    LMC                    ;Restore to storage
3184 25-161 053                    RTZ                    ;If counter reaches zero, exit to caller. Finished.
3185 25-162 104 131 025            JMP PUSHIT             ;Else continue to output the number.
3186 25-165 066 157     ZERODG:    LLI 157                ;If first digit of floating point number is a zero, set
3187 25-167 327                    LCM                    ;Pointer to decimal exponent storage location.
3188 25-170 021                    DCC                    ;Decrement the value to compensate for skipping
3189 25-171 372                    LMC                    ;Display of first digit. Restore to storage.
3190 25-172 066 166                LLI 166                ;Change pointer to MSW of output working register
3191 25-174 307                    LAM                    ;Fetch MSW of output working register
3192 25-175 240                    NDA                    ;Test the contents
3193 25-176 110 112 025            JFZ DECRDG             ;If non-zero, continue outputting
3194 25-201 061                    DCL                    ;Else decrement pointer to next byte in working register
3195 25-202 307                    LAM                    ;Fetch its contents
3196 25-203 240                    NDA                    ;Test
3197 25-204 110 112 025            JFZ DECRDG             ;If non-zero, continue outputting
3198 25-207 061                    DCL                    ;Else decrement pointer to LSW of working register
3199 25-210 307                    LAM                    ;Fetch its contents
3200 25-211 240                    NDA                    ;Test
3201 25-212 110 112 025            JFZ DECRDG             ;If non-zero, continue outputting
3202 25-215 066 157                LLI 157                ;If decimal mantissa is zero, set pointer to decirnal
3203 25-217 370                    LMA                    ;Exponent storage and clear it
3204 25-220 104 112 025            JMP DECRDG             ;Finish outputting
3205                    
3206                                                      ;Following routine multiplies the binary number in the
3207                                                      ;output working register by ten to push the most signifi-
3208                                                      ;cant digit out to the MSW+L byte.
3209                    
3210 25-223 066 167     OUTX10:    LLI 167                ;Set pointer to work ing register M SW+ 1
3211 25-225 076 000                LMI 000                ;Clear it in preparation for receiving next digit pushed
3212 25-227 066 164                LLI 164                ;Into it. Change pointer to working register LSW.
3213 25-231 335                    LDH                    ;Set up register D to same page as H.
3214 25-232 046 160                LEI 160                ;Set second pointer to LSW of second working register
3215 25-234 016 004                LBI 004                ;Set precision counter
3216 25-236 106 013 021            CAL MOVEIT             ;Move first working register into second
3217 25-241 066 164                LLI 164                ;Reset pointer to LSW of first working register
3218 25-243 016 004                LBI 004                ;Set precision counter
3219 25-245 106 177 022            CAL ROTATL             ;Rotate contents of first working register left (X 2)
3220 25-250 066 164                LLI 164                ;Reset pointer to LSW
3221 25-252 016 004                LBI 004                ;Reset precision counter
3222 25-254 106 177 022            CAL ROTATL             ;Rotate contents left again (X 4)
3223 25-257 066 160                LLI 160                ;Set pointer to LSW of original value in 2'nd register
3224 25-261 046 164                LEI 164                ;Set pointer to LSW of rotated value
3225 25-263 016 004                LBI 004                ;Set precision counter
3226 25-265 106 127 022            CAL ADDER              ;Add rotated value to original value (X 5)
3227 25-270 066 164                LLI 164                ;Reset pointer to LSW of first working register
3228 25-272 016 004                LBI 004                ;Set precision counter
3229 25-274 106 177 022            CAL ROTATL             ;Rotate contents left again (X 10)
3230 25-277 007                    RET                    ;Exit to calling routine
3231                    
3232                                                      ;The final group of routines in the floating point output
3233                                                      ;section take care of outputting the decimal exponent
3234                                                      ;portion of floating point numbers.
3235                    
3236 25-300 066 157     EXPOUT:    LLI 157                ;Set pointer to decimal exponent storage location
3237 25-302 307                    LAM                    ;Fetch value to the accumulator
3238 25-303 240                    NDA                    ;Test the value
3239 25-304 053                    RTZ                    ;If zero, then no exponent portion. Exit to caller.
3240 25-305 006 305                LAI 305                ;Else, load ACC with ASCII code for letter E.
3241 25-307 106 202 003            CAL ECHO               ;Display E for Exponent via user's display driver rtn
3242 25-312 307                    LAM                    ;Get decimal exponent value back into ACC
3243 25-313 240                    NDA                    ;Test again
3244 25-314 160 324 025            JTS EXOUTN             ;If value is negative, skip ahead
3245 25-317 006 253                LAI 253                ;If positive, load ASCII code for + sign
3246 25-321 104 333 025            JMP AHEAD2             ;Jump to display the + sign
3247 25-324 054 377     EXOUTN:    XRI 377                ;When decimal exponent is negative, must negate
3248 25-326 004 001                ADI 001                ;Value for display purposes. Perform two's complement
3249 25-330 370                    LMA                    ;And restore the negated value to storage location
3250 25-331 006 255                LAI 255                ;Load ASCII code for minus sign
3251 25-333 106 202 003 AHEAD2:    CAL ECHO               ;Display the ASCII character in ACC
3252 25-336 016 000                LBI 000                ;Clear register B
3253 25-340 307                    LAM                    ;Fetch the decimal exponent value back into ACC
3254 25-341 024 012     SUB12:     SUI 012                ;Subtract 10 (decimal) from value in ACC
3255 25-343 160 353 025            JTS TOMUCH             ;Break out of loop when accumulator goes negative
3256 25-346 370                    LMA                    ;Else restore value to storage location
3257 25-347 010                    INB                    ;Increment register B as a counter
3258 25-350 104 341 025            JMP SUB12              ;Repeat loop to form tens value of decimal exponent
3259 25-353 006 260     TOMUCH:    LAI 260                ;Load base ASCII value for digit into the accumulator
3260 25-355 201                    ADB                    ;Add to the count in B to forin tens digit of decimal
3261 25-356 106 202 003            CAL ECHO               ;Exponent. Display via user's driver subroutine
3262 25-361 307                    LAM                    ;Fetch remainder of decimal exponent value
3263 25-362 004 260                ADI 260                ;Add in ASCII base value to form final digit
3264 25-364 106 202 003            CAL ECHO               ;Display second digit of decirnal exponent
3265 25-367 007                    RET                    ;Finished outputting. Return to caller.
3266                    ;;; The above RETURN SHOULD BE AT 25 367
3267                    
3268                    ;;; NOW OPEN AREA UP TO 26 000 CAN BE USED FOR PATCHING...
3269                    
3270                    	ORG 026#000
3271 26-000 000          	DATA 000		; CC FOR INPUT LINE BUFFER
3272 26-001             	DATA *79 		; THE INPUT LINE BUFFER
3273 26-120 000 000 000  	DATA 000,000,000,000	; THESE ARE SYMBOL BUFFER STORAGE
     26-123 000 
3274 26-124 000 000 000  	DATA 000,000,000,000
     26-127 000 
3275 26-130 000 000 000  	DATA 000,000,000,000	; SHOULD BE 26-120 TO 26 143
     26-133 000 
3276 26-134 000 000 000  	DATA 000,000,000,000
     26-137 000 
3277 26-140 000 000 000  	DATA 000,000,000,000
     26-143 000 
3278 26-144 000 000 000  	DATA 000,000,000,000	; THESE LOCATIONS ARE AUXILIARY SYMBOL BUFFER
     26-147 000 
3279 26-150 000 000 000  	DATA 000,000,000,000
     26-153 000 
3280 26-154 000 000 000  	DATA 000,000,000,000	; SHOULD BE 26 144 TO 26 175
     26-157 000 
3281 26-160 000 000 000  	DATA 000,000,000,000
     26-163 000 
3282 26-164 000 000 000  	DATA 000,000,000,000
     26-167 000 
3283 26-170 000 000 000  	DATA 000,000,000,000
     26-173 000 
3284 26-174 000 000      	DATA 000,000
3285 26-176 000          	DATA 000		; TEMP SCAN STORAGE REGISTER
3286 26-177 000          	DATA 000		; TAB FLAG
3287 26-200 000          	DATA 000		; EVAL CURRENT TEMP REG.
3288 26-201 000          	DATA 000		; SYNTAX LINE NUMBER
3289 26-202 000          	DATA 000		; SCAN TEMPORARY REGISTER
3290 26-203 000          	DATA 000		; STATEMENT TOKEN
3291 26-204 000 000      	DATA 000,000		; TEMPORARY WORKING REGISTERS
3292 26-206 000 000      	DATA 000,000		; ARRAY POINTERS
3293                    ;;; NOW WE SHOULD BE UP TO 26 210
3294 26-210 000          	DATA 000		; OPERATOR STACK POINTER
3295 26-211             	DATA *15		; OPERATOR STACK
3296 26-230 000          	DATA 000		; FUN/ARRAY STACK POINTER
3297 26-231             	DATA *7			; FUNCTION/ARRAY STACK
3298                    ;;; THE LAST BYTE SHOULD HAVE BEEN 26 237
3299                    
3300                    
3301                    	;; HEIRARCHY TABLE (FOR OUT OF STACK OPS)
3302                    	;; USED BY PARSER ROUTINE.
3303                    ;;; This SHOULD START AT 26 240
3304 26-240 000          	DATA 000		; EOS
3305 26-241 003          	DATA 003		; PLUS SIGN
3306 26-242 003          	DATA 003		; MINUS SIGN
3307 26-243 004          	DATA 004		; MULTIPLICATION SIGN
3308 26-244 004          	DATA 004		; DIVISION SIGN
3309 26-245 005          	DATA 005		; EXPONENT SIGN
3310 26-246 006          	DATA 006		; LEFT PARENTHESIS
3311 26-247 001          	DATA 001		; RIGHT PARENTHESIS
3312 26-250 002          	DATA 002		; NOT ASSIGNED
3313 26-251 002          	DATA 002		; LESS THAN SIGN
3314 26-252 002          	DATA 002		; Equal sign
3315 26-253 002          	DATA 002		; GREATER THAN SIGN
3316 26-254 002          	DATA 002		; LESS THAN OR EQUAL COMBO
3317 26-255 002          	DATA 002		; EQUAL OR GREATER THAN
3318 26-256 002          	DATA 002		; LESS THAN OR GREATER THAN
3319                    
3320                    	;; HEIRARCHY TABLE (FOR INTO STACK OPS)
3321                    	;; USED BY PARSER ROUTINE.
3322                    ;;; This SHOULD START AT 26 257
3323 26-257 000          	DATA 000		; EOS
3324 26-260 003          	DATA 003		; PLUS SIGN
3325 26-261 003          	DATA 003		; MINUS SIGN
3326 26-262 004          	DATA 004		; MULTIPLICATION SIGN
3327 26-263 004          	DATA 004		; DIVISION SIGN
3328 26-264 005          	DATA 005		; EXPONENTIATION SIGN
3329 26-265 001          	DATA 001		; LEFT PARENTHESIS
3330 26-266 001          	DATA 001		; RIGHT PARENTHESIS
3331 26-267 002          	DATA 002		; NOT ASSIGNED
3332 26-270 002          	DATA 002		; LESS THAN SIGN
3333 26-271 002          	DATA 002		; EQUAL SIGN
3334 26-272 002          	DATA 002		; GREATER THAN SIGN
3335 26-273 002          	DATA 002		; LESS THAN OR EQUAL SIGN
3336 26-274 002          	DATA 002		; EQUAL TO OR GREATER THAN
3337 26-275 002          	DATA 002		; LESS THAN OR GREATER THAN
3338                    
3339 26-276 000          	DATA 000		; EVAL START POINTER
3340 26-277 000          	DATA 000		; EVAL FINISH POINTER
3341                    
3342                    	;; FUNCTION NAMES TABLE
3343                    ;;; This SHOULD START AT 26 300
3344 26-300 003          	DATA 3
3345 26-301 311 316 324  	DATA "INT"
3346 26-304 003          	DATA 3
3347 26-305 323 307 316  	DATA "SGN"
3348 26-310 003          	DATA 3
3349 26-311 301 302 323  	DATA "ABS"
3350 26-314 003          	DATA 3
3351 26-315 323 321 322  	DATA "SQR"
3352 26-320 003          	DATA 3
3353 26-321 324 301 302  	DATA "TAB"
3354 26-324 003          	DATA 3
3355 26-325 322 316 304  	DATA "RND"
3356 26-330 003          	DATA 3
3357 26-331 303 310 322  	DATA "CHR"
3358 26-334 003          	DATA 3
3359 26-335 325 304 306  	DATA "UDF"
3360                    
3361 26-340 000 000 000  	DATA 000,000,000,000	; LINE NUMBER BUFFER STORAGE
     26-343 000 
3362 26-344 000 000 000  	DATA 000,000,000,000	; (SHOULD BE 340-347)
     26-347 000 
3363 26-350 000 000 000  	DATA 000,000,000,000	; AUX LINE NUMBER BUFFER
     26-353 000 
3364 26-354 000 000 000  	DATA 000,000,000,000	; (SHOULD BE 350-357)
     26-357 000 
3365                    ;;; The following data is a change in page 3 of Scelbal update issue 4
3366                    ;;; which apparently makes the "INSERT" command work correctly, the
3367                    ;;; first time (later SCR commands load 33 into this spot) 
3368 26-360 033          	DATA 033 		; USER PGM LINE PTR (PG)
3369 26-361 000          	DATA 000 		; USER PGM LINE PTR (LOW)
3370 26-362 000          	DATA 000 		; AUX PGM LINE PTR (PG)
3371 26-363 000          	DATA 000 		; AUX PGM LINE PTR (LOW)
3372 26-364 000          	DATA 000 		; END OF USER PGM BUFFER PTR (PG)
3373 26-365 000          	DATA 000 		; END OF USER PGM BUFFER PTR (LOW)
3374 26-366 000          	DATA 000		; PARENTHESIS COUNTER (366)
3375 26-367 000          	DATA 000		; QUOTE INDICATOR
3376 26-370 000          	DATA 000		; TABLE COUNTER (370)
3377                    ;;; locations 371-377 NOT ASSIGNED
3378                    
3379                    	ORG 027#000
3380 27-000 003          	DATA 3
3381 27-001 322 305 315  	DATA "REM"
3382 27-004 002          	DATA 2
3383 27-005 311 306      	DATA "IF"
3384 27-007 003          	DATA 3    ;MGA 3/31/12 Loboyko transcription error
3385 27-010 314 305 324  	DATA "LET"
3386 27-013 004          	DATA 4
3387 27-014 307 317 324  	DATA "GOTO"
     27-017 317 
3388 27-020 005          	DATA 5
3389 27-021 320 322 311  	DATA "PRINT"
     27-024 316 324 
3390 27-026 005          	DATA 5
3391 27-027 311 316 320  	DATA "INPUT"
     27-032 325 324 
3392 27-034 003          	DATA 3
3393 27-035 306 317 322  	DATA "FOR"
3394 27-040 004          	DATA 4
3395 27-041 316 305 330  	DATA "NEXT"
     27-044 324 
3396 27-045 005          	DATA 5
3397 27-046 307 317 323  	DATA "GOSUB"
     27-051 325 302 
3398 27-053 006          	DATA 6    ;MGA 4/12/12 another Loboyko transcription error
3399 27-054 322 305 324  	DATA "RETURN"
     27-057 325 322 316
3400 27-062 003          	DATA 3
3401 27-063 304 311 315  	DATA "DIM"
3402 27-066 003          	DATA 3
3403 27-067 305 316 304  	DATA "END"
3404 27-072 000          	DATA 0			; END OF TABLE, SHOULD BE 072
3405                    
3406 27-073 000          	DATA 000		; GOSUB STACK POINTER
3407 27-074             	DATA *1			; NOT ASSIGNED;
3408 27-075 000          	DATA 000		; NUMBER OF ARRAYS COUNTER
3409 27-076 000          	DATA 000		; ARRAY POINTER
3410 27-077 000          	DATA 000		; VARIABLES COUNTER SHOULD BE 077
3411 27-100 000 000 000  	DATA 000,000,000,000	; USED AS THE GOSUB STACK 100-117
     27-103 000 
3412 27-104 000 000 000  	DATA 000,000,000,000
     27-107 000 
3413 27-110 000 000 000  	DATA 000,000,000,000
     27-113 000 
3414 27-114 000 000 000  	DATA 000,000,000,000
     27-117 000 
3415 27-120 000 000 000  	DATA 000,000,000,000	; USED AS ARRAY VARIABLES TABLE
     27-123 000 
3416 27-124 000 000 000  	DATA 000,000,000,000	; SHOULD BE 120-137
     27-127 000 
3417 27-130 000 000 000  	DATA 000,000,000,000
     27-133 000 
3418 27-134 000 000 000  	DATA 000,000,000,000
     27-137 000 
3419                    
3420 27-140 000 000 000  	DATA 000,000,000,000	; USED FOR FOR/NEXT STACK STORAGE
     27-143 000 
3421 27-144 000 000 000  	DATA 000,000,000,000	; SHOULD BE 140 TO 177
     27-147 000 
3422 27-150 000 000 000  	DATA 000,000,000,000
     27-153 000 
3423 27-154 000 000 000  	DATA 000,000,000,000
     27-157 000 
3424 27-160 000 000 000  	DATA 000,000,000,000
     27-163 000 
3425 27-164 000 000 000  	DATA 000,000,000,000
     27-167 000 
3426 27-170 000 000 000  	DATA 000,000,000,000
     27-173 000 
3427 27-174 000 000 000  	DATA 000,000,000,000
     27-177 000 
3428 27-200 000          	DATA 000		; FOR/NEXT STACK POINTER
3429 27-201 000          	DATA 000		; ARRAY/VARIABLE FLAG
3430 27-202 000          	DATA 000  		; STOSYM COUNTER
3431 27-203 000          	DATA 000		; FUN/ARRAY STACK POINTER (203
3432 27-204 000          	DATA 000		; ARRAY VALUES POINTER
3433 27-205             	DATA *3			; NOT USED (SHOULD BE 205-207)
3434 27-210 000          	DATA 000		; USED AS VARIABLES SYMBOL TABLE
3435 27-211             	DATA *119		; (SHOULD BE 211-377 RESERVED)
3436                    ;;; The above should cover 211 to 377
3437                    	;; THERE ARE NOW ADDRESSES AT START OF PAGE 30, NOT ASSIGNED;
3438                    
3439                    
3440                    ;;; The following is PATCH NR.1
3441                    	ORG 030#000
3442 30-000 066 123     PATCH1:	LLI 123
3443 30-002 076 000     	LMI 000
3444 30-004 066 133     	LLI 133
3445 30-006 076 000     	LMI 000
3446 30-010 007         	RET
3447                    
3448                    	
3449                    	
3450                    	ORG 030#013
3451                    	
3452 30-013 066 144     NEXT:      LLI 144                ;Load L with start of AUX SYMBOL BUFFER
3453 30-015 056 026                LHI \HB\OLDPG26        ;** Set H to page of AUX SYMBOL BUFFER
3454 30-017 076 000                LMI 000                ;Initialize AUX SYMBOL BUFFER by clearing first byte
3455 30-021 066 202                LLI 202                ;Change L to address of SCAN pointer
3456 30-023 317                    LBM                    ;Fetch pointer value to CPU register B
3457 30-024 010                    INB                    ;Add one to the current pointer value
3458 30-025 066 201                LLI 201                ;Load L with address of NEXT pointer storage location
3459 30-027 371                    LMB                    ;Place the updated SCAN pointer as the NEXT pointer
3460 30-030 066 201     NEXT1:     LLI 201                ;Reset L to address of NEXT pointer storage location
3461 30-032 106 240 002            CAL GETCHR             ;Fetch the character pointed to by the NEXT pointer
3462 30-035 150 045 030            JTZ NEXT2              ;If the character is a space, ignore it
3463 30-040 066 144                LLI 144                ;Else, load L with start of AUX SYMBOL BUFFER
3464 30-042 106 314 002            CAL CONCT1             ;Concatenate the character onto the AUX SYMBOL BF
3465 30-045 066 201     NEXT2:     LLI 201                ;Reset L to address of NEXT pointer storage location
3466 30-047 106 003 003            CAL LOOP               ;Advance the NEXT pointer and see if end of line
3467 30-052 110 030 030            JFZ NEXT1              ;Fetch next character in line if not end of line
3468 30-055 066 144                LLI 144                ;When reach end of line, should have variable name
3469 30-057 307                    LAM                    ;In the AUX SYMBOL BUFFER. Fetch the (cc) for
3470 30-060 074 001                CPI 001                ;The buffer and see if variable name is just one letter
3471 30-062 110 071 030            JFZ NEXT3              ;If more than one proceed directly to look for name
3472 30-065 066 146                LLI 146                ;In FOR/NEXT STACK. If have just a one letter name
3473 30-067 076 000                LMI 000                ;Then set second character in buffer to zero
3474 30-071 066 205     NEXT3:     LLI 205                ;Load L with address of FOR/NEXT STACK pointer
3475 30-073 056 027                LHI \HB\OLDPG27        ;** Set H to page of FOR/NEXT STACK pointer
3476 30-075 307                    LAM                    ;Fetch the FOR/NEXT STACK pointer value to ACC
3477 30-076 002                    RLC                    ;Rotate value left to multiply by two. Then rotate it
3478 30-077 002                    RLC                    ;Left again to multiply by four. Add base address plus
3479 30-100 004 136                ADI 136                ;Two to form pointer to variable name in top of stack
3480 30-102 056 027                LHI \HB\OLDPG27        ;** Set H to page of FOR/NEXT STACK
3481 30-104 360                    LLA                    ;Move pointer value from ACC to CPU register L
3482 30-105 036 026                LDI \HB\OLDPG26        ;** Set register D to page of AUX SYMBOL BUFFER
3483 30-107 046 145                LEI 145                ;Set register E to first character in the buffer
3484 30-111 016 002                LBI 002                ;Set B to serve as a character counter
3485 30-113 106 370 002            CAL STRCPC             ;See if variable name in the NEXT statement same as
3486 30-116 150 130 030            JTZ NEXT4              ;That stored in the top of the FOR/NEXT STACK
3487 30-121 006 306     FORNXT:    LAI 306                ;Load ACC with ASCII code for letter F
3488 30-123 026 316                LCI 316                ;Load register C with ASCII code for letter N
3489 30-125 104 226 002            JMP ERROR              ;Display For/Next (FN) error message if required
3490 30-130 066 360     NEXT4:     LLI 360                ;Load L with address of user program line pointer
3491 30-132 056 026                LHI \HB\OLDPG26        ;** Load H with page of user pgm line pntr storage loc.
3492 30-134 337                    LDM                    ;Fetch the page portion of the line pointer into D
3493 30-135 060                    INL                    ;Advance the memory pointer
3494 30-136 347                    LEM                    ;Fetch the low portion of the line pointer into E
3495 30-137 060                    INL                    ;Advance pntr to AUXILIARY LINE POINTER storage
3496 30-140 373                    LMD                    ;Location and store value of line pointer there too (page)
3497 30-141 060                    INL                    ;Advance pointer to second byte of AUXILIARY line
3498 30-142 374                    LME                    ;Pointer and store value of line pointer (low portion)
3499 30-143 066 205                LLI 205                ;Load L with address of FOR/NEXT STACK pointer
3500 30-145 056 027                LHI \HB\OLDPG27        ;** Set H to page of FOR/NEXT STACK pointer
3501 30-147 307                    LAM                    ;Fetch the FOR/NEXT STACK pointer value to ACC
3502 30-150 002                    RLC                    ;Rotate value left to multiply by two. Then rotate it
3503 30-151 002                    RLC                    ;Left again to multiply by four. Add base address to
3504 30-152 004 134                ADI 134                ;Form pointer to top of FOR/NEXT STACK and place
3505 30-154 360                    LLA                    ;The pointer value into CPU register L. Fetch the page
3506 30-155 337                    LDM                    ;Address of the associated FOR statement line pointer
3507 30-156 060                    INL                    ;Into register D. Advance the pointer and fetch the low
3508 30-157 347                    LEM                    ;Address value into register E. Prepare to change user
3509 30-160 066 360                LLI 360                ;Program line pointer to the FOR statement line by
3510 30-162 056 026                LHI \HB\OLDPG26        ;** Setting H & L to the user pgrn line pntr storage loc.
3511 30-164 373                    LMD                    ;Place the page value in the pointer storage location
3512 30-165 060                    INL                    ;Advance the memory pointer
3513 30-166 374                    LME                    ;Place the low value in the pointer storage location
3514 30-167 353                    LHD                    ;Now set up H and L to point to the start of the
3515 30-170 364                    LLE                    ;Associated FOR statement line in the user pgm buffer
3516 30-171 036 026                LDI \HB\OLDPG26        ;** Change D to point to the line input buffer
3517 30-173 046 000                LEI 000                ;And set L to the gtart of the line input buffer
3518 30-175 106 046 012            CAL MOVEC              ;Move the associated FOR statement line into the input
3519 30-200 066 325                LLI 325                ;Line buffer. Set L to point to start of TO string which is
3520 30-202 056 001                LHI \HB\OLDPG1         ;** Stored in a text strings storage area on this page
3521 30-204 106 012 013            CAL INSTR              ;Search the statement line for the occurrence of TO
3522 30-207 304                    LAE                    ;Register E will be zero if TO not found. Move E to ACC
3523 30-210 240                    NDA                    ;To make a test. If TO found then proceed to set up for
3524 30-211 150 121 030            JTZ FORNXT             ;Evaluation. If TO not found, then have error condition.
3525 30-214 004 002                ADI 002                ;Advance the pointer over the characters in TO string
3526 30-216 066 276                LLI 276                ;Change L to point to EVAL pointer storage location
3527 30-220 056 026                LHI \HB\OLDPG26        ;** Set H to page of EVAL pointer. Set up the starting
3528 30-222 370                    LMA                    ;Position for the EVAL subroutine (after TO string)
3529 30-223 066 330                LLI 330                ;Set L to point to start of STEP string which is stored
3530 30-225 056 001                LHI \HB\OLDPG1         ;** In text stxings storage area on this page. Search the
3531 30-227 106 012 013            CAL INSTR              ;Statement line for the occurrence of STEP
3532 30-232 304                    LAE                    ;Register E will be zero if STEP not found. Move E to
3533 30-233 240                    NDA                    ;The accumulator to make a test. If STEP found must
3534 30-234 110 300 030            JFZ NEXT5              ;Evaluate expression after STEP to get STEP SIZE.
3535 30-237 066 004                LLI 004                ;Else, have an IMPLIED STEP SIZE of 1.0. Set pointer
3536 30-241 056 001                LHI \HB\OLDPG1         ;** To start of storage area for 1.0 in floating point
3537 30-243 106 244 022            CAL FLOAD              ;Format and call subroutine to load FPACC with 1.0
3538 30-246 066 304                LLI 304                ;Set L to start of FOR/NEXT STEP SIZE storage loc.
3539 30-250 106 255 022            CAL FSTORE             ;Store the value 1.0 in the F/N STEP SIZE registers
3540 30-253 066 000                LLI 000                ;Change L to the start of the input line buffer
3541 30-255 056 026                LHI \HB\OLDPG26        ;** Set H to the page of the input line buffer
3542 30-257 317                    LBM                    ;Fetch the (cc) into CPU register B (length of FOR line)
3543 30-260 066 277                LLI 277                ;Change L to EVAL FINISH pointer stomge location
3544 30-262 371                    LMB                    ;Set the EVAL FINISH pointer to the end of the line
3545 30-263 106 224 003            CAL EVAL               ;Evaluate the LIMIT expression to obtain FOR LIMIT
3546 30-266 066 310                LLI 310                ;Load L with address of start of F/N LIMIT registers
3547 30-270 056 001                LHI \HB\OLDPG1         ;** Load H with page of FOR/NEXT LIMIT registers
3548 30-272 106 255 022            CAL FSTORE  ;MGA 3/31/12 no lab here Store the FOR/NEXT LIMIT value
3549 30-275 104 351 030            JMP NEXT6              ;Since have IMPLIED STEP jump ahead
3550 30-300 041         NEXT5:     DCE  ;MGA 3/21/12 lab here When have STEP directive, subtract one from pointer
3551 30-301 066 277                LLI 277                ;To get to character before S in STEP. Save this value in
3552 30-303 056 026                LHI \HB\OLDPG26        ;** The EVAL FINISH pointer stomge location to serve
3553 30-305 374                    LME                    ;As evaluation end location when obtaining TO Iiinit
3554 30-306 106 224 003            CAL EVAL               ;Evaluate the LIMIT expression to obtain FOR LIMIT
3555 30-311 066 310                LLI 310                ;Load L with address of start of FIN LIMIT registers
3556 30-313 056 001                LHI \HB\OLDPG1         ;** Load H with page of FORINEXT LIMIT registers
3557 30-315 106 255 022            CAL FSTORE             ;Store the FOR/NEXT LIMIT value
3558 30-320 066 277                LLI 277                ;Reset L to EVAL FINISH pointer storage location
3559 30-322 056 026                LHI \HB\OLDPG26        ;** Set H to page of EVAL FINISH pointer storage loc.
3560 30-324 307                    LAM                    ;Fetch the pointer value (character before S in STEP)
3561 30-325 004 005                ADI 005                ;Add five to change pointer to character after P in STEP
3562 30-327 061                    DCL                    ;Decrement L to point to EVAL (start) pointer
3563 30-330 370                    LMA                    ;Set up the starting position for the EVAL subroutine
3564 30-331 066 000                LLI 000                ; Load L with starting address of the line input buffer
3565 30-333 317                    LBM                    ;Fetch the (cc) for the line input buffer (line length)
3566 30-334 066 277                LLI 277                ;Change L to the EVAL FINISH storage location
3567 30-336 371                    LMB                    ;Set the EVAL FINISH pointer
3568 30-337 106 224 003            CAL EVAL               ;Evaluate the STEP SIZE expression
3569 30-342 066 304                LLI 304                ;Load L with address of start of F/N STEP registers
3570 30-344 056 001                LHI \HB\OLDPG1         ;** Set H to page of FIN STEP registers
3571 30-346 106 255 022            CAL FSTORE             ;Store the FOR/NEXT STEP SIZE value
3572 30-351 066 144     NEXT6:     LLI 144                ;Load L with address of AUX SYMBOL BUFFER
3573 30-353 056 026                LHI \HB\OLDPG26        ;** Set H to page of the AUX SYMBOL BUFFER
3574 30-355 076 000                LMI 000                ;Initialize AUX SUMBOL BUFFER with a zero byte
3575 30-357 066 034                LLI 034                ;Set L to start of FOR string which is stored in the
3576 30-361 056 027                LHI \HB\OLDPG27        ;** KEYWORD look-up table on this page
3577 30-363 106 012 013            CAL INSTR              ;Search the statement line for the FOR directive
3578 30-366 304                    LAE                    ;Register E will be zero if FOR not found. Move E to
3579 30-367 240                    NDA                    ;ACC and -make test to see if FOR directive located
3580 30-370 066 202                LLI 202                ;Load L with address of SCAN pointer
3581 30-372 056 026                LHI \HB\OLDPG26        ;** Load H with page of SCAN pointer
3582 30-374 370                    LMA                    ;Set up pointer to occurrence of FOR directive in line
3583 30-375 150 121 030            JTZ FORNXT             ;If FOR not found, have an error condition
3584 31-000 004 003                ADI 003                ;If have FOR, add three to advance pointer over FOR
3585 31-002 066 203                LLI 203                ;Set L to point to F/N pointer storage location
3586 31-004 370                    LMA                    ;Set F/N pointer to character after FOR directive
3587 31-005 066 203     NEXT7:     LLI 203                ;Set L to point to FIN pointer storage location
3588 31-007 106 240 002            CAL GETCHR             ;Fetch a character from position pointed to by FIN pntr
3589 31-012 150 027 031            JTZ NEXT8              ;If character is a space, ignore it
3590 31-015 074 275                CPI 275                ;Else, test to see if character is "=" sign
3591 31-017 150 042 031            JTZ NEXT9              ;If yes, have picked up variable name, jump ahead
3592 31-022 066 144                LLI 144                ;If not, set L to the start of the AUX SYMBOL BUFFER
3593 31-024 106 314 002            CAL CONCT1             ;And store the character in the AUX SYMBOL BUFFER
3594 31-027 066 203     NEXT8:     LLI 203                ;Load L with address of the F/N pointer
3595 31-031 106 003 003            CAL LOOP               ;Increment the pointer and see if end of the line
3596 31-034 110 005 031            JFZ NEXT7              ;If not, continue fetching characters
3597 31-037 104 121 030            JMP FORNXT             ;If end of line before "=" sign then have error condx
3598 31-042 066 202     NEXT9:     LLI 202                ;Load L with address of SCAN pointer
3599 31-044 056 026                LHI \HB\OLDPG26        ;** Load H with page of SCAN pointer
3600 31-046 307                    LAM                    ;Fetch pointer value to ACC (points to start of FOR
3601 31-047 004 003                ADI 003                ;Directive) and add three to move pointer over FOR
3602 31-051 066 276                LLI 276                ;Directive. Change L to EVAL pointer storage location
3603 31-053 370                    LMA                    ;Set EVAL pointer to character after FOR in line
3604 31-054 066 203                LLI 203                ;Load L with address of FIN pointer storage location
3605 31-056 317                    LBM                    ;Fetch pointer to register B (points to "=" sign) and
3606 31-057 011                    DCB                    ;Decrement the pointer (to character before "=" sign)
3607 31-060 066 277                LLI 277                ;Load L with address of EVAL FINISH pointer
3608 31-062 371                    LMB                    ;Set EVAL FINISH pointer
3609 31-063 106 224 003            CAL EVAL               ;Call subroutine to obtain current value of the variable
3610 31-066 066 304                LLI 304                ;Load L with address of start of F/N STEP registers
3611 31-070 056 001                LHI \HB\OLDPG1         ;** Set H to page of F/N STEP registers
3612 31-072 106 277 022            CAL FACXOP             ;Call subroutine to set up FP registers for addition
3613 31-075 106 211 020            CAL FPADD              ;Add FIN STEP size to current VARIABLE value
3614 31-100 066 314                LLI 314                ;Load L with address of FIN TEMP storage registers
3615 31-102 056 001                LHI \HB\OLDPG1         ;**Set H to page of FIN TEMP storage registers
3616 31-104 106 255 022            CAL FSTORE             ;Save the result of the addition in F/N TEMP registers
3617 31-107 066 310                LLI 310                ;Load L with starting address of F/N LIMIT registers
3618 31-111 106 277 022            CAL FACXOP             ;Call subroutine to set up FP registers for subtraction
3619 31-114 106 032 021            CAL FPSUB              ;Subtract F/N LIMIT value from VARIABLE value
3620 31-117 066 306                LLI 306                ;Set pointer to MSW of F/N STEP registers
3621 31-121 307                    LAM                    ;Fetch this value into the ACC
3622 31-122 240                    NDA                    ;Test to see if STEP value might be zero
3623 31-123 066 126                LLI 126                ;Load L with address of MSW of FPACC
3624 31-125 307                    LAM                    ;Fetch this value into the ACC
3625 31-126 150 121 030            JTZ FORNXT             ;If STEP size was zero, then endless loop, an error condx
3626 31-131 160 170 031            JTS NEXT11             ;If STEP size less than zero make alternate test on limit
3627 31-134 240                    NDA                    ;Test the contents of the MSW of the FPACC
3628 31-135 160 177 031            JTS NEXT12             ;Continue FORINEXT loop if current variable value is
3629 31-140 150 177 031            JTZ NEXT12             ;Less than or equal to the F/N LIMIT value
3630 31-143 066 363     NEXT10:    LLI 363                ;If out of LIMIT range, load L with address of the AUX
3631 31-145 056 026                LHI \HB\OLDPG26        ;** PGM LINE pointer. (Contains pointer to the NEXT
3632 31-147 347                    LEM                    ;Statement line that initiated this routine.) Fetch the
3633 31-150 061                    DCL                    ;Low part of the address into E, decrement the memory
3634 31-151 337                    LDM                    ;And get the page part of the address into CPU register
3635 31-152 061                    DCL                    ;Decrement memory pointer to the low portion of the
3636 31-153 374                    LME                    ;User pgm buffer line pointer (regular pointer) and set it
3637 31-154 061                    DCL                    ;With the value from the AUX line pntr, decrement the
3638 31-155 373                    LMD                    ;Pointer and do the same for the page portion
3639 31-156 066 205                LLI 205                ;Set L to address of FOR/NEXT STACK pointer
3640 31-160 056 027                LHI \HB\OLDPG27        ;** Set H to page of FOR/NEXT STACK pointer
3641 31-162 317                    LBM                    ;Fetch and decrement the
3642 31-163 011                    DCB                    ;FOR/NEXT STACK pointer value
3643 31-164 371                    LMB                    ;To perform effective popping operation
3644 31-165 104 116 013            JMP NXTLIN             ;Statement line after NEXT statement is done next
3645 31-170 240         NEXT11:    NDA                    ;When F/N STEP is negative, reverse test so that if the
3646 31-171 120 177 031            JFS NEXT12             ;Variable value is greater than or equal to the F/N LIMIT
3647 31-174 104 143 031            JMP NEXT10             ;The FOR/NEXT loop continues. Else it is finished.
3648 31-177 066 314     NEXT12:    LLI 314                ;Load L with address of FIN TEMP storage registers
3649 31-201 056 001                LHI \HB\OLDPG1         ;** Set H to FIN TEMP storage registers page
3650 31-203 106 244 022            CAL FLOAD              ;Transfer the updated variable value to the FPACC
3651 31-206 106 252 010            CAL RESTSY             ;Restore the variable name and value
3652 31-211 106 055 010            CAL STOSYM             ;In the VARIABLES table. Exit routine so that
3653 31-214 104 116 013            JMP NXTLIN             ;Statement line after FOR statement is done next
3654                    
3655                    ;;; The label BACKSP SHOULD BE AT 31 217
3656                    
3657 31-217 006 215     BACKSP:    LAI 215                ;Load ASCII code for carriage-return into the ACC
3658 31-221 106 202 003            CAL ECHO               ;Display the carriage-return
3659 31-224 106 202 003            CAL ECHO               ;Repeat to provide extra time if TTY
3660 31-227 066 043                LLI 043                ;Load L with address of COLUMN COUNTER
3661 31-231 056 001                LHI \HB\OLDPG1         ;** Set H to page of COLUMN COUNTER
3662 31-233 076 001                LMI 001                ;Set COLUMN COUNTER to first column
3663 31-235 066 124                LLI 124                ;Set L to address containing desired TAB position
3664 31-237 307                    LAM                    ;Fetch the desired TAB position value
3665 31-240 240                    NDA                    ;Test to see if it is
3666 31-241 063                    RTS                    ;Negative or zero
3667 31-242 053                    RTZ                    ;In which case return to caller
3668 31-243 104 022 010            JMP TAB1               ;Else, proceed to perform the TAB operation.
3669                    
3670                    	
3671                    ;;; The label FOR5 SHOULD START AT 31 246
3672                    	
3673 31-246 066 205     FOR5:      LLI 205                ;Load L with address of the FOR/NEXT STACK pointer
3674 31-250 056 027                LHI \HB\OLDPG27        ;** Load H with page of the FOR/NEXT STACK pntr
3675 31-252 307                    LAM                    ;Fetch the stack pointer to the ACC.
3676 31-253 002                    RLC                    ;Rotate it left to multiply by two, then rotate it again to
3677 31-254 002                    RLC                    ;Multiply by four. Add this value to the base address
3678 31-255 004 136                ADI 136                ;Plus two of the base address to point to the next part of
3679 31-257 340                    LEA                    ;The FOR/NEXT STACK. Place this value in register E.
3680 31-260 335                    LDH                    ;Set D to the FORINEXT STACK area page.
3681 31-261 066 145                LLI 145                ;Load L with the address of the first character in the
3682 31-263 056 026                LHI \HB\OLDPG26        ;** AUX SYMBOL BUFFER and set up H to this page.
3683 31-265 016 002                LBI 002                ;Set up register B as a number of bytes to move counter.
3684 31-267 106 013 021            CAL MOVEIT             ;Move the variable name into the FOR/NEXT STACK.
3685 31-272 106 055 010            CAL STOSYM             ;Store initial variable value in the VARIABLES TABLE.
3686 31-275 104 116 013            JMP NXTLIN             ;Continue with next line in user program buffer.
3687                    
3688                    
3689                    ;;; The label PARSEP SHOULD START AT 31 300
3690 31-300 066 176     PARSEP:    LLI 176                ;Load L with PARSER TOKEN storage location. Set
3691 31-302 076 000                LMI 000                ;The value indicating end of expression. Call the
3692 31-304 106 324 004            CAL PARSER             ;PARSER subroutine for final time for the expression.
3693 31-307 066 227                LLI 227                ;Change L to point to the ARITH STACK pointer.
3694 31-311 056 001                LHI \HB\OLDPG1         ;** Set H to the page of the ARITH STACK pointer.
3695 31-313 307                    LAM                    ;Fetch the ARITH STACK pointer value.
3696 31-314 074 230                CPI 230                ;Should indicate only one value (answer) in stack.
3697 31-316 053                    RTZ                    ;Exit with answer in FPACC if ARITH STACK is O.K.
3698 31-317 104 152 011            JMP SYNERR             ;Else have a syntax error!
3699                    	
3700                    	
3701                    ;;; THERE IS SOME BLANK ADDRESSES HERE 317-NEXT PAGE
3702                    	
3703                    
3704                    	ORG 032#000
3705 32-000 066 014     SQRX:      LLI 014                ;Load L with address of FP TEMP registers
3706 32-002 056 001                LHI \HB\OLDPG1         ;** Set H to page of FP TEMP. Move contents of FPACC
3707 32-004 106 255 022            CAL FSTORE             ;[Argument of SQR(X)] into FP TEMP for storage.
3708 32-007 066 126                LLI 126                ;Load L with MSW of FPACC
3709 32-011 307                    LAM                    ;Fetch the MSW into the accumulator
3710 32-012 240                    NDA                    ;Check the sign of the number in the FPACC
3711 32-013 160 217 032            JTS SQRERR             ;If number negative, cannot take square root
3712 32-016 150 247 006            JTZ CFALSE             ;If number is zero, return with zero value in FPACC
3713 32-021 066 017                LLI 017                ;Load L with address of FP TEMP Exponent register
3714 32-023 307                    LAM                    ;Fetch the Exponent value into the ACC
3715 32-024 240                    NDA                    ;Check sign of the Fxponent
3716 32-025 160 041 032            JTS NEGEXP             ;If Exponent less than zero, process negative Exponent
3717 32-030 032                    RAR                    ;If Exponent positive, rotate right to divide by two
3718 32-031 310                    LBA                    ;And save the result in CPU register B
3719 32-032 006 000                LAI 000                ;Clear the accumulator without disturbing Carry bit
3720 32-034 022                    RAL                    ;Rotate Carry bit into the ACC to save remainder
3721 32-035 370                    LMA                    ;Store the remainder back in FP TEMP Exponent reg.
3722 32-036 104 062 032            JMP SQREXP             ;Jump to continue processing
3723 32-041 310         NEGEXP:    LBA                    ;For negative Exponent, form two Is complement by
3724 32-042 250                    XRA                    ;Placing the positive value in CPU register B, clearing
3725 32-043 221                    SUB                    ;The accumulator, and then subtracting B from the ACC
3726 32-044 240                    NDA                    ;Clear the Carry bit after the complementing operation
3727 32-045 032                    RAR                    ;Rotate the value right to divide by two
3728 32-046 310                    LBA                    ;Save the result in CPU register B
3729 32-047 006 000                LAI 000                ;Clear the accumulator without disturbing Carry bit
3730 32-051 210                    ACA                    ;Add Carry bit to the accumulator as remainder
3731 32-052 370                    LMA                    ;Store the remainder back in FP TEMP Exponent reg
3732 32-053 150 057 032            JTZ NOREMD             ;If remainder was zero skip ahead. If not, increment the
3733 32-056 010                    INB                    ;Result of the divide by two ops to compen for negative
3734 32-057 250         NOREMD:    XRA                    ;Clear the accumulator
3735 32-060 221                    SUB                    ;Subtract the quotient of the divide by two op to
3736 32-061 310                    LBA                    ;Form two's complement and save the result in register B
3737 32-062 066 013     SQREXP:    LLI 013                ;Load L with address of TEMP register
3738 32-064 371                    LMB                    ;Store Fxponent quotient from above ops in TEMP
3739 32-065 066 004                LLI 004                ;Load L with address of FP registers containing +1.0
3740 32-067 046 034                LEI 034                ;Load E with address of SQR APPROX working registers
3741 32-071 335                    LDH                    ;Set D to same page as H
3742 32-072 016 004                LBI 004                ;Set up register B as a number of bytes to move counter
3743 32-074 106 013 021            CAL MOVEIT             ;Transfer value +1.0 into SQR APPROX registers
3744 32-077 106 247 006            CAL CFALSE             ;Now clear the FPACC registers
3745 32-102 066 044                LLI 044                ;Load L with address of LAST SQR APPROX temp regs.
3746 32-104 106 255 022            CAL FSTORE             ;Initialize the LAST SQR APPROX regs to value of zero
3747 32-107 066 034     SQRLOP:    LLI 034                ;Load L with address of SQR APPROX working registers
3748 32-111 106 244 022            CAL FLOAD              ;Transfer SQR APPROX into the FPACC
3749 32-114 066 014                LLI 014                ;Load L with address of SQR ARG storage registers
3750 32-116 106 266 022            CAL OPLOAD             ;Transfer SQR ARG into the FPOP
3751 32-121 106 322 021            CAL FPDIV              ;Divde SQR ARG by SQR APPROX (Fon-n X/A)
3752 32-124 066 034                LLI 034                ;Load L with address of SQR APPROX registers
3753 32-126 106 266 022            CAL OPLOAD             ;Transfer SQR APPROX into the FPOP
3754 32-131 106 211 020            CAL FPADD              ;Add to form value (X/A + A)
3755 32-134 066 127                LLI 127                ;Load L with address of FPACC Exponent register
3756 32-136 317                    LBM                    ;Fetch Exponent value into CPU register B
3757 32-137 011                    DCB                    ;Subtract one to effectively divide FPACC by two
3758 32-140 371                    LMB                    ;Restore to memory. (Now have ((X/A + A) /2)
3759 32-141 066 034                LLI 034                ;Load L with address of SQR APPROX registers
3760 32-143 106 255 022            CAL FSTORE             ;Store contents of FPACC as new SQR APPROX
3761 32-146 066 044                LLI 044                ;Load L with address of LAST SQR APPROX registers
3762 32-150 106 266 022            CAL OPLOAD             ;Transfer LAST SQR APPROX into the FPOP
3763 32-153 106 032 021            CAL FPSUB              ;Subtract (LAST SQR APPROX - SQR APPROX)
3764 32-156 066 127                LLI 127                ;Load L with address of FPACC Exponent
3765 32-160 307                    LAM                    ;Fetch the Exponent into the accumulator
3766 32-161 074 367                CPI 367                ;See if difference less than 2 to the minus ninth
3767                    ;;; The below is changed for PATCH 2
3768                    ;;; following is the original code
3769                    ;;;           JTS SQRCNV             ;If so, approximation has converged
3770                    ;;; Now is the new line
3771 32-163 104 364 032 	   JMP PATCH2
3772                    ;;;;           DCL
3773                    ;;;;           LAM
3774                    ;;;;           NDA
3775                    ;;;;           JTZ SQRCNV             ;THIS IS PATCH #2
3776 32-166 066 034     SQR1:	   LLI 034                ;Else, load L with address of SQR APPROX
3777 32-170 335                    LDH                    ;Set D to same page as H
3778 32-171 046 044                LEI 044                ;And E with address of LAST SQR APPROX
3779 32-173 016 004                LBI 004                ;Set up register B as a number of bytes to move counter
3780 32-175 106 013 021            CAL MOVEIT             ;Transfer SQR APPROX into LAST SQR APPROX
3781 32-200 104 107 032            JMP SQRLOP             ;Continue ops until approximation converges
3782 32-203 066 013     SQRCNV:    LLI 013                ;Load L with address of TEMP register. Fetch the
3783 32-205 307                    LAM                    ;Exponenent quotient store there into accumulator.
3784 32-206 066 037                LLI 037                ;Change L to point to SQR APPROX exponent.
3785 32-210 207                    ADM                    ;Add SQR APPROX exponent to quotient value.
3786 32-211 370                    LMA                    ;Store sum back in SQR APPROX Exponent register.
3787 32-212 066 034                LLI 034                ;Load L with address of SQR APPROX. Transfer the
3788 32-214 104 244 022            JMP FLOAD              ;SQR APPROX into FPACC as answer and exit.
3789 32-217 006 323     SQRERR:    LAI 323                ;Load ASCII code for letter S into the accumulator.
3790 32-221 026 321                LCI 321                ;Load ASCII code for letter Q into CPU register C.
3791 32-223 104 226 002            JMP ERROR              ;Display the SQuare root (SQ) error message.
3792                    ;;; above instruction starts at 223
3793                    ;;; some blank addresses available here.
3794                    	ORG 032#240
3795 32-240 066 064     RNDX:      LLI 064                ;Load L with address of SEED storage registers
3796 32-242 056 001                LHI \HB\OLDPG1         ;** Set H to page for floating point working registers
3797 32-244 106 244 022            CAL FLOAD              ;Transfer SEED into the FPACC
3798 32-247 066 050                LLI 050                ;Load L with address of random constant A
3799 32-251 106 266 022            CAL OPLOAD             ;Transfer random constant A into the FPOP
3800 32-254 106 046 021            CAL FPMULT             ;Multiply to form (SEED * A)
3801 32-257 066 060                LLI 060                ;Load L with address of random constant C
3802 32-261 106 266 022            CAL OPLOAD             ;Transfer random constant C into the FPOP
3803 32-264 106 211 020            CAL FPADD              ;Add to fom (SEED * A) + C
3804 32-267 066 064                LLI 064                ;Load L with address of SEED storage registers
3805 32-271 106 255 022            CAL FSTORE             ;Store I (SEED * A) + C] in former SEED registers
3806 32-274 066 127                LLI 127                ;Load L with address of FPACC Exponent register
3807 32-276 307                    LAM                    ;Fetch Exponent value into the accumulator
3808 32-277 024 020                SUI 020                ;Subtract 16 (decimal) to effectively divide by 65,536
3809 32-301 370                    LMA                    ;Now FPACC = [((SEED * A) + C)/65,536]
3810 32-302 106 000 020            CAL FPFIX              ;Convert floating to fixed point to obtain integer part
3811 32-305 066 123                LLI 123                ;Load L with address of FPACC Extension register
3812 32-307 076 000                LMI 000                ;Clear the FPACC Extension register
3813 32-311 066 127                LLI 127                ;Load L with address of FPACC Exponent
3814 32-313 076 000                LMI 000                ;Clear the FPACC Exponent register
3815 32-315 106 064 020            CAL FPFLT              ;Fetch INT(((SEED * A) + C)/65,536) into the FPACC
3816 32-320 066 127                LLI 127                ;Load L with address of FPACC Exponent
3817 32-322 307                    LAM                    ;Fetch FPACC Exponent into the accumulator
3818 32-323 004 020                ADI 020                ;Add 16 (decimal) to effectively multiply by 65,536
3819 32-325 370                    LMA                    ;(65,536 * INT[ ((SEED * A) + C)/65,5361) in FPACC
3820 32-326 066 064                LLI 064                ;Load L with address of [(SEED * A) + C]
3821 32-330 106 266 022            CAL OPLOAD             ;Transfer it into FPOP. Subtract FPACC to form
3822 32-333 106 032 021            CAL FPSUB              ;[(SEED * A) + C] MOD 65,536
3823 32-336 066 064                LLI 064                ;Load L with address of former SEED registers
3824 32-340 106 255 022            CAL FSTORE             ;Store SEED MOD 65,536 in place of [(SEED * A) + Cl
3825 32-343 066 127                LLI 127                ;Load L with address of FPACC Exponent
3826 32-345 307                    LAM                    ;Fetch FPACC Exponent into the ACC and subtract
3827 32-346 024 020                SUI 020                ;16 (decimal) to form (SEED MOD 65,536)/65,536
3828 32-350 370                    LMA                    ;So that random number in FPACC is between
3829 32-351 007                    RET                    ;0.0 and +1.0 and exit to calling routine
3830                    ;;; THE ABOVE RETURN SHOULD BE 32 351
3831                    	
3832                    
3833                    ;;; NOTE OPEN ADDRESSES TO END OF PAGE 32
3834                    
3835                    ;;; following is PATCH 2
3836                    	ORG 032#364
3837 32-364 160 203 032 PATCH2:	JTS SQRCNV
3838 32-367 061         	DCL
3839 32-370 307         	LAM
3840 32-371 240         	NDA
3841 32-372 150 203 032 	JTZ SQRCNV
3842 32-375 104 166 032 	JMP SQR1
3843                    ;;; The above jump should start at 32 375
3844                    	
3845                    
3846                    	;; PAGES 33 TO REMAINDER OF MEMORY
3847                    	;; OR START OF OPTIONAL ARRAY HANDLING
3848                    	;; ROUTINES USED AS USER PROGRAM BUFFER
3849                    
3850                    
3851                    
3852                    	;; OPTIONAL ARRAY ROUTINES ASSEMBLED FOR OPERATION
3853                    	;; IN THE UPPER 3 PAGES OF A 12K SYSTEM ARE LISTED HERE.
3854                    
3855                    	ORG 055#000
3856                    	
3857 55-000 066 126     PRIGH1:    LLI 126                ;Load L with address of the MSW in the FPACC
3858 55-002 056 001                LHI \HB\OLDPG1         ;** Set H to page of FPACC
3859 55-004 307                    LAM                    ;Fetch MSW of FPACC into the ACC.
3860 55-005 240                    NDA                    ;Test to see if value in FPACC is positive.
3861 55-006 160 136 055            JTS OUTRNG             ;If not, go display error message.
3862 55-011 106 000 020            CAL FPFIX              ;If O.K. then convert floating point to fixed point
3863 55-014 066 124                LLI 124                ;Load L with address of LSAL of converted value
3864 55-016 307                    LAM                    ;Fetch the LSW of the value into the ACC
3865 55-017 024 001                SUI 001                ;Subtract one from the value to establish proper
3866 55-021 002                    RLC                    ;Origin for future ops. Now rotate the value twice
3867 55-022 002                    RLC                    ;To effectively multiply by four. Save the
3868 55-023 320                    LCA                    ;Calculated result in CPU register C
3869 55-024 066 203                LLI 203                ;Load L with address of F/A STACK TEMP
3870 55-026 056 027                LHI \HB\OLDPG27        ;** Load H with page of F/A STACK TEMP
3871 55-030 307                    LAM                    ;Fetch the value into the accumulator
3872 55-031 054 377                XRI 377                ;Complement the value
3873 55-033 002                    RLC                    ;Rotate the value twice to multiply by four (the number
3874 55-034 002                    RLC                    ;Of bytes per entry in the ARRAY VARIABLES table).
3875 55-035 004 120                ADI 120                ;Add the starting address of the ARRAY VARIABLES
3876 55-037 056 027                LHI \HB\OLDPG27        ;** TABLE to forin pointer. Set page address in H.
3877 55-041 360                    LLA                    ;Point to the name in the ARRAY VARIABLES
3878 55-042 060                    INL                    ;Increment the pointer value twice to move over the
3879 55-043 060                    INL                    ;Name in the table and point to starting address for the
3880 55-044 307                    LAM                    ;Array values in the ARRAY VALUES table. Fetch this
3881 55-045 202                    ADC                    ;Address to the ACC. Now add in the figure calculated
3882 55-046 360                    LLA                    ;To reach desired subscripted data storage location. Set
3883 55-047 056 057                LHI \HB\OLDPG57        ;tt The pointer to that location. Load the floating point
3884 55-051 104 244 022            JMP FLOAD              ;Value stored there into the FPACC and exit to caller.
3885                    	
3886                    	
3887                    ;;; The label FUNAR2 SHOULD START AT 55-054
3888 55-054 066 202     FUNAR2:    LLI 202                ;Load L with address of TEMP COUNTER
3889 55-056 056 027                LHI \HB\OLDPG27        ;** Load H with page of counter
3890 55-060 317                    LBM                    ;Fetch the counter value
3891 55-061 010                    INB                    ;Increment the value
3892 55-062 371                    LMB                    ;Restore the value to memory
3893 55-063 026 002                LCI 002                ;Initialize register C to a value of two for future ops
3894 55-065 066 114                LLI 114                ;Load L with address of start of ARRAY VARIABLES
3895 55-067 056 027                LHI \HB\OLDPG27        ;** TABLE (less four). Set H to page of the table.
3896 55-071 106 230 007            CAL TABADR             ;Calculate address of start of next narne in table.
3897 55-074 036 026                LDI \HB\OLDPG26        ;** Load D with page of the SYMBOL BUFFER
3898 55-076 046 120                LEI 120                ;Set E to starting address of the SYMBOL BUFFER
3899 55-100 106 332 002            CAL STRCP              ;Compare name in ARRAY VARIABLES table to the
3900 55-103 150 124 055            JTZ FUNAR3             ;Contents of the SYMBOL BUFFER. If match, go set up
3901 55-106 066 202                LLI 202                ;Array token value. Else, reset L to address of TEMP
3902 55-110 056 027                LHI \HB\OLDPG27        ;** COUNTER. Set H to page of TEMP COUNTER.
3903 55-112 307                    LAM                    ;Fetch the counter value into the accumulator.
3904 55-113 066 075                LLI 075                ;Change L to number of arrays storage location.
3905 55-115 277                    CPM                    ;Compare number of entries checked against number
3906 55-116 110 054 055            JFZ FUNAR2             ;Possible. Keep searching table if not finished.
3907 55-121 104 172 007            JMP FAERR              ;If finished and no match than have F/A error condx.
3908 55-124 066 202     FUNAR3:    LLI 202                ;Load L with address of TEMP COUNTER
3909 55-126 056 027                LHI \HB\OLDPG27        ;** Load H with page of counter.
3910 55-130 250                    XRA                    ;Clear the accumulator. Subtract the value in the TEMP
3911 55-131 237                    SBM                    ;COUNTER from zero to obtain two's complement.
3912 55-132 370                    LMA                    ;Place this back in counter location as ARRAY TOKEN
3913 55-133 104 207 007            JMP FUNAR4             ;VALUE (negative). Go place the value on F/A STACK.
3914                    	
3915                    
3916                    ;;; The label OUTRNG STARTS AT 55 136
3917 55-136 006 317     OUTRNG:    LAI 317                ;Load the ASCII code for letter 0 into the accumulator
3918 55-140 026 322                LCI 322                ;Load the ASCII code for letter R into register C
3919 55-142 104 226 002            JMP ERROR              ;Go display Out of Range (OR) error message.
3920                    	
3921                    
3922                    
3923                    	
3924 55-145 106 252 010 ARRAY:     CAL RESTSY             ;Transfer contents of AUX SYMBOL BUFFER into the
3925 55-150 104 160 055            JMP ARRAY2             ;SYMBOL BUFFER. (Entry when have actual LET)
3926 55-153 066 202     ARRAY1:    LLI 202                ;Load L with address of SCAN pointer
3927 55-155 104 162 055            JMP ARRAY3             ;Proceed to process. (Entry point for IMPLIED LET)
3928 55-160 066 203     ARRAY2:    LLI 203                ;Load L with address of LET pointer
3929 55-162 056 026     ARRAY3:    LHI \HB\OLDPG26        ;** Set H to pointer page
3930 55-164 317                    LBM                    ;Fetch pointer to location where "(" found in statement
3931 55-165 010                    INB                    ;Line. Increment it to point to next character in the line.
3932 55-166 066 276                LLI 276                ;Load L with address of EVAL pointer and load it with
3933 55-170 371                    LMB                    ;The starting address for the EVAL routine
3934 55-171 066 206                LLI 206                ;Change L to address of ARRAY SETUP pointer
3935 55-173 371                    LMB                    ;And also store address in that location
3936 55-174 066 206     ARRAY4:    LLI 206                ;Load L with address of ARRAY SETUP pointer
3937 55-176 106 240 002            CAL GETCHR             ;Fetch character pointed to by ARRAY SETUP pntr
3938 55-201 074 251                CPI 251                ;See if character is ")" ? If so, then have located
3939 55-203 150 225 055            JTZ ARRAY5             ;End of the subscript. If not, reset
3940 55-206 066 206                LLI 206                ;to the ARRAY SETUP pointer. Increment the
3941 55-210 106 003 003            CAL LOOP               ;Pointer and test for the end of the statement line.
3942 55-213 110 174 055            JFZ ARRAY4             ;If not end of line, continue looking for right paren.
3943 55-216 006 301                LAI 301                ;If reach end of line before right parenthesis than load
3944 55-220 026 306                LCI 306                ;ASCII code for letters A and F and display message
3945 55-222 104 226 002            JMP ERROR              ;Indicating Array Forrnat (AF) error condition
3946 55-225 066 206     ARRAY5:    LLI 206                ;Load L with address of ARRAY SETUP pointer
3947 55-227 317                    LBM                    ;Fetch pointer (pointing to ")"sign) into register B
3948 55-230 011                    DCB                    ;Decrement it to move back to end of subscript number
3949 55-231 066 277                LLI 277                ;Load L with address of EVAL FINISH pointer location
3950 55-233 371                    LMB                    ;Place the pointer value in the EVAL FINISH pointer
3951 55-234 066 207                LLI 207                ;Load L with address of LOOP COUNTER
3952 55-236 076 000                LMI 000                ;Initialize LOOP COUNTER to value of zero
3953 55-240 066 207     ARRAY6:    LLI 207                ;Load L with address of LOOP COUNTER
3954 55-242 056 026                LHI \HB\OLDPG26        ;** Load H with page of LOOP COUNTER
3955 55-244 317                    LBM                    ;Fetch the counter value
3956 55-245 010                    INB                    ;Increment it
3957 55-246 371                    LMB                    ;Restore the counter value to memory
3958 55-247 026 002                LCI 002                ;Set up counter in register C for future ops
3959 55-251 066 114                LLI 114                ;Load L with address of start of ARRAY VARIABLES
3960 55-253 056 027                LHI \HB\OLDPG27        ;** Table less four). Set H to page of the table.
3961 55-255 106 230 007            CAL TABADR             ;Calculate the address of next entry in the table
3962 55-260 046 120                LEI 120                ;Load register E with starting address of SYMBOL BUFF
3963 55-262 036 026                LDI \HB\OLDPG26        ;** Set D to page of SYMBOL BUFFER
3964 55-264 106 332 002            CAL STRCP              ;Compare entry in table against contents of SYMBOL BF
3965 55-267 150 312 055            JTZ ARRAY7             ;If match, have found array naine in the table.
3966 55-272 066 207                LLI 207                ;Else, set L to address of the LOOP COUNTER
3967 55-274 056 026                LHI \HB\OLDPG26        ;** Set H to page of the LOOP COUNTER
3968 55-276 307                    LAM                    ;Fetch the counter value to the ACC
3969 55-277 066 075                LLI 075                ;Change L to the counter containing number of arrays
3970 55-301 056 027                LHI \HB\OLDPG27        ;** Set H to the proper page
3971 55-303 277                    CPM                    ;Compare number of arrays to count in LOOP CNTR
3972 55-304 110 240 055            JFZ ARRAY6             ;If more entries in the table, continue looking for match
3973 55-307 104 172 007            JMP FAERR              ;If no matching name in table then have an error condx.
3974 55-312 106 224 003 ARRAY7:    CAL EVAL               ;Call subroutine to evaluate subscript expression
3975 55-315 106 000 020            CAL FPFIX              ;Convert the subscript value obtained to fixed forrnat
3976 55-320 066 207                LLI 207                ;Load L with address of LOOP COUNTER
3977 55-322 056 026                LHI \HB\OLDPG26        ;** Set H to page of the LOOP COUNTER
3978 55-324 317                    LBM                    ;Fetch the value in the LOOP COUNTER into the ACC
3979 55-325 026 002                LCI 002                ;Set up counter in register C future ops
3980 55-327 066 114                LLI 114                ;Load L with address of ARRAY VARIABLES
3981 55-331 056 027                LHI \HB\OLDPG27        ;** Table less four). Set H to page of the table.
3982 55-333 106 230 007            CAL TABADR             ;Calculate the address of entry in the table
3983 55-336 060                    INL                    ;Advance the ARRAY VARIABLES table pointer twice
3984 55-337 060                    INL                    ;To advance pointer over array name.
3985 55-340 327                    LCM                    ;Fetch array base address in ARRAY VALUES table
3986 55-341 066 124                LLI 124                ;Load L with address of subscript value
3987 55-343 056 001                LHI \HB\OLDPG1         ;** Set H to page of subscript value
3988 55-345 307                    LAM                    ;Fetch the subscript value into the accumulator
3989 55-346 024 001                SUI 001                ;Subtract one from subscript value to allow for zero
3990 55-350 002                    RLC                    ;Origin. Now multiply by four
3991 55-351 002                    RLC                    ;Using rotates (number of bytes required for each entry
3992 55-352 202                    ADC                    ;In the ARRAY VALUES table). Add in base address to
3993 55-353 066 204                LLI 204                ;The calculated value to form final address in the
3994 55-355 056 027                LHI \HB\OLDPG27        ;** ARRAY VALUES table. Now set H & L to TEMP
3995 55-357 370                    LMA                    ;ARRAY ELEMENT storage location & store the addr.
3996 55-360 066 201                LLI 201                ;Change L to point to ARRAY FLAG
3997 55-362 076 377                LMI 377                ;Set the ARRAY FLAG for future use
3998 55-364 007                    RET                    ;Exit to calling routine
3999                    
4000                    	
4001                    ;;; The label DIM SHOULD START AT 55 365
4002 55-365 106 255 002 DIM:       CAL CLESYM             ;Initialize the SYMBOL BUFFER to cleared condition
4003 55-370 066 202                LLI 202                ;Load L with address of SCAN pointer
4004 55-372 317                    LBM                    ;Fetch SCAN pointer value into register B
4005 55-373 010                    INB                    ;Add one to the SCAN pointer value
4006 55-374 066 203                LLI 203                ;Change L to DIM pointer (formerly TOKEN) storage
4007 55-376 371                    LMB                    ;Store the updated SCAN pointer as the DIM pointer
4008 55-377 066 203     DIM1:      LLI 203                ;Load L with the address of DIM pointer storage location
4009 56-001 106 240 002            CAL GETCHR             ;Fetch a character from the line input buffer
4010 56-004 150 017 056            JTZ DIM2               ;If character fetched is a space, ignore it
4011 56-007 074 250                CPI 250                ;Else see if character is "(" left parenthesis
4012 56-011 150 032 056            JTZ DIM3               ;If so, should have ARRAY VARIABLE naine in buffer
4013 56-014 106 310 002            CAL CONCTS             ;If not, append the character to the SYMBOL BUFFER
4014 56-017 066 203     DIM2:      LLI 203                ;Load L with the address of DIM pointer stomge location
4015 56-021 106 003 003            CAL LOOP               ;Increment the pointer and see if end of line
4016 56-024 110 377 055            JFZ DIM1               ;If not end of line, fetch next character
4017 56-027 104 337 056            JMP DIMERR             ;Else have a DIMension error condition
4018 56-032 066 206     DIM3:      LLI 206                ;Load L with address of ARRAY pointer storage loc
4019 56-034 076 000                LMI 000                ;Initialize ARRAY pointer to starting value of zero
4020 56-036 066 206     DIM4:      LLI 206                ;Load L with address of ARRAY pointer storage loc
4021 56-040 056 026                LHI \HB\OLDPG26        ;** Set H to page of ARRAY pointer storage location
4022 56-042 307                    LAM                    ;Fetch value in ARRAY pointer to ACC (effectively
4023 56-043 002                    RLC                    ;Represents number of arrays defined in pgm). Rotate
4024 56-044 002                    RLC                    ;Left twice to multiply by four (niunber of bytes per
4025 56-045 004 114                ADI 114                ;entry in ARRAY VARIABLES table). Add to base
4026 56-047 056 027                LHI \HB\OLDPG27        ;** Address to form pointer to ARRAY VARIA.BLES
4027 56-051 360                    LLA                    ;Table and set up H & L as the memory pointer.
4028 56-052 046 120                LEI 120                ;Load E with starting address of the SYMBOL BUFFER
4029 56-054 036 026                LDI \HB\OLDPG26        ;** Load D with the page address of the SYMBOL BUFF
4030 56-056 106 332 002            CAL STRCP              ;Compare contents of SYMBOL BF to entry in ARRAY
4031 56-061 150 301 056            JTZ DIM9               ;VARIABLES table. If same, have duplicate array name.
4032 56-064 066 206                LLI 206                ;Else, load L with address of ARRAY pointer storage
4033 56-066 056 026                LHI \HB\OLDPG26        ;** Load H with page of ARRAY pointer storage
4034 56-070 317                    LBM                    ;Fetch the ARRAY pointer value to register B
4035 56-071 010                    INB                    ;Increment the value
4036 56-072 371                    LMB                    ;Restore it to ARRAY pointer storage location
4037 56-073 066 075                LLI 075                ;Change L to number of arrays storage location
4038 56-075 056 027                LHI \HB\OLDPG27        ;** Set H to page of the number of arrays stomge loc
4039 56-077 307                    LAM                    ;Fetch the number of arrays value to the ACC
4040 56-100 011                    DCB                    ;Restore B to previous count
4041 56-101 271                    CPB                    ;Compare number of arrays tested against nr defined
4042 56-102 110 036 056            JFZ DIM4               ;If not equal, continue searching ARRAY VARIABLES
4043 56-105 066 075                LLI 075                ;Table. When table searched with no match, then must
4044 56-107 056 027                LHI \HB\OLDPG27        ;** Append naine to table. First set pointer to number
4045 56-111 317                    LBM                    ;Of arrays storage location. Fetch that value and
4046 56-112 010                    INB                    ;Add one to account for new name being added.
4047 56-113 371                    LMB                    ;Restore the updated value back to memory.
4048 56-114 066 076                LLI 076                ;Change pointer to ARRAY TEMP pointer storage
4049 56-116 371                    LMB                    ;Store pointer to current array in ARRAY TEMP too.
4050 56-117 066 206                LLI 206                ;Load L with address of ARRAY pointer stomge loc.
4051 56-121 056 026                LHI \HB\OLDPG26        ;** Set H to page of ARRAY pointer storage location
4052 56-123 371                    LMB                    ;And update it also for new array being added.
4053 56-124 307                    LAM                    ;Fetch the current ARRAY pointer value to the ACC
4054 56-125 002                    RLC                    ;Multiply it times four by performing two rotate left
4055 56-126 002                    RLC                    ;Operations and add it to base value to form address in
4056 56-127 004 114                ADI 114                ;The ARRAY VARIABLES table. Place the low part
4057 56-131 340                    LEA                    ;Of this calculated address value into register E.
4058 56-132 036 027                LDI \HB\OLDPG27        ;** Set register D to the page of the table.
4059 56-134 066 120                LLI 120                ;Load L with the start of the SYMBOL BUFFER
4060 56-136 056 026                LHI \HB\OLDPG26        ;** Load H with the page of the SYMBOL BUFFER
4061 56-140 106 046 012            CAL MOVEC              ;Move the array name from the SYMBOL BUFFER to
4062 56-143 106 255 002            CAL CLESYM             ;The ARRAY VARIABLES table. Then clear the
4063 56-146 066 203                LLI 203                ;SYMBOL BUFFER. Reset L to the DIM pointer storage
4064 56-150 056 026                LHI \HB\OLDPG26        ;** Location. Set H to the DIM pointer page.
4065 56-152 317                    LBM                    ;Fetch the pointer value (points to "(" part of DIM
4066 56-153 010                    INB                    ;Statement). Increment the pointer to next character in
4067 56-154 066 204                LLI 204                ;The line input buffer. Cbange L to DIMEN pointer.
4068 56-156 371                    LMB                    ;Store the updated DIM pointer in DIMEN storage loc.
4069 56-157 066 204     DIM5:      LLI 204                ;Set L to DIMEN pointer storage location
4070 56-161 106 240 002            CAL GETCHR             ;Fetch character in line input buffer
4071 56-164 150 211 056            JTZ DIM6               ;Ignore character for space
4072 56-167 074 251                CPI 251                ;If not space, see if character is right parenthesis
4073 56-171 150 224 056            JTZ DIM7               ;If yes, process DIMension size (array length)
4074 56-174 074 260                CPI 260                ;If not, see if character is a valid decimal number
4075 56-176 160 337 056            JTS DIMERR             ;If not valid number, have DIMension error condition
4076 56-201 074 272                CPI 272                ;Continue testing for valid decitnal number
4077 56-203 120 337 056            JFS DIMERR             ;If not valid number, then DIMension error condition
4078 56-206 106 310 002            CAL CONCTS             ;If valid decirnal number, append digit to SYMBOL BF
4079 56-211 066 204     DIM6:      LLI 204                ;Set L to DIMEN pointer storage location
4080 56-213 106 003 003            CAL LOOP               ;Advance the pointer value and check for end of the line
4081 56-216 110 157 056            JFZ DIM5               ;If not end of line, continue fetching DIMension size
4082 56-221 104 337 056            JMP DIMERR             ;If end of line before right parenthesis, have error condx.
4083 56-224 066 120     DIM7:      LLI 120                ;Load L with address of start of SYMBOL BUFFER
4084 56-226 056 026                LHI \HB\OLDPG26        ;** Load H with page of SYMBOL BUFFER. (Now
4085 56-230 106 044 023            CAL DINPUT             ;Contains DIMension size.) Convert buffer to floating
4086 56-233 106 000 020            CAL FPFIX              ;Point number and then reformat to fixed point.
4087 56-236 066 124                LLI 124                ;Load L with address of LSW of fixed point number
4088 56-240 307                    LAM                    ; And fetch the low order byte of the nr into the ACC
4089 56-241 002                    RLC                    ;Rotate it left two tirnes to multiply it by four (the
4090 56-242 002                    RLC                    ;Number of bytes required to store a floating point nr).
4091 56-243 320                    LCA                    ;Store this value in CPU register C temporarily
4092 56-244 066 076                LLI 076                ;Set L to ARRAY TEMP storage location.
4093 56-246 056 027                LHI \HB\OLDPG27        ;** Set H to ARRAY TEMP pointer page.
4094 56-250 307                    LAM                    ;Fetch the value in ARRAY TEMP (points to ARRAY
4095 56-251 024 001                SUI 001                ;VARIABLES table). Subtract one from the pointer
4096 56-253 002                    RLC                    ;Value and multiply the result by four using rotate left
4097 56-254 002                    RLC                    ;Instructions. Add this value to a base address
4098 56-255 004 122                ADI 122                ;(Augmented by two) to point to ARRAY VALUES
4099 56-257 360                    LLA                    ;Pointer storage location in the ARRAY VARIABLES
4100 56-260 056 027                LHI \HB\OLDPG27        ;Table and set the pointer up in registers H & L.
4101 56-262 317                    LBM                    ;Fetch the starting address in the ARRAY VALUES
4102 56-263 004 004                ADI 004                ;Table for the previous array into register B. Now add
4103 56-265 360                    LLA                    ;Four to the ARRAY VARIABLES table pointer to
4104 56-266 301                    LAB                    ;Point to curront ARRAY VALUES starting address.
4105 56-267 202                    ADC                    ;Add the previous array starting address plus number of
4106 56-270 370                    LMA                    ;Bytes required and store as starting loc for next array
4107 56-271 066 204     DIM8:      LLI 204                ;Set L to address of DIMEN pointer storage location
4108 56-273 056 026                LHI \HB\OLDPG26        ;** Set H to page of DIMEN pointer
4109 56-275 317                    LBM                    ;Fetch pointer value (points to ") " in line)
4110 56-276 066 203                LLI 203                ;Change L to DIM pointer storage location
4111 56-300 371                    LMB                    ;Store former DIMEN value back in DIM pointer
4112 56-301 066 203     DIM9:      LLI 203                ;Load L with address of DIM pointer storage location
4113 56-303 106 240 002            CAL GETCHR             ;Fetch a character from the line input buffer
4114 56-306 074 254                CPI 254                ;See if character is a comma (,) sign
4115 56-310 150 326 056            JTZ DIM10              ;If yes, have another array being defined on the line
4116 56-313 066 203                LLI 203                ;If not, reset L to the DIM pointer
4117 56-315 106 003 003            CAL LOOP               ;Increment the pointer and see if end of the line
4118 56-320 110 301 056            JFZ DIM9               ;If not end of the line, keep looking for a comma
4119 56-323 104 116 013            JMP NXTLIN             ;Else exit the DIM statement routine to continue pgm
4120 56-326 066 203     DIM10:     LLI 203                ;Set L to DIM pointer storage location
4121 56-330 317                    LBM                    ;Fetch pointer value (points to comma sign just found)
4122 56-331 066 202                LLI 202                ;Load L with address of SCAN pointer storage location
4123 56-333 371                    LMB                    ;Place DIM pointer into the-SCAN pointer
4124 56-334 104 365 055            JMP DIM                ;Continue processing DIM statement line for next array
4125 56-337 006 304     DIMERR:    LAI 304                ;On error condition, load ASCII code for letter D in ACC
4126 56-341 026 305                LCI 305                ;And ASCII code for letter E in CPU register C
4127 56-343 104 226 002            JMP ERROR              ;Go display the Dirnension Error (DE) message.
4128                    
4129                    	
4130                    
4131                    
4132                    
4133                    
Symbol Count: 381
    Symbol  Oct Val  DecVal
    ------  -------  ------
  ENDPGRAM      055     45
  BGNPGRAM      033     27
    OLDPG1    1 000    256
   OLDPG26   26 000   5632
   OLDPG27   27 000   5888
   OLDPG57   57 000  12032
      save      100     64
      load      100     64
      CINP      103     67
    CPRINT      116     78
    STATST      117     79
     UDEFX      135     93
    SYNTAX    2 000    512
    SYNTX1    2 015    525
    SYNTX2    2 044    548
    SYNTX3    2 061    561
    SYNTX4    2 067    567
    SYNTX5    2 124    596
    SYNTXL    2 137    607
    SYNTX6    2 171    633
    SYNTX7    2 210    648
    SYNTX8    2 215    653
    BIGERR    2 222    658
     ERROR    2 226    662
    GETCHR    2 240    672
    CLESYM    2 255    685
    CONCTA    2 264    692
    CONCTN    2 276    702
    CONCTS    2 310    712
    CONCT1    2 314    716
    CONCTE    2 327    727
     STRCP    2 332    730
    STRCPL    2 344    740
    STRCPE    2 356    750
    STRCPC    2 370    760
       ADV    2 377    767
      LOOP    3 003    771
     STRIN    3 014    780
    STRIN1    3 016    782
    NOTDEL    3 045    805
    STRINF    3 102    834
     SUBHL    3 113    843
     TEXTC    3 121    849
    TEXTCL    3 125    853
      CRLF    3 141    865
       DEC    3 164    884
     DECNO    3 172    890
    INDEXB    3 174    892
      ECHO    3 202    898
    CINPUT    3 221    913
      EVAL    3 224    916
     SCAN1    3 254    940
     SCAN2    3 300    960
     SCAN3    3 345    997
    SCANFN    3 351   1001
     SCAN4    3 357   1007
     SCAN5    3 373   1019
     SCAN6    4 007   1031
     SCAN7    4 033   1051
     SCAN8    4 064   1076
     SCAN9    4 100   1088
    SCAN11    4 143   1123
    SCAN12    4 206   1158
    SCAN13    4 251   1193
    SCAN14    4 260   1200
    SCAN15    4 267   1207
    SCAN16    4 276   1214
    SCAN10    4 301   1217
    PARSER    4 324   1236
    PARNUM    4 356   1262
    NOEXPO    5 005   1285
    LOOKUP    5 033   1307
    LOOKU1    5 061   1329
    LOOKU2    5 111   1353
    LOOKU4    5 201   1409
     PARSE    5 231   1433
    PARSE1    5 307   1479
    PARSE2    5 332   1498
    FPOPER    5 364   1524
    PARNER    6 104   1604
        LT    6 121   1617
        EQ    6 136   1630
        GT    6 153   1643
        LE    6 173   1659
        GE    6 213   1675
        NE    6 230   1688
     CTRUE    6 242   1698
     FPONE    6 242   1698
    CFALSE    6 247   1703
     AD4DE    6 256   1710
    INTEXP    6 263   1715
    MULOOP    6 341   1761
    DVLOOP    6 362   1778
    PRIGHT    7 003   1795
    FUNARR    7 100   1856
    FUNAR1    7 115   1869
     FAERR    7 172   1914
    FUNAR4    7 207   1927
    TABADR    7 230   1944
    TABAD1    7 231   1945
      INTX    7 243   1955
      INT1    7 327   2007
      INT2    7 341   2017
      ABSX    7 346   2022
      SGNX    7 360   2032
      CHRX    7 377   2047
      TABX   10 017   2063
      TAB1   10 022   2066
      TABC   10 042   2082
    TABLOP   10 045   2085
    STOSYM   10 055   2093
    STOSY1   10 100   2112
    STOSY2   10 126   2134
    STOSY3   10 156   2158
    STOSY5   10 227   2199
    SAVESY   10 240   2208
    RESTSY   10 252   2218
    MOVECP   10 261   2225
      EXEC   10 266   2230
     EXEC1   10 275   2237
      LIST   10 333   2267
    NOLIST   10 354   2284
    SCRLOP   11 060   2352
     NOSCR   11 071   2361
    SYNERR   11 152   2410
    SYNTOK   11 161   2417
    GETAUX   11 177   2431
    GETAU0   11 211   2441
    GETAU1   11 242   2466
    GETAU2   11 267   2487
    PATCH3   11 307   2503
    NOTEND   11 336   2526
    NOSAME   12 005   2565
     MOVEC   12 046   2598
    MOVEPG   12 050   2600
    CONTIN   12 073   2619
    GETCHP   12 123   2643
    REMOVE   12 144   2660
    REMOV1   12 167   2679
    INSERT   12 205   2693
    INSER1   12 231   2713
    INSER3   12 255   2733
    INCLIN   12 255   2733
    CPHLDE   12 277   2751
     ADBDE   12 305   2757
     CTRLC   12 313   2763
    FINERR   12 322   2770
    FINER1   12 351   2793
     DVERR   12 357   2799
    FIXERR   12 366   2806
    NUMERR   12 375   2813
     INSTR   13 012   2826
    INSTR1   13 016   2830
    INSTR2   13 061   2865
     ADVDE   13 064   2868
       RUN   13 070   2872
    NXTLIN   13 116   2894
    SAMLIN   13 156   2926
    DIRECT   13 211   2953
     PRINT   13 345   3045
    PRINT1   13 366   3062
    PRINT2   14 002   3074
    PRINT3   14 043   3107
    PRINT4   14 075   3133
    PRINT5   14 114   3148
    PRINT6   14 125   3157
     QUOTE   14 203   3203
    QUOTE1   14 220   3216
    QUOTER   14 246   3238
    QUOTE2   14 263   3251
    PFPOUT   14 314   3276
      ZERO   14 336   3294
      FRAC   14 350   3304
    PCOMMA   14 357   3311
     PCOM1   15 003   3331
      LET0   15 013   3339
       LET   15 031   3353
      LET1   15 042   3362
      LET2   15 053   3371
      LET3   15 113   3403
      LET4   15 122   3410
    LETERR   15 132   3418
      LET5   15 141   3425
      GOTO   15 174   3452
     GOTO1   15 211   3465
     GOTO2   15 240   3488
     GOTO3   15 250   3496
     GOTO4   15 261   3505
     GOTO5   15 270   3512
     GOTO6   15 315   3533
     GOTO7   15 340   3552
    GOTOER   16 020   3600
        IF   16 027   3607
     IFERR   16 073   3643
       IF1   16 102   3650
       IF2   16 143   3683
       IF3   16 166   3702
       IF4   16 200   3712
     GOSUB   16 236   3742
    GOSUB1   16 255   3757
    RETURN   16 304   3780
    GOSERR   16 347   3815
    RETERR   16 356   3822
     INPUT   16 365   3829
    INPUT1   16 377   3839
    INPUT2   17 037   3871
    INPUT3   17 042   3874
    INPUT4   17 063   3891
    INPUTX   17 104   3908
    INPUTN   17 140   3936
       FP0   17 157   3951
       FOR   17 164   3956
    FORERR   17 243   4003
      FOR1   17 252   4010
      FOR2   17 266   4022
      FOR3   17 310   4040
      FOR4   17 323   4051
     FPFIX   20 000   4096
    FPFIXL   20 033   4123
    FPZERO   20 051   4137
     FPFLT   20 064   4148
    FPNORM   20 066   4150
    NOEXC0   20 100   4160
    ACZERT   20 120   4176
     LOOK0   20 124   4180
    ACNONZ   20 143   4195
    ACCSET   20 166   4214
    RESIGN   20 175   4221
    FPCOMP   20 202   4226
     FPADD   20 211   4233
     MOVOP   20 222   4242
    NONZAC   20 235   4253
    CKEQEX   20 242   4258
    SKPNEG   20 264   4276
    LINEUP   20 303   4291
    MORACC   20 313   4299
    SHIFT0   20 327   4311
     MOROP   20 330   4312
    SHACOP   20 341   4321
    SHLOOP   20 374   4348
    FSHIFT   21 002   4354
    BRING1   21 007   4359
    MOVEIT   21 013   4363
     FPSUB   21 032   4378
    FPMULT   21 046   4390
    ADDEXP   21 051   4393
    SETMCT   21 062   4402
    MULTIP   21 066   4406
    EXMLDV   21 146   4454
    CKSIGN   21 166   4470
    CLRNEX   21 175   4477
    CLROPL   21 203   4483
    CLRNX1   21 207   4487
    OPSGNT   21 230   4504
    NEGFPA   21 251   4521
    ADOPPP   21 270   4536
    MROUND   21 302   4546
    CROUND   21 307   4551
     FPDIV   21 322   4562
    SUBEXP   21 334   4572
    SETDCT   21 345   4581
    DIVIDE   21 351   4585
      NOGO   21 376   4606
    QUOROT   21 377   4607
    DVEXIT   22 070   4664
    SETSUB   22 101   4673
     ADDER   22 127   4695
    ADDMOR   22 130   4696
    COMPLM   22 150   4712
    MORCOM   22 155   4717
    ROTATL   22 177   4735
      ROTL   22 200   4736
    ROTATR   22 211   4745
      ROTR   22 212   4746
    SUBBER   22 223   4755
    SUBTRA   22 224   4756
     FLOAD   22 244   4772
    FSTORE   22 255   4781
    OPLOAD   22 266   4790
     SETIT   22 272   4794
    FACXOP   22 277   4799
    SAVEHL   22 317   4815
    RESTHL   22 337   4831
    SWITCH   22 356   4846
    GETINP   22 365   4853
      NOT0   23 010   4872
    INDEXC   23 036   4894
    DINPUT   23 044   4900
    CLRNX2   23 055   4909
    CLRNX3   23 067   4919
    NINPUT   23 115   4941
    NOTPLM   23 120   4944
    PERIOD   23 201   4993
    FNDEXP   23 221   5009
    EXPINP   23 241   5025
    NOEXPS   23 244   5028
    ENDINP   23 311   5065
    FININP   23 327   5079
    POSEXP   23 365   5109
     EXPOK   24 000   5120
     FPX10   24 010   5128
    MINEXP   24 033   5147
     FPD10   24 033   5147
    DECBIN   24 056   5166
     FPOUT   24 165   5237
    OUTNEG   24 207   5255
    AHEAD1   24 220   5264
    OUTFLT   24 253   5291
    OUTFIX   24 271   5305
    DECEXT   24 277   5311
    DECREP   24 327   5335
    DECEXD   24 336   5342
    DECOUT   24 360   5360
    COMPEN   25 010   5384
    OUTDIG   25 032   5402
    OUTDGS   25 045   5413
    OUTZER   25 104   5444
    OUTDGX   25 105   5445
    DECRDG   25 112   5450
    PUSHIT   25 131   5465
    CKDECP   25 137   5471
    NODECP   25 154   5484
    ZERODG   25 165   5493
    OUTX10   25 223   5523
    EXPOUT   25 300   5568
    EXOUTN   25 324   5588
    AHEAD2   25 333   5595
     SUB12   25 341   5601
    TOMUCH   25 353   5611
    PATCH1   30 000   6144
      NEXT   30 013   6155
     NEXT1   30 030   6168
     NEXT2   30 045   6181
     NEXT3   30 071   6201
    FORNXT   30 121   6225
     NEXT4   30 130   6232
     NEXT5   30 300   6336
     NEXT6   30 351   6377
     NEXT7   31 005   6405
     NEXT8   31 027   6423
     NEXT9   31 042   6434
    NEXT10   31 143   6499
    NEXT11   31 170   6520
    NEXT12   31 177   6527
    BACKSP   31 217   6543
      FOR5   31 246   6566
    PARSEP   31 300   6592
      SQRX   32 000   6656
    NEGEXP   32 041   6689
    NOREMD   32 057   6703
    SQREXP   32 062   6706
    SQRLOP   32 107   6727
      SQR1   32 166   6774
    SQRCNV   32 203   6787
    SQRERR   32 217   6799
      RNDX   32 240   6816
    PATCH2   32 364   6900
    PRIGH1   55 000  11520
    FUNAR2   55 054  11564
    FUNAR3   55 124  11604
    OUTRNG   55 136  11614
     ARRAY   55 145  11621
    ARRAY1   55 153  11627
    ARRAY2   55 160  11632
    ARRAY3   55 162  11634
    ARRAY4   55 174  11644
    ARRAY5   55 225  11669
    ARRAY6   55 240  11680
    ARRAY7   55 312  11722
       DIM   55 365  11765
      DIM1   55 377  11775
      DIM2   56 017  11791
      DIM3   56 032  11802
      DIM4   56 036  11806
      DIM5   56 157  11887
      DIM6   56 211  11913
      DIM7   56 224  11924
      DIM8   56 271  11961
      DIM9   56 301  11969
     DIM10   56 326  11990
    DIMERR   56 337  11999
