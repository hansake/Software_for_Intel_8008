AS8 assembler for intel 8008, t.e.jones Version 1.0
Options: listfile=1 debug=0 binaryout=1 singlelist=0
octalnums=1 markascii=1
Infile=sc1.asm
Assembly Performed: Fri Sep 24 17:19:24 2021


Line Addr.  CodeBytes   Source Line
---- ------ ----------- ----------------------------------
   1                    ;;; This is the Scelbi Basic Program from 1974 known as
   2                    ;;; SCELBAL by Mark G. Arnold (MGA) and Nat Wadsworth  
   3                    ;;;
   4                    ;;;  Copyright 1975 Scelbi Computer Consulting, Inc.
   5                    ;;;  All rights reserved
   6                    ;;;
   7                    ;;; MGA gives permission to use SCELBAL for 
   8                    ;;; educational, historical, non-commercial purposes.
   9                    ;;; Versions of this have been circulating on the web since
  10                    ;;; about 2000; this version is authorized by MGA (Mar 2012)
  11                    ;;; with the understanding no warranty is expressed or implied.
  12                    ;;; As stated in the original, "no responsibility is assumed for
  13                    ;;; for inaccuracies or for the success or failure of
  14                    ;;; various applications to which the information herein
  15                    ;;; may be applied."
  16                    ;;; 
  17                    ;;; SCELBAL is the only open-source, floating-point 
  18                    ;;; high-level language ever implemented on Intel's first
  19                    ;;; general-purpose microprocessor, the 8008.  It was
  20                    ;;; published in book form:
  21                    ;;;
  22                    ;;;  SCELBAL: A Higher-Level Language for 8008/8080 Systems
  23                    ;;;
  24                    ;;; (Tiny BASIC only used 16-bit integers; the MCM\70
  25                    ;;; was a closed system; calculators implemented with 8008
  26                    ;;; were floating-point, but not high-level.)
  27                    ;;;
  28                    ;;; This version is modified to assemble with the
  29                    ;;; as8 assembler (using the -octal option) 
  30                    ;;; for the Intel 8008 by Thomas E. Jones.
  31                    ;;; This current form is made up non-relocatable so that
  32                    ;;; locations of all code and data is identical to the
  33                    ;;; original SCELBAL documents and patches.  It should be
  34                    ;;; reasonable after debugging code to convert this to a
  35                    ;;; relocatable and ROMable code with variables in RAM.
  36                    ;;; This code originates from a version made by 
  37                    ;;;
  38                    ;;;    Steve Loboyko in 2001.
  39                    ;;;
  40                    ;;; This version has all 3 patches for SCELBAL (the two
  41                    ;;; pasted in the original manual, and a third which was
  42                    ;;; written in SCELBAL UPDATE publication, as well as
  43                    ;;; a couple changes to constants which didn't actually
  44                    ;;; require a patch, just changes to bytes of data or
  45                    ;;; arguments to an instruction--one of these (Tucker) was 
  46                    ;;; incorrect and restored to original by MGA March 2012).
  47                    ;;; 
  48                    ;;; This comment must be incorporated with any version of SCELBAL
  49                    ;;; downloaded, distributed, posted or disemenated.
  50                    	
  51                    
  52                    ENDPGRAM:  EQU 055       ;MGA 4/10/12 as in orig; for his ROMable Loboyko said 077       [077]
  53                    BGNPGRAM:  EQU 033       ;MGA 4/10/12 as in orig; for his ROMable Loboyko said 044       [044]
  54                    	
  55                    ;;; Here are labels originally attempting to make the code
  56                    ;;; relocatable.  These 4 pages contain variable data
  57                    ;;; which needs to be relocated from ROM to RAM.
  58                    ;;; I can't vouch for ALL references to these pages in
  59                    ;;; the code being switched to these labels, but they
  60                    ;;; seem to be.
  61                    	
  62                    OLDPG1:		EQU	001#000
  63                    OLDPG26:	EQU	026#000
  64                    OLDPG27:	EQU	027#000
  65                    OLDPG57:	EQU	057#000
  66                    
  67                    
  68                    ;;; Page zero will contain the I/O Routines.  These are actually
  69                    ;;; just as suggested by Scelbal Manual for Serial I/O.
  70                    
  71                    	ORG 000#100		; save a bit of space before this
  72                    	
  73                    save:	
  74 00-100 104 266 010 load:	JMP EXEC		; By default, save and load isn't implemented.
  75                    
  76                    INPORT:	EQU 5
  77                    OUTPORT: EQU 016
  78                    
  79                    ;;; HERE IS THE USER DEFINED CHARACTER INPUT TO READ FROM SERIAL PORT
  80                    	
  81 00-103 113         CINP:	INP INPORT
  82 00-104 240         	NDA
  83 00-105 160 103 000 	JTS CINP
  84 00-110 250         	XRA
  85 00-111 016 104     	LBI 104
  86                    
  87 00-113 011         MORE1:	DCB
  88 00-114 110 113 000 	JFZ MORE1
  89 00-117 135         	OUT OUTPORT
  90 00-120 106 177 000 	CAL TIMER
  91 00-123 106 167 000 	CAL NEXBIT
  92 00-126 106 167 000 	CAL NEXBIT
  93 00-131 106 167 000 	CAL NEXBIT
  94 00-134 106 167 000 	CAL NEXBIT
  95 00-137 106 167 000 	CAL NEXBIT
  96 00-142 106 167 000 	CAL NEXBIT
  97 00-145 106 167 000 	CAL NEXBIT
  98 00-150 106 167 000 	CAL NEXBIT
  99                    
 100 00-153 006 001     STOP:	LAI 001
 101 00-155 135         	OUT OUTPORT
 102 00-156 301         	LAB
 103 00-157 002         	RLC
 104 00-160 016 314     	LBI 314
 105                    
 106 00-162 011         MORE3:	DCB
 107 00-163 110 162 000 	JFZ MORE3
 108 00-166 007         	RET
 109                    
 110 00-167 113         NEXBIT:	INP INPORT
 111 00-170 044 200     	NDI 200
 112                    
 113 00-172 002                RLC
 114 00-173 135                OUT OUTPORT
 115 00-174 012                RRC
 116 00-175 201         	ADB
 117 00-176 012         	RRC
 118 00-177 016 213     TIMER:	LBI 213
 119 00-201 011         MORE2:	DCB
 120 00-202 110 201 000 	JFZ MORE2
 121 00-205 310         	LBA
 122 00-206 007         	RET
 123                    ;;; no user defined functions yet, stop here if we: see one.
 124 00-207 001         UDEFX:	HLT
 125                    
 126                    ;;; HERE IS THE USER DEFINED PRINT ROUTINE FOR A SERIAL PORT
 127                    	
 128 00-210 240         CPRINT:	NDA
 129 00-211 022         	RAL
 130 00-212 135         	OUT OUTPORT
 131 00-213 032         	RAR
 132 00-214 106 177 000 	CAL TIMER
 133 00-217 106 264 000 	CAL BITOUT
 134 00-222 106 264 000 	CAL BITOUT
 135 00-225 106 264 000 	CAL BITOUT
 136 00-230 106 264 000 	CAL BITOUT
 137 00-233 106 264 000 	CAL BITOUT
 138 00-236 106 264 000 	CAL BITOUT
 139 00-241 106 264 000 	CAL BITOUT
 140 00-244 106 264 000 	CAL BITOUT
 141 00-247 310         	LBA
 142 00-250 006 001     	LAI 001
 143 00-252 135         	OUT OUTPORT
 144 00-253 301         	LAB
 145 00-254 106 177 000 	CAL TIMER
 146 00-257 016 103     	LBI 103
 147 00-261 104 162 000 	JMP MORE3
 148                    
 149 00-264 135         BITOUT:	OUT OUTPORT
 150 00-265 012         	RRC
 151 00-266 106 177 000 	CAL TIMER
 152 00-271 007         	RET
 153                    ;;; THE ABOVE MUST CONCLUDE BEFORE BY PAGE 1 STARTS
 154                    	
 155                    	
 156                    ;;; Page one has many constants and variables.
 157                    	
 158                    	ORG 001#000
 159 01-000             	DATA *4
 160 01-004 000 000 100  	DATA 000,000,100,001	; STORES FLOATING POINT CONSTANT +1.0
     01-007 001 
 161 01-010             	DATA *3
 162 01-013 000          	DATA 000		; EXPONENT COUNTER
 163 01-014 000 000 000  	DATA 000,000,000,000	; STORES FLOATING POINT NUMBER TEMPORARILLY
     01-017 000 
 164 01-020             	DATA *4
 165 01-024 000 000 300  	DATA 000,000,300,001	; STORES FLOATING POINT CONSTANT -1.0
     01-027 001 
 166 01-030 000 000 000  	DATA 000,000,000,000	; SCRATCH PAD AREA (16 BYTES)
     01-033 000 
 167 01-034 000 000 000  	DATA 000,000,000,000
     01-037 000 
 168 01-040 000 000 000  	DATA 000,000,000,000
     01-043 000 
 169 01-044 000 000 000  	DATA 000,000,000,000
     01-047 000 
 170 01-050 001 120 162  	DATA 001,120,162,002	; STORES RANDOM NUMBER GENERATOR CONSTANT VALUE
     01-053 002 
 171 01-054             	DATA *4
 172 01-060 003 150 157  	DATA 003,150,157,014	; STORES RANDOM NUMBER GENERATOR CONSTANT VALUE
     01-063 014 
 173 01-064 000 000 000  	DATA 000,000,000,000	; SCRATCH PAD AREA (12 BYTES) (01 064-077)
     01-067 000 
 174 01-070 000 000 000  	DATA 000,000,000,000
     01-073 000 
 175 01-074 000 000 000  	DATA 000,000,000,000
     01-077 000 
 176 01-100 000 000      	DATA 000,000		; SIGN INDICATOR
 177 01-102 000          	DATA 000		; BITS COUNTER
 178 01-103 000 000      	DATA 000,000		; SIGN INDICATOR
 179 01-105 000          	DATA 000		; INPUT DIGIT COUNTER
 180 01-106 000          	DATA 000		; TEMP STORATE
 181 01-107 000          	DATA 000		; OUTPUT DIGIT COUNTER
 182 01-110 000          	DATA 000 		; FP MODE INDICATOR
 183 01-111             	DATA *7			; NOT ASSIGNED (SHOULD BE 01 111-117)
 184 01-120 000 000 000  	DATA 000,000,000,000	; FPACC EXTENSION
     01-123 000 
 185 01-124 000 000 000  	DATA 000,000,000,000	; FPACC LSW, NSW, MSW, EXPONENT
     01-127 000 
 186 01-130 000 000 000  	DATA 000,000,000,000	; FPOP  Extension
     01-133 000 
 187 01-134 000 000 000  	DATA 000,000,000,000	; FPOP  LSW, NSW, MSW, EXPONENT
     01-137 000 
 188 01-140 000 000 000  	DATA 000,000,000,000	; FLOATING POINT WORKING AREA
     01-143 000 
 189 01-144 000 000 000  	DATA 000,000,000,000	; (SHOULD BE AT 01 140-01-167)
     01-147 000 
 190 01-150 000 000 000  	DATA 000,000,000,000
     01-153 000 
 191 01-154 000 000 000  	DATA 000,000,000,000
     01-157 000 
 192 01-160 000 000 000  	DATA 000,000,000,000
     01-163 000 
 193 01-164 000 000 000  	DATA 000,000,000,000
     01-167 000 
 194 01-170             	DATA *8			; NOT ASSIGNED (SHOULD BE 01 170-01 177)
 195 01-200 000 000 000  	DATA 000,000,000,000	; TEMPORARY REGISTER STORAGE AREA (D,E,H&L)
     01-203 000 
 196 01-204             	DATA *4			; NOT ASSIGNED (01 204-01 207)
 197 01-210 000 000 120  	DATA 000,000,120,004	; STORES FLOATING POINT CONSTANT +10.0
     01-213 004 
 198 01-214 147 146 146  	DATA 147,146,146,375	; STORES FLOATING POINT CONSTANT +0.1
     01-217 375 
 199 01-220 000          	DATA 000		; GETINP COUNTER
 200 01-221             	DATA *6			; NOT ASSIGNED (01 221-01 226)
 201 01-227 000          	DATA 000		; ARITHMETIC STACK POINTER (01 227)
 202 01-230 000          	DATA 000		; ARITHMETIC STACK (NOT CLEAR HOW LONG)
 203                    	ORG 001#272
 204 01-272 004          	DATA 004		; CC FOR SAVE
 205 01-273 323 301 326  	DATA "SAVE"
     01-276 305 
 206 01-277 004          	DATA 004		; CC FOR LOAD
 207 01-300 314 317 301  	DATA "LOAD"
     01-303 304 
 208 01-304 000 000 000  	DATA 000,000,000,000	; UNCLEAR WHAT THIS IS (01 304-01 317) ZEROS
     01-307 000 
 209 01-310 000 000 000  	DATA 000,000,000,000	; (PROBABLY STEP, FOR/NEXT, AND ARRAY PTR TEMP)
     01-313 000 
 210 01-314 000 000 000  	DATA 000,000,000,000
     01-317 000 
 211                    	;; AT THIS POINT WE SHOULD BE AT LOCATION 01 320
 212 01-320 004          	DATA 4
 213 01-321 324 310 305  	DATA "THEN"
     01-324 316 
 214 01-325 002          	DATA 2
 215 01-326 324 317      	DATA "TO"
 216 01-330 004          	DATA 4
 217 01-331 323 324 305  	DATA "STEP"
     01-334 320 
 218 01-335 004          	DATA 4
 219 01-336 314 311 323  	DATA "LIST"
     01-341 324 
 220 01-342 003          	DATA 3
 221 01-343 322 325 316  	DATA "RUN"
 222 01-346 003          	DATA 3
 223 01-347 323 303 322  	DATA "SCR
 224 01-352 013          	DATA 013		; CC FOR "READY" MESSAGE
 225 01-353 224 215 212  	DATA 224,215,212	; CTRL-T, CARRIAGE RETURN, LINE FEED
 226 01-356 322 305 301  	DATA "READY"
     01-361 304 331 
 227 01-363 215 212 212  	DATA 215,212,212	; CARRIAGE RETURN, LINE FEED, LINE FEED;
 228 01-366 011          	DATA 011
 229 01-367 240 301 324  	DATA " AT LINE "
     01-372 240 314 311
     01-375 316 305 240
 230                    	;; THIS SHOULD BE THE END OF PAGE 01
 231                    
 232                    	
 233                    	ORG 002#000		; START PAGE 02, THE CODE
 234                    	
 235                    
 236 02-000 106 255 002 SYNTAX:    CAL CLESYM             ;Clear the SYMBOL BUFFER area
 237 02-003 066 340                LLI 340                ;Set L to start of LINE NUMBER BUFFER
 238 02-005 056 026                LHI \HB\OLDPG26        ;** Set H to page of LINE NUMBER BUFFER
 239 02-007 076 000                LMI 000                ;Initialize line number buff by placing zero as (cc)
 240 02-011 066 201                LLI 201                ;Change pointer to syntax counter/pointer storage loc.
 241 02-013 076 001                LMI 001                ;Set pointer to first character (after cc) in line buffer
 242 02-015 066 201     SYNTX1:    LLI 201                ;Set pointer to syntax cntr/pntr storage location
 243 02-017 106 240 002            CAL GETCHR             ;Fetch the character pointed to by contents of syntax
 244 02-022 150 044 002            JTZ SYNTX2             ;Cntr/pntr from the line input buffer. If character was
 245 02-025 074 260                CPI 260                ;A space, ignore. Else, test to see if character was ASCII
 246 02-027 160 061 002            JTS SYNTX3             ;Code for a decimal digit. If not a decimal digit, consider
 247 02-032 074 272                CPI 272                ;Line number to have been processed by jumping
 248 02-034 120 061 002            JFS SYNTX3             ;Over the remainder of this SYNTX1 section.
 249 02-037 066 340                LLI 340                ;If have decimal digit, set pointer to start of LINE
 250 02-041 106 314 002            CAL CONCT1             ;NUMBER BUFFER and append incoming digit there.
 251 02-044 066 201     SYNTX2:    LLI 201                ;Reset L to syntax cntr/pntr storage location. Call sub-
 252 02-046 106 003 003            CAL LOOP               ;Routine to advance pntr and test for end of inr)ut buffer
 253 02-051 110 015 002            JFZ SYNTX1             ;If not end of input buffer, go back for next digit
 254 02-054 066 203                LLI 203                ;If end of buffer, only had a line number in the line.
 255 02-056 076 000                LMI 000                ;Set pntr to TOKEN storage location. Set TOKEN = 000.
 256 02-060 007                    RET                    ;Return to caller.
 257 02-061 066 201     SYNTX3:    LLI 201                ;Reset pointer to syntax cntr/pntr and fetch
 258 02-063 317                    LBM                    ;Position of next character after the line number
 259 02-064 066 202                LLI 202                ;Change pntr to SCAN pntr storage location
 260 02-066 371                    LMB                    ;Store address when SCAN takes up after line number
 261 02-067 066 202     SYNTX4:    LLI 202                ;Set pntr to SCAN pntr stomge location
 262 02-071 106 240 002            CAL GETCHR             ;Fetch the character pointed to by contents of the SCAN
 263 02-074 150 171 002            JTZ SYNTX6             ;Pointer storage location. If character was ASCII code
 264 02-077 074 275                CPI 275                ;For space, ignore. Else, compare character with "=" sign
 265 02-101 150 210 002            JTZ SYNTX7             ;If is an equal sign, go set TOKEN for IMPLIED LET.
 266 02-104 074 250                CPI 250                ;Else, compare character with left parenthesis " ( "
 267 02-106 150 215 002            JTZ SYNTX8             ;If left parenthesis, go set TOKEN for implied array LET
 268 02-111 106 310 002            CAL CONCTS             ;Otherwise, concatenate the character onto the string
 269 02-114 066 203                LLI 203                ;Being constructed in the SYMBOL BUFFER. Now set
 270 02-116 076 001                LMI 001                ;Up TOKEN storage location to an initial value of 001.
 271 02-120 056 027                LHI \HB\OLDPG27        ;** Set H to point to start of KEYWORD TABLE.
 272 02-122 066 000                LLI 000                ;Set L to point to start of KEYWORD TABLE.
 273 02-124 036 026     SYNTX5:    LDI \HB\OLDPG26        ;** Set D to page of SYMBOL BUFFER
 274 02-126 046 120                LEI 120                ;Set E to start of SYMBOL BUFFER
 275 02-130 106 332 002            CAL STRCP              ;Compare char string presently in SYMBOL BUFFER
 276 02-133 053                    RTZ                    ;With entry in KEYWORD TABLE. Exit if match.
 277 02-134 106 356 022            CAL SWITCH             ;TOKEN will be set to keyword found. Else, switch
 278 02-137 060         SYNTXL:    INL                    ;Pointers to get table address back and advance pntr to
 279 02-140 307                    LAM                    ;KEYWORD TABLE. Now look for start of next entry
 280 02-141 044 300                NDI 300                ;In KEYWORD TABLE by looking for (cc) byte which
 281 02-143 110 137 002            JFZ SYNTXL             ;Will NOT have a one in the two most sig. bits. Advance
 282 02-146 106 356 022            CAL SWITCH             ;Pntr til next entry found. Then switch pointers apin so
 283 02-151 066 203                LLI 203                ;Table pointer is in D&E. Put addr of TOKEN in L.
 284 02-153 056 026                LHI \HB\OLDPG26        ;** And page of TOKEN in H. Fetch the value currently
 285 02-155 317                    LBM                    ;In TOKEN and advance it to account for going on to
 286 02-156 010                    INB                    ;The next entry in the KEYWORD TABLE.
 287 02-157 371                    LMB                    ;Restore the updated TOKEN value back to storage.
 288 02-160 106 356 022            CAL SWITCH             ;Restore the keyword table pointer back to H&L.
 289 02-163 301                    LAB                    ;Put TOKEN count in ACC.
 290 02-164 074 015                CPI 015                ;See if have tested all entries in the keyword table.
 291 02-166 110 124 002            JFZ SYNTX5             ;If not, continue checking the keyword table.
 292 02-171 066 202     SYNTX6:    LLI 202                ;Set L to SCAN pointer storage location
 293 02-173 056 026                LHI \HB\OLDPG26        ;** Set H to page of SCAN pointer stomge location
 294 02-175 106 003 003            CAL LOOP               ;Call routine to advance pntr & test for end of In buffer
 295 02-200 110 067 002            JFZ SYNTX4             ;Go back and add another character to SYMBOL BUFF
 296 02-203 066 203                LLI 203                ;And search table for KEYWORD again. Unless reach
 297 02-205 076 377                LMI 377                ;End of line input buffer. In which case set TOKEN=377
 298 02-207 007                    RET                    ;As an error indicator and exit to calling routine.
 299 02-210 066 203     SYNTX7:    LLI 203                ;Set pointer to TOKEN storage register. Set TOKEN
 300 02-212 076 015                LMI 015                ;Equal to 015 when "=" sign found for IMPLIED LET.
 301 02-214 007                    RET                    ;Exit to calling routine.
 302 02-215 066 203     SYNTX8:    LLI 203                ;Set pointer to TOKEN storage register. Set TOKEN
 303 02-217 076 016                LMI 016                ;Equal to 016 when "(" found for IMPLIED array LET.
 304 02-221 007                    RET                    ;Exit to calling routine.
 305                    
 306                                                      ;The following are subroutines used by SYNTAX and
 307                                                      ;other routines in SCELBAL.
 308                    
 309 02-222 006 302     BIGERR:    LAI 302                ;Load ASCII code for letters B and G to indicate BIG
 310 02-224 026 307                LCI 307                ;ERROR (for when buffer, stack,etc., overflows).
 311 02-226 106 202 003 ERROR:     CAL ECHO               ;Call user provided display routine to print ASCII code
 312 02-231 302                    LAC                    ;In accumulator. Transfer ASCII code from C to ACC
 313 02-232 106 202 003            CAL ECHO               ;And repeat to display error codes.
 314 02-235 104 322 012            JMP FINERR             ;Go cpmplete error message (AT LINE) as required.
 315 02-240 307         GETCHR:    LAM                    ;Get pointer from memory location pointed to by H&L
 316 02-241 074 120                CPI 120                ;See if within range of line input buffer.
 317 02-243 120 222 002            JFS BIGERR             ;If not then have an overflow condition = error.
 318 02-246 360                    LLA                    ;Else can use it as addr of character to fetch from the
 319 02-247 056 026                LHI \HB\OLDPG26        ;** LINE INPUT BUFFER by setting up H too.
 320 02-251 307                    LAM                    ;Fetch the character from the line input buffer.
 321 02-252 074 240                CPI 240                ;See if it is ASCII code for space.
 322 02-254 007                    RET                    ;Return to caller with flags set according to comparison.
 323 02-255 066 120     CLESYM:    LLI 120                ;Set L to start of SYMBOL BUFFER.
 324 02-257 056 026                LHI \HB\OLDPG26        ;** Set H to page of SYMBOL BUFFER.
 325 02-261 076 000                LMI 000                ;Place a zero byte at start of SYMBOL BUFFER.
 326 02-263 007                    RET                    ;To effectively clear the buffer. Then exit to caller.
 327                    
 328                    
 329                                                      ;Subroutine to concatenate (append) a character to the
 330                                                      ;SYMBOL BUFFER. Character must be alphanumeric.
 331                    
 332 02-264 074 301     CONCTA:    CPI 301                ;See if character code less than that for letter A.
 333 02-266 160 276 002            JTS CONCTN             ;If so, go see if it is numeric.
 334 02-271 074 333                CPI 333                ;See if character code greater than that for letter Z.
 335 02-273 160 310 002            JTS CONCTS             ;If not, have valid alphabetical character.
 336 02-276 074 260     CONCTN:    CPI 260                ;Else, see if character in valid numeric range.
 337 02-300 160 327 002            JTS CONCTE             ;If not, have an error condition.
 338 02-303 074 272                CPI 272                ;Continue to check for valid number.
 339 02-305 120 327 002            JFS CONCTE             ;If not, have an error condition.
 340 02-310 066 120     CONCTS:    LLI 120                ;If character alphanumeric, can concatenate. Set pointer
 341 02-312 056 026                LHI \HB\OLDPG26        ;** To starting address of SYMBOL BUFFER.
 342 02-314 327         CONCT1:    LCM                    ;Fetch old character count in SYMBOL BUFFER.
 343 02-315 020                    INC                    ;Increment the value to account for adding new
 344 02-316 372                    LMC                    ;Character to the buffer. Restore updated (cc).
 345 02-317 310                    LBA                    ;Save character to be appended in register B.
 346 02-320 106 036 023            CAL INDEXC             ;Add (cc) to address in H & L to get new end of buffer
 347 02-323 371                    LMB                    ;Address and append the new character to buffer
 348 02-324 006 000                LAI 000                ;Clear the accumulator
 349 02-326 007                    RET                    ;Exit to caller
 350 02-327 104 152 011 CONCTE:    JMP SYNERR             ;If character to be appended not alphanumeric, ERROR!
 351                    
 352                                                      ;Subroutine to compare
 353                                                      ;character strings pointed to by
 354                                                      ;register pairs D & E and H & L.
 355                    
 356 02-332 307         STRCP:     LAM                    ;Fetch (cc) of first string.
 357 02-333 106 356 022            CAL SWITCH             ;Switch pointers and fetch length of second string (cc)
 358 02-336 317                    LBM                    ;Into register B. Compare the lengths of the two strings.
 359 02-337 271                    CPB                    ;If they are not the same
 360 02-340 013                    RFZ                    ;Return to caller with flags set to non-zero condition
 361 02-341 106 356 022            CAL SWITCH             ;Else, exchange the pointers back to first string.
 362 02-344 106 377 002 STRCPL:    CAL ADV                ;Advance the pointer to string number 1 and fetch a
 363 02-347 307                    LAM                    ;Character from that string into the accumulator.
 364 02-350 106 356 022            CAL SWITCH             ;Now switch the pointers to string number 2.
 365 02-353 106 377 002            CAL ADV                ;Advance the pointer in line number 2.
 366 02-356 277         STRCPE:    CPM                    ;Compare char in stxing 1 (ACC) to string 2 (memory)
 367 02-357 013                    RFZ                    ;If not equal, return to cauer with flags set to non-zero
 368 02-360 106 356 022            CAL SWITCH             ;Else, exchange pointers to restore pntr to string 1
 369 02-363 011                    DCB                    ;Decrement the string length counter in register B
 370 02-364 110 344 002            JFZ STRCPL             ;If not finiahed, continue testing entire string
 371 02-367 007                    RET                    ;If complete match, return with flag in zero condition
 372 02-370 307         STRCPC:    LAM                    ;Fetch character pointed to by pointer to string 1
 373 02-371 106 356 022            CAL SWITCH             ;Exchange pointer to examine string 2
 374 02-374 104 356 002            JMP STRCPE             ;Continue the string comparison loop
 375                    
 376                                                      ;Subroutine to advance the two byte
 377                                                      ;value in CPU registers H and L.
 378                    
 379 02-377 060         ADV:       INL                    ;Advance value in register L.
 380 03-000 013                    RFZ                    ;If new value not zero, return to caller.
 381 03-001 050                    INH                    ;Else must increment value in H
 382 03-002 007                    RET                    ;Before retuming to caller
 383                    
 384                                                      ;Subroutine to advance a buffer pointer
 385                                                      ;and test to see if the end of the buffer
 386                                                      ;has been reached.
 387                    
 388 03-003 317         LOOP:      LBM                    ;Fetch memory location pointed to by H & L into B.
 389 03-004 010                    INB                    ;Increment the value.
 390 03-005 371                    LMB                    ;Restore it back to memory.
 391 03-006 066 000                LLI 000                ;Change pointer to start of INPUT LINE BUFFER
 392 03-010 307                    LAM                    ;Fetch buffer length (cc) value into the accumulator
 393 03-011 011                    DCB                    ;Make value in B original value
 394 03-012 271                    CPB                    ;See if buffer length same as that in B
 395 03-013 007                    RET                    ;Return with flags yielding results of the comparison
 396                    
 397                                                      ;The following subroutine is used to
 398                                                      ;input characters from the system's
 399                                                      ;input device (such as a keyboard)
 400                                                      ;into the LINE INPUT BUFFER. Routine has limited
 401                                                      ;editing capability included.
 402                                                      ;(Rubout = delete previous character(s) entered.)
 403                    ;;; This label, STRIN:	should be location 03 014
 404 03-014 026 000     STRIN:     LCI 000                ;Initialize register C to zero.
 405 03-016 106 221 003 STRIN1:    CAL CINPUT             ;Call user provided device input subroutine to fetch one
 406 03-021 074 377                CPI 377                ;Character from the input device. Is it ASCII code for
 407 03-023 110 045 003            JFZ NOTDEL             ;Rubout? Skip to next section if not rubout.
 408 03-026 006 334                LAI 334                ;Else, load ASCII code for backslash into ACC.
 409 03-030 106 202 003            CAL ECHO               ;Call user display driver to present backslash as a delete
 410 03-033 021                    DCC                    ;Indicator. Now decrement the input character counter.
 411 03-034 160 014 003            JTS STRIN              ;If at beginning of line do NOT decrement H and L.
 412 03-037 106 164 003            CAL DEC                ;Else, decrement H & L line pointer to erase previous
 413 03-042 104 016 003            JMP STRIN1             ;Entry, then go back for a new input.
 414 03-045 074 203     NOTDEL:    CPI 203                ;See if character inputted was'CONTROL C'
 415 03-047 150 313 012            JTZ CTRLC              ;If so, stop inputting and go back to the EXECutive
 416 03-052 074 215                CPI 215                ;If not, see if character was carriage-return
 417 03-054 150 102 003            JTZ STRINF             ;If so, have end of line of input
 418 03-057 074 212                CPI 212                ;If not, see if character was line-feed
 419 03-061 150 016 003            JTZ STRIN1             ;If so, ignore the input, get another character
 420 03-064 106 377 002            CAL ADV                ;If none of the above, advance contents of H & L
 421 03-067 020                    INC                    ;Increment the character counter
 422 03-070 370                    LMA                    ;Store the new character in the line input buffer
 423 03-071 302                    LAC                    ;Put new character count in the accumulator
 424 03-072 074 120                CPI 120                ;Make sure maximum buffer size not exceeded
 425 03-074 120 222 002            JFS BIGERR             ;If buffer size exceeded, go display BG error message
 426 03-077 104 016 003            JMP STRIN1             ;Else can go back to look for next input
 427 03-102 312         STRINF:    LBC                    ;Transfer character count from C to B
 428 03-103 106 113 003            CAL SUBHL              ;Subtract B from H & L to get starting address of
 429 03-106 372                    LMC                    ;The string and place the character count (cc) there
 430 03-107 106 141 003            CAL CRLF               ;Provide a line ending CR & LF combination on the
 431 03-112 007                    RET                    ;Display device. Then exit to caller.
 432                    
 433                                                      ;Subroutine to subtract contents of CPU register B from
 434                                                      ;the two byte value in CPU registers H & L.
 435                    
 436 03-113 306         SUBHL:     LAL                    ;Load contents of register L into the accumulator
 437 03-114 221                    SUB                    ;Subtract the contents of register B
 438 03-115 360                    LLA                    ;Restore the new value back to L
 439 03-116 003                    RFC                    ;If no carry, then no underflow. Exit to caller.
 440 03-117 051                    DCH                    ;Else must also decrement contents of H.
 441 03-120 007                    RET                    ;Before retuming to caller.
 442                    
 443                                                      ;Subroutine to display a character string on the system's
 444                                                      ;display device.
 445                    
 446 03-121 327         TEXTC:     LCM                    ;Fetch (cc) from the first location in the buffer (H & L
 447 03-122 307                    LAM                    ;Pointing there upon entry) into register B and ACC.
 448 03-123 240                    NDA                    ;Test the character count value.
 449 03-124 053                    RTZ                    ;No display if (cc) is zero.
 450 03-125 106 377 002 TEXTCL:    CAL ADV                ;Advance pointer to next location in buffer
 451 03-130 307                    LAM                    ;Fetch a character from the buffer into ACC
 452 03-131 106 202 003            CAL ECHO               ;Call the user's display driver subroutine
 453 03-134 021                    DCC                    ;Decrement the (cc)
 454 03-135 110 125 003            JFZ TEXTCL             ;If character counter not zero, continue display
 455 03-140 007                    RET                    ;Exit to caller when (cc) is zero.
 456                    
 457                                                      ;Subroutine to provide carriage-return and line-feed
 458                                                      ;combination to system's display device. Routine also
 459                                                      ;initializes a column counter to zero. Column counter
 460                                                      ;is used by selected output routines to count the num-
 461                                                      ;ber of characters that have been displayed on a line.
 462                    
 463 03-141 006 215     CRLF:      LAI 215                ;Load ASCII code for carriage-return into ACC
 464 03-143 106 202 003            CAL ECHO               ;Call user provided display driver subroutine
 465 03-146 006 212                LAI 212                ;Load ASCII code for line-feed into ACC
 466 03-150 106 202 003            CAL ECHO               ;Call user provided display driver subroutine
 467 03-153 066 043                LLI 043                ;Set L to point to COLUMN COUNTER storage location
 468 03-155 056 001                LHI \HB\OLDPG1         ;** Set H to page of COLUMN COUNTER
 469 03-157 076 001                LMI 001                ;Initialize COLUMN COUNTER to a value of one
 470 03-161 353                    LHD                    ;Restore H from D (saved by ECHO subroutine)
 471 03-162 364                    LLE                    ;Restore L from E (saved by ECHO subroutine)
 472 03-163 007                    RET                    ;Then exit to calling routine
 473                    
 474                                                      ;Subroutine to decrement double-byte value in CPU
 475                                                      ;registers H and L.
 476                    
 477 03-164 061         DEC:       DCL                    ;Decrement contents of L
 478 03-165 060                    INL                    ;Now increment to exercise CPU flags
 479 03-166 110 172 003            JFZ DECNO              ;If L not presently zero, skip decrementing H
 480 03-171 051                    DCH                    ;Else decrement H
 481 03-172 061         DECNO:     DCL                    ;Do the actual decrement of L
 482 03-173 007                    RET                    ;Return to caller
 483                    
 484                    
 485                                                      ;Subroutine to index the value in CPU registers H and L
 486                                                      ;by the contents of CPU register B.
 487                    
 488 03-174 306         INDEXB:    LAL                    ;Load L into the accumulator
 489 03-175 201                    ADB                    ;Add B to that value
 490 03-176 360                    LLA                    ;Restore the new value to L
 491 03-177 003                    RFC                    ;If no carry,  return to caller
 492 03-200 050                    INH                    ;Else, increment value in H
 493 03-201 007                    RET                    ;Before returning to caller
 494                    
 495                                                      ;The following subroutine is used to
 496                                                      ;display the ASCII encoded character in the ACC on the
 497                                                      ;system's display device. This routine calls a routine
 498                                                      ;labeled CINPUT which must be provided by the user to
 499                                                      ;actually drive the system's output device. The subroutine
 500                                                      ;below also increments an output column counter each time
 501                                                      ;it is used.
 502                    
 503 03-202 335         ECHO:      LDH                    ;Save entry value of H in register D
 504 03-203 346                    LEL                    ;And save entry value of L in register E
 505 03-204 066 043                LLI 043                ;Set L to point to COLUMN COUNTER storage location
 506 03-206 056 001                LHI \HB\OLDPG1         ;** Set H to page of COLUMN COUNTER
 507 03-210 317                    LBM                    ;Fetch the value in the COLUMN COUNTER
 508 03-211 010                    INB                    ;And increment it for each character displayed
 509 03-212 371                    LMB                    ;Restore the updated count in memory
 510 03-213 106 210 000            CAL CPRINT              ;tt Call the user's device driver subroutine
 511 03-216 353                    LHD                    ;Restore entry value of H from D
 512 03-217 364                    LLE                    ;Restore entry value of L from E
 513 03-220 007                    RET                    ;Return to calling routine
 514 03-221 104 103 000 CINPUT:	   JMP CINP               ;Reference to user defined input subroutine
 515                    
 516                    ;;; The label EVAL: SHOULD BE AT 03 224
 517 03-224 066 227     EVAL:      LLI 227                ;Load L with address of ARITHMETIC STACK pointer
 518 03-226 056 001                LHI \HB\OLDPG1         ;** Set H to page of ARITHMETIC STACK pointer
 519 03-230 076 224                LMI 224                ;Initialize ARITH STACK pointer value to addr minus 4
 520 03-232 060                    INL                    ;Advance memory pointer to FUN/ARRAY STACK pntr
 521 03-233 056 026                LHI \HB\OLDPG26        ;** Set H to page of FUN/ARRAY STACK pointer
 522 03-235 076 000                LMI 000                ;Initialize FUNIARRAY STACK pointer to start of stack
 523 03-237 106 255 002            CAL CLESYM             ;Initialize the SYMBOL BUFFER to empty condition
 524 03-242 066 210                LLI 210                ;Load L with address of OPERATOR STACK pointer
 525 03-244 076 000                LMI 000                ;Initialize OPERATOR STACK pointer value
 526 03-246 066 276                LLI 276                ;Set L to address of EVAL pointer (start of expression)
 527 03-250 317                    LBM                    ;Fetch the EVAL pointer value into register B
 528 03-251 066 200                LLI 200                ;Set up a working pointer register in this location
 529 03-253 371                    LMB                    ;And initialize EVAL CURRENT pointer
 530 03-254 066 200     SCAN1:     LLI 200                ;Load L with address of EVAL CURRENT pointer
 531 03-256 106 240 002            CAL GETCHR             ;Fetch a character in the expression being evaluated
 532 03-261 150 301 004            JTZ SCAN10             ;If character is a space, jump out of this section
 533 03-264 074 253                CPI 253                ;See if character is a "+" sign
 534 03-266 110 300 003            JFZ SCAN2              ;If not, continue checking for an operator
 535 03-271 066 176                LLI 176                ;If yes, set pointer to PARSER TOKEN storage location
 536 03-273 076 001                LMI 001                ;Place TOKEN value for "+" sign in PARSER TOKEN
 537 03-275 104 351 003            JMP SCANFN             ;Go to PARSER subroutine entry point
 538 03-300 074 255     SCAN2:     CPI 255                ;See if character is a minus ("-") sign
 539 03-302 110 357 003            JFZ SCAN4              ;If not, continue checking for an operator
 540 03-305 066 120                LLI 120                ;If yes, check the length of the symbol stored in the
 541 03-307 307                    LAM                    ;SYMBOL BUFFER by fetching the (cc) byte
 542 03-310 240                    NDA                    ;And testing to see if (cc) is zero
 543 03-311 110 345 003            JFZ SCAN3              ;If length not zero, then not a unary minus indicator
 544 03-314 066 176                LLI 176                ;Else, check to see if last operator was a right parenthesi
 545 03-316 307                    LAM                    ;By fetching the value in the PARSER TOKEN storage
 546 03-317 074 007                CPI 007                ;Location and seeing if it is token value for ")"
 547 03-321 150 345 003            JTZ SCAN3              ;If last operator was I')" then do not have a unary minus
 548 03-324 074 003                CPI 003                ;Check to see if last operator was C4*~2
 549 03-326 150 152 011            JTZ SYNERR             ;If yes, then have a syntax error
 550 03-331 074 005                CPI 005                ;Check to see if last operator was exponentiation
 551 03-333 150 152 011            JTZ SYNERR             ;If yes, then have a syntax error
 552 03-336 066 120                LLI 120                ;If none of the above, then minus sign is unary, put
 553 03-340 076 001                LMI 001                ;Character string representing the
 554 03-342 060                    INL                    ;Value zero in the SYMBOL BUFFER in string format
 555 03-343 076 260                LMI 260                ;(Character count (cc) followed by ASCII code for zero)
 556 03-345 066 176     SCAN3:     LLI 176                ;Set L to address of PARSER TOKEN storage location
 557 03-347 076 002                LMI 002                ;Set PARSER TOKEN value for minus operator
 558 03-351 106 324 004 SCANFN:    CAL PARSER             ;Call the PARSER subroutine to process current symbol
 559 03-354 104 301 004            JMP SCAN10             ;And operator. Then jump to continue processing.
 560 03-357 074 252     SCAN4:     CPI 252                ;See if character fetched from expression is
 561 03-361 110 373 003            JFZ SCAN5              ;If not, continue checking for an operator
 562 03-364 066 176                LLI 176                ;If yes, set pointer to PARSER TOKEN storage location
 563 03-366 076 003                LMI 003                ;Place TOKEN value for "*" (multiplication) operator in
 564 03-370 104 351 003            JMP SCANFN             ;PARSER TOKEN and go to PARSER subroutine entry
 565 03-373 074 257     SCAN5:     CPI 257                ;See if character fetched from expression is
 566 03-375 110 007 004            JFZ SCAN6              ;If not, continue checking for an operator
 567 04-000 066 176                LLI 176                ;If yes, set pointer to PARSER TOKEN storage location
 568 04-002 076 004                LMI 004                ;Place TOKEN value for "/" (division) operator in
 569 04-004 104 351 003            JMP SCANFN             ;PARSER TOKEN and go to PARSER subroutine entry
 570 04-007 074 250     SCAN6:     CPI 250                ;See if character fetched from expression is
 571 04-011 110 033 004            JFZ SCAN7              ;If not, continue checking for an operator
 572 04-014 066 230                LLI 230                ;If yes, load L with address of FUN/ARRAY STACK
 573 04-016 317                    LBM                    ;Pointer. Fetch the value in the stack pointer. Increment
 574 04-017 010                    INB                    ;It to indicate number of "(" operators encountered.
 575 04-020 371                    LMB                    ;Restore the updated stack pointer back to memory
 576 04-021 106 100 007            CAL FUNARR             ;Call subroutine to process possible FUNCTION or
 577 04-024 066 176                LLI 176                ;ARRAY variable subscript. Ihen set pointer to
 578 04-026 076 006                LMI 006                ;PARSER TOKEN storage and set value for operator
 579 04-030 104 351 003            JMP SCANFN             ;Go to PARSER subroutine entry point.
 580 04-033 074 251     SCAN7:     CPI 251                ;See if character fetched from expression is
 581 04-035 110 064 004            JFZ SCAN8              ;If not, continue checking for an operator
 582 04-040 066 176                LLI 176                ;If yes, load L with address of PARSER TOKEN
 583 04-042 076 007                LMI 007                ;Set PARSER TOKEN value to reflect ")"
 584 04-044 106 324 004            CAL PARSER             ;Call the  PARSER subroutine to process current symbol
 585                    	
 586 04-047 106 003 007            CAL PRIGHT             ;Call subroutine to handle FUNCTION or ARRAY
 587 04-052 066 230                LLI 230                ;Load L with address of FUN/ARRAY STACK pointer
 588 04-054 056 026                LHI \HB\OLDPG26        ;** Set H to page of FUN/ARRAY STACK pointer
 589 04-056 317                    LBM                    ;Fetch the value in the stack pointer. Decrement it
 590 04-057 011                    DCB                    ;To account for left parenthesis just processed.
 591 04-060 371                    LMB                    ;Restore the updated value back to memory.
 592 04-061 104 301 004            JMP SCAN10             ;Jump to continue processing expression.
 593 04-064 074 336     SCAN8:     CPI 336                ;See if character fetched from expression is " t
 594 04-066 110 100 004            JFZ SCAN9              ;If not, continue checking for an operator
 595 04-071 066 176                LLI 176                ;If yes, load L with address of PARSER TOKEN
 596 04-073 076 005                LMI 005                ;Put in value for exponentiation
 597 04-075 104 351 003            JMP SCANFN             ;Go to PARSER subroutine entry point.
 598 04-100 074 274     SCAN9:     CPI 274                ;See if character fetched is the "less than" sign
 599 04-102 110 143 004            JFZ SCAN11             ;If not, continue checking for an operator
 600 04-105 066 200                LLI 200                ;If yes, set L to the EVAL CURRENT pointer
 601 04-107 317                    LBM                    ;Fetch the pointer
 602 04-110 010                    INB                    ;Increment it to point to the next character
 603 04-111 371                    LMB                    ;Restore the updated pointer value
 604 04-112 106 240 002            CAL GETCHR             ;Fetch the next character in the expression
 605 04-115 074 275                CPI 275                ;Is the character the "= 9 $ sign?
 606 04-117 150 251 004            JTZ SCAN13             ;If so, have 'less than or equal" combination
 607 04-122 074 276                CPI 276                ;Is the character the "greater than" sign?
 608 04-124 150 267 004            JTZ SCAN15             ;If so, have "less than or greater than" combination
 609 04-127 066 200                LLI 200                ;Else character is not part of the operator. Set L back
 610 04-131 317                    LBM                    ;To the EVAL CURRENT pointer. Fetch the pointer
 611 04-132 011                    DCB                    ;Value and decriment it back one character in the
 612 04-133 371                    LMB                    ;Expression. Restore the original pointer value.
 613 04-134 066 176                LLI 176                ;Have just the 'less than" operator. Set L to the
 614 04-136 076 011                LMI 011                ;PARSER TOKEN storage location and set the value for
 615 04-140 104 351 003            JMP SCANFN             ;The 'less than" sign then go to PARSER entry point.
 616 04-143 074 275     SCAN11:    CPI 275                ;See if character fetched is the "= " sign
 617 04-145 110 206 004            JFZ SCAN12             ;If not, continue checking for an operator
 618 04-150 066 200                LLI 200                ;If yes, set L to the EVAL CURRENT pointer
 619 04-152 317                    LBM                    ;Fetch the pointer
 620 04-153 010                    INB                    ;Increment it to point to the next character
 621 04-154 371                    LMB                    ;Restore the updated pointer value
 622 04-155 106 240 002            CAL GETCHR             ;Fetch the next character in the expression
 623 04-160 074 274                CPI 274                ;Is the character the "less than" sign?
 624 04-162 150 251 004            JTZ SCAN13             ;If so, have "less than or equal" combination
 625 04-165 074 276                CPI 276                ;Is the character the "greater than" sign?
 626 04-167 150 260 004            JTZ SCAN14             ;If so, have "equal or greater than" combination
 627 04-172 066 200                LLI 200                ;Else character is not part of the operator. Set L back
 628 04-174 317                    LBM                    ;To the EVAL CURRENT pointer. Fetch the pointer
 629 04-175 011                    DCB                    ;Value and decrement it back one character in the
 630 04-176 371                    LMB                    ;Expression. Restore the original pointer value.
 631 04-177 066 176                LLI 176                ;Just have '~-- " operator. Set L to the PARSER TOKEN
 632 04-201 076 012                LMI 012                ;Storage location and set the value for the sign.
 633 04-203 104 351 003            JMP SCANFN             ;Go to the PARSER entry point.
 634 04-206 074 276     SCAN12:    CPI 276                ;See if character fetched is the "greater than" sign
 635 04-210 110 276 004            JFZ SCAN16             ;If not, go append the character to the SYMBOL BUFF
 636 04-213 066 200                LLI 200                ;If so, set L to the EVAL CURRENT pointer
 637 04-215 317                    LBM                    ;Fetch the pointer
 638 04-216 010                    INB                    ;Increment it to point to the next character
 639 04-217 371                    LMB                    ;Restore the updated pointer value
 640 04-220 106 240 002            CAL GETCHR             ;Fetch the next character in the expression
 641 04-223 074 274                CPI 274                ;Is the character the "less than" sign?
 642 04-225 150 267 004            JTZ SCAN15             ;If so, have "less than or greater than" combination
 643 04-230 074 275                CPI 275                ;Is the character the "= " sign?
 644 04-232 150 260 004            JTZ SCAN14             ;If so, have the "equal to or greater than " combination
 645 04-235 066 200                LLI 200                ;Else character is not part of the operator. Set L back
 646 04-237 317                    LBM                    ;To the EVAL CURRENT pointer. Fetch the pointer
 647 04-240 011                    DCB                    ;Value and decrement it back one character in the
 648 04-241 371                    LMB                    ;Expression. Restore the original pointer value.
 649 04-242 066 176                LLI 176                ;Have just the "greater than" operator. Set L to the
 650 04-244 076 013                LMI 013                ;PARSER TOKEN storage location and set the value for
 651 04-246 104 351 003            JMP SCANFN             ;The "greater than" sign then go to PARSER entry
 652 04-251 066 176     SCAN13:    LLI 176                ;When have 'less than or equal" combination set L to
 653 04-253 076 014                LMI 014                ;PARSER TOKEN storage location and set the value.
 654 04-255 104 351 003            JMP SCANFN             ;Then go to the PARSER entry point.
 655 04-260 066 176     SCAN14:    LLI 176                ;When have "equal to or greater than" combination set L
 656 04-262 076 015                LMI 015                ;To PARSER TOKEN storage location and set the value.
 657 04-264 104 351 003            JMP SCANFN             ;Then go to the PARSER entry point.
 658 04-267 066 176     SCAN15:    LLI 176                ;When have 'less than or greater than" combination set
 659 04-271 076 016                LMI 016                ;L to PARSER TOKEN storage location and set value.
 660 04-273 104 351 003            JMP SCANFN             ;Then go to the PARSER entry point.
 661 04-276 106 310 002 SCAN16:    CAL CONCTS             ;Concatenate the character to the SYMBOL BUFFER
 662 04-301 066 200     SCAN10:    LLI 200                ;Set L to the EVAL CURRENT pointer storage location
 663 04-303 056 026                LHI \HB\OLDPG26        ;** Set H to page of EVAL CURRENT pointer
 664 04-305 317                    LBM                    ;Fetch the EVAL CURRENT pointer value into B
 665 04-306 010                    INB                    ;Increment the pointer value to point to next character
 666 04-307 371                    LMB                    ;In the expression and restore the updated value.
 667 04-310 066 277                LLI 277                ;Set L to EVAL FINISH storage location.
 668 04-312 307                    LAM                    ;Fetch the EVAL FINISH value into the accumulator.
 669 04-313 011                    DCB                    ;Set B to last character processed in the expression.
 670 04-314 271                    CPB                    ;See if last character was at EVAL FINISH location.
 671 04-315 110 254 003            JFZ SCAN1              ;If not, continue processing the expression. Else, jump
 672 04-320 104 300 031            JMP PARSEP             ;To final evaluation procedure and test.  (Directs routine
 673 04-323 001                    HLT                    ;To a dislocated section.) Safety Halt in unused byte.
 674 04-324 066 120     PARSER:    LLI 120                ;Load L with starting address of SYMBOL BUFFER
 675 04-326 056 026                LHI \HB\OLDPG26        ;** Load H with page of SYMBOL BUFFER
 676 04-330 307                    LAM                    ;Fetch the (cc) for  contents of SYMBOL BUFFER
 677 04-331 240                    NDA                    ;Into the ACC and see if buffer is  empty
 678 04-332 150 231 005            JTZ PARSE              ;If empty then no need to convert contents
 679 04-335 060                    INL                    ;If not empty, advance buffer pointer
 680 04-336 307                    LAM                    ;Fetch the first character in the buffer
 681 04-337 074 256                CPI 256                ;See if it is ASCII code for decimal sign
 682 04-341 150 356 004            JTZ PARNUM             ;If yes, consider contents of buffer to be a number
 683 04-344 074 260                CPI 260                ;If not decimal sign, see if first character represents
 684 04-346 160 033 005            JTS LOOKUP             ;A deciinal digit, if not, should have a variable
 685 04-351 074 272                CPI 272                ;Continue to test for a decimal digit
 686 04-353 120 033 005            JFS LOOKUP             ;If not, go look up the variable nwne
 687 04-356 061         PARNUM:    DCL                    ;If SYMBOL BUFFER contains number, decrement
 688 04-357 307                    LAM                    ;Buffer pointer back to (cc) and fetch it to ACC
 689 04-360 074 001                CPI 001                ;See if length of string in buffer is just one
 690 04-362 150 005 005            JTZ NOEXPO             ;If so, cannot have number with scientific notation
 691 04-365 206                    ADL                    ;If not, add length to buffer pointer to
 692 04-366 360                    LLA                    ;Point to last character in the buffer
 693 04-367 307                    LAM                    ;Fetch the last character in buffer and see if it
 694 04-370 074 305                CPI 305                ;Represents letter E for Exponent
 695 04-372 110 005 005            JFZ NOEXPO             ;If not, cannot have number with scientific notation
 696 04-375 066 200                LLI 200                ;If yes, have part of a scientific number, set pointer to
 697 04-377 106 240 002            CAL GETCHR             ;Get the operator that follows the E and append it to
 698 05-002 104 310 002            JMP CONCTS             ;The SYMBOL BUFFER and return to EVAL routine
 699 05-005 066 227     NOEXPO:    LLI 227                ;Load L with address of ARITHMETIC STACK pointer
 700 05-007 056 001                LHI \HB\OLDPG1         ;** Load H with page of ARITHMETIC STACK pointer
 701 05-011 307                    LAM                    ;Fetch AS pointer value to ACC and add four to account
 702 05-012 004 004                ADI 004                ;For the number of bytes required to store a number in
 703 05-014 370                    LMA                    ;Floating point format. Restore pointer to mernory.
 704 05-015 360                    LLA                    ;Then, change L to point to entry position in the AS
 705 05-016 106 255 022            CAL FSTORE             ;Place contents of the FPACC onto top of the AS
 706 05-021 066 120                LLI 120                ;Change L to point to start of the SYMBOL BUFFER
 707 05-023 056 026                LHI \HB\OLDPG26        ;** Set H to page of the SYMBOL BUFFER
 708 05-025 106 044 023            CAL DINPUT             ;Convert number in the buffer to floating point format
 709 05-030 104 231 005            JMP PARSE              ;In the FPACC then jump to check operator sign.
 710 05-033 066 370     LOOKUP:    LLI 370                ;Load L with address of LOOK-UP COUNTER
 711 05-035 056 026                LHI \HB\OLDPG26        ;** Load H with page of the counter
 712 05-037 076 000                LMI 000                ;Initialize the counter to zero
 713 05-041 066 120                LLI 120                ;Load L with starting address of the SYMBOL BUFFER
 714 05-043 036 027                LDI \HB\OLDPG27        ;** Load D with page of the VARIABLES TABLE
 715 05-045 046 210                LEI 210                ;Load E with start of the VARL433LES TABLE
 716 05-047 307                    LAM                    ;Fetch the (cc) for the string in the SYMBOL BUFFER
 717 05-050 074 001                CPI 001                ;See if the name length is just one character. If not,
 718 05-052 110 061 005            JFZ LOOKU1             ;Should be two so proceed to look-up routine. Else,
 719 05-055 066 122                LLI 122                ;Change L to second character byte in the buffer and set
 720 05-057 076 000                LMI 000                ;It to zero to provide compatibility with entries in table
 721 05-061 066 121     LOOKU1:    LLI 121                ;Load L with addr of first character in the SYMBOL
 722 05-063 056 026                LHI \HB\OLDPG26        ;** BUFFER. Set H to page of the SYMBOL BUFFER.
 723 05-065 106 356 022            CAL SWITCH             ;Exchange contents of D&E with H&L so that can
 724 05-070 307                    LAM                    ;Fetch the first character of a name in the VARIABLES
 725 05-071 060                    INL                    ;TABLE. Advance the table pointer and save the
 726 05-072 317                    LBM                    ;Second byte of name in B. Then advance the pointer
 727 05-073 060                    INL                    ;Again to reach first bvte of floating point forrnatted
 728 05-074 106 356 022            CAL SWITCH             ;Number in table. Now exchange D&E with H&L and
 729 05-077 277                    CPM                    ;Compare first byte in table against first char in buffer
 730 05-100 110 111 005            JFZ LOOKU2             ;If not the same, go try next entry in table. If same,
 731 05-103 060                    INL                    ;Advance pointer to next char in buffer. Transfer the
 732 05-104 301                    LAB                    ;Character in B (second byte in table entry) to the ACC
 733 05-105 277                    CPM                    ;Compare it against second character in the buffer.
 734 05-106 150 201 005            JTZ LOOKU4             ;If match, have found the name in the VARIABLES tbl.
 735 05-111 106 256 006 LOOKU2:    CAL AD4DE              ;Call subroutine to add four to the pointer in D&E to
 736 05-114 066 370                LLI 370                ;Advance the table pointer over value bytes. Then set
 737 05-116 056 026                LHI \HB\OLDPG26        ;** Up H and L to point to LOOK-UP COUNTER.
 738 05-120 317                    LBM                    ;Fetch counter value (counts number of entries tested
 739 05-121 010                    INB                    ;In the VARIABLES TABLE), increment it
 740 05-122 371                    LMB                    ;And restore it back to meynory
 741 05-123 066 077                LLI 077                ;Load L with address of SYMBOL VARIABLES counter
 742 05-125 056 027                LHI \HB\OLDPG27        ;** Do same for H. (Counts number of names in table.)
 743 05-127 301                    LAB                    ;Place LOOK-UP COUNTER value in the accumulator.
 744 05-130 277                    CPM                    ;Compare it with number of entries in the table.
 745 05-131 110 061 005            JFZ LOOKU1             ;If have not reached end of table, keep looking for name.
 746 05-134 066 077                LLI 077                ;If reach end of table without match, need to add name
 747 05-136 056 027                LHI \HB\OLDPG27        ;** To table. First set H & L to the SYMBOL
 748 05-140 317                    LBM                    ;VARIABLES counter. Fetch the counter value and
 749 05-141 010                    INB                    ;Increment to account for new name being added to the
 750 05-142 371                    LMB                    ;Table. Restore the updated count to meinory. Also,
 751 05-143 301                    LAB                    ;Move the new counter value to the accumulator and
 752 05-144 074 025                CPI 025                ;Check to see that table size is not exceeded. If try to
 753 05-146 120 222 002            JFS BIGERR             ;Go over 20 (decirnal) entries then have BIG error.
 754 05-151 066 121                LLI 121                ;Else, set L to point to first character in the SYMBOL
 755 05-153 056 026                LHI \HB\OLDPG26        ;** BUFFER and set H to proper page. Set the number
 756 05-155 016 002                LBI 002                ;Of bytes to be transferred into register B as a counter.
 757 05-157 106 013 021            CAL MOVEIT             ;Move the symbol name from the buffer to the
 758 05-162 364                    LLE                    ;VARIABLES TABLE. Now set up H & L with value
 759 05-163 353                    LHD                    ;Contained in D & E after moving ops (points to first
 760 05-164 250                    XRA                    ;Byte of the value to be associated with the symbol
 761 05-165 370                    LMA                    ;Name.) Clear the accumulator and place zero in all four
 762 05-166 060                    INL                    ;Bytes associated with the variable name entered
 763 05-167 370                    LMA                    ;In the VARIABLES TABLE
 764 05-170 060                    INL                    ;In order to
 765 05-171 370                    LMA                    ;Assign an
 766 05-172 060                    INL                    ;Initial value
 767 05-173 370                    LMA                    ;To the variable narne
 768 05-174 306                    LAL                    ;Then transfer the address in L to the acc'umulator
 769 05-175 024 004                SUI 004                ;Subtract four to reset the pointer to start of zeroing ops
 770 05-177 340                    LEA                    ;Restore the address in D & E to be in same state as if
 771 05-200 335                    LDH                    ;Name was found in the table in the LOOKUP routine
 772 05-201 106 317 022 LOOKU4:    CAL SAVEHL             ;Save current address to VARIABLES TABLE
 773 05-204 066 227                LLI 227                ;Load L with address of ARITHMETIC STACK pointer
 774 05-206 056 001                LHI \HB\OLDPG1         ;** Load H with page of the pointer
 775 05-210 307                    LAM                    ;Fetch the AS pointer value to the accumulator
 776 05-211 004 004                ADI 004                ;Add four to account for next floating point forrnatted
 777 05-213 370                    LMA                    ;Number to be stored in the stack. Restore the stack
 778 05-214 360                    LLA                    ;Pointer to memory and set it up in register L too.
 779 05-215 106 255 022            CAL FSTORE             ;Place the value in the FPACC on the top of the
 780 05-220 106 337 022            CAL RESTHL             ;ARITHMETIC STACK. Restore the VARIABLES
 781 05-223 106 356 022            CAL SWITCH             ;TABLE pointer to H&L and move it to D&E. Now load
 782 05-226 106 244 022            CAL FLOAD              ;The VARIABLE value from the table to the FPACC.
 783 05-231 106 255 002 PARSE:     CAL CLESYM             ;Clear the SYMBOL BUFFER
 784 05-234 066 176                LLI 176                ;Load L with address of PARSER TOKEN VALUE
 785 05-236 307                    LAM                    ;And fetch the token value into the accumulator
 786 05-237 074 007                CPI 007                ;Is it token value for right parenthesis ")" ? If so, have
 787 05-241 150 332 005            JTZ PARSE2             ;Special case where must perforin ops til find a "(" !
 788 05-244 004 240                ADI 240                ;Else, fon-n address to HEIRARCHY IN table and
 789 05-246 360                    LLA                    ;Set L to point to HEIRARCHY IN VALUE in the table
 790 05-247 317                    LBM                    ;Fetch the heirarchy value from the table to register B
 791 05-250 066 210                LLI 210                ;Set L to OPERATOR STACK pointer storage location
 792 05-252 327                    LCM                    ;Fetch the OS pointer into CPU register C
 793 05-253 106 036 023            CAL INDEXC             ;Add OS pointer to address of OS pointer storage loc
 794 05-256 307                    LAM                    ;Fetch the token value for the operator at top of the OS
 795 05-257 004 257                ADI 257                ;And form address to HEIRARCHY OUT table
 796 05-261 360                    LLA                    ;Set L to point to HEIRARCHY OUT VALUE in the
 797 05-262 301                    LAB                    ;Table. Move the HEIRARCHY IN value to the ACC.
 798 05-263 277                    CPM                    ;Compare the HEIRARCHY IN with the HEIRARCHY
 799 05-264 150 307 005            JTZ PARSE1             ;OUT value. If heirarchy of current operator equal to or
 800 05-267 160 307 005            JTS PARSE1             ;Less than operator on top of OS stack, perfo
 801 05-272 066 176                LLI 176                ;Operation indicated in top of OS stack. Else, fetch the
 802 05-274 317                    LBM                    ;Current operator token value into register B.
 803 05-275 066 210                LLI 210                ;Load L with address of the OPERATOR STACK pntr
 804 05-277 327                    LCM                    ;Fetch the stack pointer value
 805 05-300 020                    INC                    ;Increment it to account for new entry on the stack
 806 05-301 372                    LMC                    ;Restore the stack pointer value to memory
 807 05-302 106 036 023            CAL INDEXC             ;For in pointer to next entry in OPERATOR STACK
 808 05-305 371                    LMB                    ;Place the current operator token value on top of the OS
 809 05-306 007                    RET                    ;Exit back to the EVAL routine.
 810 05-307 066 210     PARSE1:    LLI 210                ;Load L with address of the OPERATOR STACK pntr
 811 05-311 307                    LAM                    ;Fetch the stack pointer value to the accumulator
 812 05-312 206                    ADL                    ;Add in the value of the stack pointer address to form
 813 05-313 360                    LLA                    ;Address that points to top entry in the OS
 814 05-314 307                    LAM                    ;Fetch the token value at the top of the OS to the ACC
 815 05-315 240                    NDA                    ;Check to see if the token value is zero for end of stack
 816 05-316 053                    RTZ                    ;Exit back to the EVAL routine if stack empty
 817 05-317 066 210                LLI 210                ;Else, reset L to the OS pointer storage location
 818 05-321 327                    LCM                    ;Fetch the pointer value
 819 05-322 021                    DCC                    ;Decrement it to account for operator rernoved from
 820 05-323 372                    LMC                    ;The OPERATOR STACK and restore the pointer value
 821 05-324 106 364 005            CAL FPOPER             ;Perform the operation obtained from the top of the OS
 822 05-327 104 231 005            JMP PARSE              ;Continue to compare current operator against top of OS
 823 05-332 066 210     PARSE2:    LLI 210                ;Load L with address of the OPERATOR STACK pntr
 824 05-334 056 026                LHI \HB\OLDPG26        ;** Load H with page of the pointer
 825 05-336 307                    LAM                    ;Fetch the stack pointer value to the accumulator
 826 05-337 206                    ADL                    ;Add in the value of the stack pointer address to form
 827 05-340 360                    LLA                    ;Address that points to top entry in the OS
 828 05-341 307                    LAM                    ;Fetch the token value at the top of the 0 S to the ACC
 829 05-342 240                    NDA                    ;Check to see if the token value is zero for end of stack
 830 05-343 150 104 006            JTZ PARNER             ;If end of stack, then have a parenthesis error condx
 831 05-346 066 210                LLI 210                ;Else, reset L to the OS pointer storage location
 832 05-350 327                    LCM                    ;Fetch the pointer value
 833 05-351 021                    DCC                    ;Decrement it to account for operator removed from
 834 05-352 372                    LMC                    ;The OPERATOR STACK and restore the pointer value
 835 05-353 074 006                CPI 006                ;Check to see if token value is "(" to close parenthesis
 836 05-355 053                    RTZ                    ;If so, exit back to EVAL routine.
 837 05-356 106 364 005            CAL FPOPER             ;Else, perforin the op obtained from the top of the OS
 838 05-361 104 332 005            JMP PARSE2             ;Continue to process data in parenthesis
 839 05-364 066 371     FPOPER:    LLI 371                ;Load L with address of TEMP OP storage location
 840 05-366 056 026                LHI \HB\OLDPG26        ;** Load H with page of TEMP OP storage location
 841 05-370 370                    LMA                    ;Store OP (from top of OPERATOR STACK)
 842 05-371 066 227                LLI 227                ;Change L to address of ARff HMETIC STACK pointer
 843 05-373 056 001                LHI \HB\OLDPG1         ;** Load H with page of AS pointer
 844 05-375 307                    LAM                    ;Fetch AS pointer value into ACC
 845 05-376 360                    LLA                    ;Set L to top of ARITHMETIC STACK
 846 05-377 106 266 022            CAL OPLOAD             ;Transfer number from ARffHMETIC STACK to FPOP
 847 06-002 066 227                LLI 227                ;Restore pointer to AS pointer
 848 06-004 307                    LAM                    ;Fetch the pointer value to the ACC and subtract four
 849 06-005 024 004                SUI 004                ;To remove top value from the ARITHMETIC STACK
 850 06-007 370                    LMA                    ;Restore the updated AS pointer to memory
 851 06-010 066 371                LLI 371                ;Set L to address of TEMP OP storage location
 852 06-012 056 026                LHI \HB\OLDPG26        ;** Set H to page of TEMP OP storage location
 853 06-014 307                    LAM                    ;Fetch the operator token value to the ACC
 854 06-015 074 001                CPI 001                ;Find out which kind of operation indicated
 855 06-017 150 211 020            JTZ FPADD              ;Perforn addition if have plus operator
 856 06-022 074 002                CPI 002                ;If not plus, see if minus
 857 06-024 150 032 021            JTZ FPSUB              ;Perform subtraction if have minus operator
 858 06-027 074 003                CPI 003                ;If not minus, see if multiplication
 859 06-031 150 046 021            JTZ FPMULT             ;Perform multiplication if have multiplication operator
 860 06-034 074 004                CPI 004                ;If not multiplication, see if division
 861 06-036 150 322 021            JTZ FPDIV              ;Perform division if have division operator
 862 06-041 074 005                CPI 005                ;If not division, see if exponentiation
 863 06-043 150 263 006            JTZ INTEXP             ;Perform exponentiation if have exponentiation operator
 864 06-046 074 011                CPI 011                ;If not exponentiation, see if "less than" operator
 865 06-050 150 121 006            JTZ LT                 ;Perform compaison for "less than" op if indicated
 866 06-053 074 012                CPI 012                ;If not 'less than" see if have "equal" operator
 867 06-055 150 136 006            JTZ EQ                 ;Perforin comparison for "equal" op if indicated
 868 06-060 074 013                CPI 013                ;If not "equal" see if have "greater than" operator
 869 06-062 150 153 006            JTZ GT                 ;Perform comparison for "greater than" op if indicated
 870 06-065 074 014                CPI 014                ;If not "'greater than" see if have 'less than or equal" op
 871 06-067 150 173 006            JTZ LE                 ;Perform comparison for the combination op if indicated
 872 06-072 074 015                CPI 015                ;See if have "equal to or greater than" operator
 873 06-074 150 213 006            JTZ GE                 ;Perform comparison for the combination op if indicated
 874 06-077 074 016                CPI 016                ;See if have "less than or greater than" operator
 875 06-101 150 230 006            JTZ NE                 ;Perform comparison for the combination op if indicated
 876 06-104 066 230     PARNER:    LLI 230                ;If cannot find operator, expression is not balanced
 877 06-106 056 026                LHI \HB\OLDPG26        ;** Set H and L to address of F/A STACK pointer
 878 06-110 076 000                LMI 000                ;Clear the F/A STACK pointer to re-initialize
 879 06-112 006 311                LAI 311                ;Load ASCII code for letter I into the accumulator
 880 06-114 026 250                LCI 250                ;And code for "(" character into register C
 881 06-116 104 226 002            JMP ERROR              ;Go display 1( for "Imbalanced Parenthesis") error msg
 882 06-121 106 032 021 LT:        CAL FPSUB              ;Subtract contents of FPACC from FPOP to compare
 883 06-124 066 126                LLI 126                ;Set L to point to the MSW of the FPACC (Contains
 884 06-126 307                    LAM                    ;Result of the subtraction.) Fetch the MSW of the
 885 06-127 240                    NDA                    ;FPACC to the accumulator and test to see if result is
 886 06-130 160 242 006            JTS CTRUE              ;Positive or negative. Set up the FPACC as a function
 887 06-133 104 247 006            JMP CFALSE             ;Of the result obtained.
 888 06-136 106 032 021 EQ:        CAL FPSUB              ;Subtract contents of FPACC from FPOP to compare
 889 06-141 066 126                LLI 126                ;Set L to point to the MSW of the FPACC (Contains
 890 06-143 307                    LAM                    ;Result of the subtraction.) Fetch the MSW of the
 891 06-144 240                    NDA                    ;FPACC to the accumulator and test to see if result is
 892 06-145 150 242 006            JTZ CTRUE              ;Equal. Set up the FPACC as a function
 893 06-150 104 247 006            JMP CFALSE             ;Of the result obtained.
 894 06-153 106 032 021 GT:        CAL FPSUB              ;Subtract contents of FPACC from FPOP to compare
 895 06-156 066 126                LLI 126                ;Set L to point to the MSW of the FPACC (Contains
 896 06-160 307                    LAM                    ;Result of the subtraction.) Fetch the MSW of the
 897 06-161 240                    NDA                    ;FPACC to the accumulator and test to see if result is
 898 06-162 150 247 006            JTZ CFALSE             ;Positive, Negative, or Equal. Set up the FPACC
 899 06-165 120 242 006            JFS CTRUE              ;As a function
 900 06-170 104 247 006            JMP CFALSE             ;Of the result obtained.
 901 06-173 106 032 021 LE:        CAL FPSUB              ;Subtract contents of FPACC from FPOP to compare
 902 06-176 066 126                LLI 126                ;Set L to point to the MSW of the FPACC (Contains
 903 06-200 307                    LAM                    ;Result of the subtraction.) Fetch the MSW of the
 904 06-201 240                    NDA                    ;FPACC to the accumulator and test to see if result is
 905 06-202 150 242 006            JTZ CTRUE              ;Positive, Negative, or Equal. Set up the FPACC
 906 06-205 160 242 006            JTS CTRUE              ;As a function
 907 06-210 104 247 006            JMP CFALSE             ;Of the result obtained
 908 06-213 106 032 021 GE:        CAL FPSUB              ;Submit contents of FPACC from FPOP to compare
 909 06-216 066 126                LLI 126                ;Set L to point to the MSW of the FPACC (Contains
 910 06-220 307                    LAM                    ;Result of the subtraction.) Fetch the MSW of the
 911 06-221 240                    NDA                    ;FPACC to the accumulator and test to see if result is
 912 06-222 120 242 006            JFS CTRUE              ;Positive or Negative. Set up the FPACC
 913 06-225 104 247 006            JMP CFALSE             ;As a function of the result obtained
 914 06-230 106 032 021 NE:        CAL FPSUB              ;Subtract contents of FPACC from FPOP to compare
 915 06-233 066 126                LLI 126                ;Set L to point to the MSW of the FPACC (Contains
 916 06-235 307                    LAM                    ;Result of the subtraction.) Fetch the MSW of the
 917 06-236 240                    NDA                    ;FPACC to the accumulator and test to see if result is
 918 06-237 150 247 006            JTZ CFALSE             ;Equal. Set up the FPACC as a function of the result.
 919                    CTRUE:
 920 06-242 066 004     FPONE:     LLI 004                ;Load L with address of floating point value +1.0
 921 06-244 104 244 022            JMP FLOAD              ;Load FPACC with value +1.0 and exit to caller
 922 06-247 066 127     CFALSE:    LLI 127                ;Load L with address of FPACC Exponent register
 923 06-251 076 000                LMI 000                ;Set the FPACC Exponent to zero and then set the
 924 06-253 104 051 020            JMP FPZERO             ;Mantissa portion of the FPACC to zero. Exit to caller.
 925 06-256 304         AD4DE:     LAE                    ;Subroutine to add four to the value in register E.
 926 06-257 004 004                ADI 004                ;Move contents of E to the ACC and add four.
 927 06-261 340                    LEA                    ;Restore the updated value back to register E.
 928 06-262 007                    RET                    ;Return to the calling routine.
 929 06-263 066 126     INTEXP:    LLI 126                ;Load L with address of WSW of FPACC (Floating Point
 930 06-265 056 001                LHI \HB\OLDPG1         ;** ACCumulator). Load H with page of FPACC.
 931 06-267 307                    LAM                    ;Fetch MSW of the FPACC into the accumulator.
 932 06-270 066 003                LLI 003                ;Load L with address of EXP TEMP storage location
 933 06-272 370                    LMA                    ;Store the FPACC MSW value in EXP TEMP location
 934 06-273 240                    NDA                    ;Test contents of the MSW of the FPACC. ff zero, then
 935 06-274 150 242 006            JTZ FPONE              ;Set FPACC equal to +1.0 (any nr to zero power = 1.0!)
 936 06-277 162 202 020            CTS FPCOMP             ;If MSW indicates negative number, complement
 937 06-302 106 000 020            CAL FPFIX              ;The FPACC. Then convert floating point number to
 938 06-305 066 124                LLI 124                ;Fixed point. Load L with address of LSW of fixed nr
 939 06-307 317                    LBM                    ;Fetch the LSW into CPU register B.
 940 06-310 066 013                LLI 013                ;Set L to address of EXPONENT COUNTER
 941 06-312 371                    LMB                    ;Place the fixed value in the EXP CNTR to indicate
 942 06-313 066 134                LLI 134                ;Number of multiplications needed (power). Now set L
 943 06-315 046 014                LEI 014                ;To LSW of FPOP and E to address of FP TEMP (LSW)
 944 06-317 056 001                LHI \HB\OLDPG1         ;** Set H to floating point working area page.
 945 06-321 335                    LDH                    ;Set D to same page address.
 946 06-322 016 004                LBI 004                ;Set transfer (precision) counter. Call subroutine to move
 947 06-324 106 013 021            CAL MOVEIT             ;Contents of FPOP into FP TEMP registers to save
 948 06-327 106 242 006            CAL FPONE              ;Original value of FPOP. Now set FPACC to +1.0.
 949 06-332 066 003                LLI 003                ;Load L with pointer to original value of FPACC
 950 06-334 307                    LAM                    ;(Stored in FP TEMP) MSW and fetch contents to ACC.
 951 06-335 240                    NDA                    ;Test to see if raising to a negative power. If so, divide
 952 06-336 160 362 006            JTS DVLOOP             ;Instead of multiply!
 953 06-341 066 014     MULOOP:    LLI 014                ;Load L with address of LSW of FP TEMP (original
 954 06-343 106 277 022            CAL FACXOP             ;Value in FPOP). Move FP TEMP into FPOP.
 955 06-346 106 046 021            CAL FPMULT             ;Multiply FPACC by FPOP. Result left in FPACC.
 956 06-351 066 013                LLI 013                ;Load L with address of EXPONENT COUNTER.
 957 06-353 317                    LBM                    ;Fetch the counter value
 958 06-354 011                    DCB                    ;Decrement it
 959 06-355 371                    LMB                    ;Restore it to memory
 960 06-356 110 341 006            JFZ MULOOP             ;If counter not zero, continue exponentiation process
 961 06-361 007                    RET                    ;When have raised to proper power, return to caller.
 962 06-362 066 014     DVLOOP:    LLI 014                ;Load L with address of LSW of FP TEMP (original
 963 06-364 106 277 022            CAL FACXOP             ;Value in FPOP). Move FP TEMP into FPOP.
 964 06-367 106 322 021            CAL FPDIV              ;Divide FPACC by FPOP. Result left in FPACC.
 965 06-372 066 013                LLI 013                ;Load L with address of EXPONENT COUNTER
 966 06-374 317                    LBM                    ;Fetch the counter value
 967 06-375 011                    DCB                    ;Decrement it
 968 06-376 371                    LMB                    ;Restore to memory
 969 06-377 110 362 006            JFZ DVLOOP             ;If counter not zero, continue exponentiation process
 970 07-002 007                    RET                    ;When have raised to proper power, return to caller.
 971                    
 972                    ;;; The label PRIGHT: SHOULD BE UP TO 07 003
 973 07-003 066 230     PRIGHT:    LLI 230                ;Load L with address of F/A STACK pointer
 974 07-005 056 026                LHI \HB\OLDPG26        ;** Load H with page of F/A STACK pointer
 975 07-007 307                    LAM                    ;Fetch the pointer value into the ACC
 976 07-010 206                    ADL                    ;Form pointer to top of the F/A STACK
 977 07-011 360                    LLA                    ;Set L to point to top of the F/A STACK
 978 07-012 307                    LAM                    ;Fetch the contents of the top of the F/A STACK into
 979 07-013 076 000                LMI 000                ;The ACC then clear the top of the F/A STACK
 980 07-015 066 203                LLI 203                ;Load L with address of F /A STACK TEMP storage
 981 07-017 056 027                LHI \HB\OLDPG27        ;** Location. Set H to page of F/A STACK TEMP
 982 07-021 370                    LMA                    ;Store value from top of F/A STACK into temp loc.
 983 07-022 240                    NDA                    ;Test to see if token value in top of stack was zero
 984 07-023 053                    RTZ                    ;If so, just had simple grouping parenthesis!
 985 07-024 160 000 055            JTS PRIGH1             ;@@ If token value minus, indicates array subscript
 986 07-027 074 001                CPI 001                ;For positive token value, look for appropriate function
 987 07-031 150 243 007            JTZ INTX               ;If token value for INTeger function, go do it.
 988 07-034 074 002                CPI 002                ;Else, see if token value for SIGN function.
 989 07-036 150 360 007            JTZ SGNX               ;If so, go do it.
 990 07-041 074 003                CPI 003                ;Else, see if token value for ABSolute function
 991 07-043 150 346 007            JTZ ABSX               ;If so, go do it.
 992 07-046 074 004                CPI 004                ;If not, see if token value for SQuare Root function
 993 07-050 150 000 032            JTZ SQRX               ;If so, go do it.
 994 07-053 074 005                CPI 005                ;If not, see if token value for TAB function
 995 07-055 150 017 010            JTZ TABX               ;If so, go do it.
 996 07-060 074 006                CPI 006                ;If not, see if token value for RaNDom function
 997 07-062 150 240 032            JTZ RNDX               ;If so, go find a random number.
 998 07-065 074 007                CPI 007                ;If not, see if token value for CHaRacter function
 999 07-067 150 377 007            JTZ CHRX               ;If so, go perform the function.
1000 07-072 074 010                CPI 010                ;Else, see if token for user defined machine language
1001 07-074 150 207 000            JTZ UDEFX              ;# Function. If so, perform the User DEfined Function
1002 07-077 001                    HLT                    ;Safety halt. Program should not reach this location!
1003                    
1004                    ;;; The label FUNARR SHOULD BE AT 07 100
1005 07-100 066 120     FUNARR:    LLI 120                ;Load L with starting address of SYMBOL BUFFER
1006 07-102 056 026                LHI \HB\OLDPG26        ;** Load H with page of SYMBOL BUFFER
1007 07-104 307                    LAM                    ;Fetch the (cc) for contents of buffer to the ACC
1008 07-105 240                    NDA                    ;See if (cc) is zero, if so buffer is empty, return to
1009 07-106 053                    RTZ                    ;Caller as have simple grouping parenthesis sign
1010 07-107 066 202                LLI 202                ;Else set L to TEMP COUNTER location
1011 07-111 056 027                LHI \HB\OLDPG27        ;** Set H to TEMP COUNTER page
1012 07-113 076 000                LMI 000                ;Initialize TEMP COUNTER to zero
1013 07-115 066 202     FUNAR1:    LLI 202                ;Load L with address of TEMP COUNTER
1014 07-117 056 027                LHI \HB\OLDPG27        ;** Load H with page of TEMP COUNTER
1015 07-121 317                    LBM                    ;Fetch the counter value to register B
1016 07-122 010                    INB                    ;Increment the counter
1017 07-123 371                    LMB                    ;Restore the updated value to memory
1018 07-124 026 002                LCI 002                ;Initialize C to a value of two for future ops
1019 07-126 066 274                LLI 274                ;Load L with starting address (less four) of FUNCTION
1020 07-130 056 026                LHI \HB\OLDPG26        ;** LOOK-UP TABLE. Set H to table page.
1021 07-132 106 230 007            CAL TABADR             ;Find address of next entry in the table
1022 07-135 036 026                LDI \HB\OLDPG26        ;** Load D with page of SYMBOL BUFFER
1023 07-137 046 120                LEI 120                ;Load E with starting address of SYMBOL BUFFER
1024 07-141 106 332 002            CAL STRCP              ;Compare entry in FUNCTION LOOK-UP TABLE with
1025 07-144 150 207 007            JTZ FUNAR4             ;Contents of SYMBOL BUFFER. If find match, go set
1026 07-147 066 202                LLI 202                ;Up the function token value. Else, set L to the TEMP
1027 07-151 056 027                LHI \HB\OLDPG27        ;** COUNTER and set H to the proper page. Fetch the
1028 07-153 307                    LAM                    ;Current counter value and see if have tried all eight
1029 07-154 074 010                CPI 010                ;Possible functions in the table.
1030 07-156 110 115 007            JFZ FUNAR1             ;If not, go back and check the next entry.
1031 07-161 066 202                LLI 202                ;If have tried all of the entries in the table, set L
1032 07-163 056 027                LHI \HB\OLDPG27        ;** As well as H to the address of the TEMP COUI,.7ER
1033 07-165 076 000                LMI 000                ;And reset it to zero. Now go see if have subscripted
1034 07-167 104 054 055            JMP FUNAR2             ;@@ Array (unless array capability not in program).
1035 07-172 066 230     FAERR:     LLI 230                ;Load L with address of F/A STACK pointer
1036 07-174 056 026                LHI \HB\OLDPG26        ;** Load H with page of F/A STACK pointer
1037 07-176 076 000                LMI 000                ;Clear the F/A STACK pointer to reset on an error
1038 07-200 006 306                LAI 306                ;Load the ASCII code for letter F into the ACC
1039 07-202 026 301                LCI 301                ;Load the ASCII code for letter A into register C
1040 07-204 104 226 002            JMP ERROR              ;Go display the FA error message
1041 07-207 066 202     FUNAR4:    LLI 202                ;Load L with address of TEMP COUNTER
1042 07-211 056 027                LHI \HB\OLDPG27        ;** Set H to page of TEMP COUNTER
1043 07-213 317                    LBM                    ;Load value in counter to register B. This is FUNCTION
1044 07-214 066 230                LLI 230                ;TOKEN VALUE. Cbange- L to F/A STACK pointer.
1045 07-216 056 026                LHI \HB\OLDPG26        ;** Load H with page of F/A STACK pointer.
1046 07-220 327                    LCM                    ;Fetch the F/A STACK pointer value into register C.
1047 07-221 106 036 023            CAL INDEXC             ;Form the address to the top of the F/A STACK.
1048 07-224 371                    LMB                    ;Store the FUNCTION TOKEN VALUE in the F/A
1049 07-225 104 255 002            JMP CLESYM             ;STACK. Then exit by clearing the SYMBOL BUFFER.
1050 07-230 301         TABADR:    LAB                    ;Move the TEMP COUNTER value from B to ACC
1051 07-231 002         TABAD1:    RLC                    ;Multiply by four using this loop to form value equal
1052 07-232 021                    DCC                    ;To number of bytes per entry (4) times current entry
1053 07-233 110 231 007            JFZ TABAD1             ;In the FUNCTION LOOK-UP TABLE.
1054 07-236 206                    ADL                    ;Add this value to the starting address of the table.
1055 07-237 360                    LLA                    ;Form pointer to next entry in table
1056 07-240 003                    RFC                    ;If no carry return to caller
1057 07-241 050                    INH                    ;Else, increment H before
1058 07-242 007                    RET                    ;Returning to caller
1059                    
1060                    ;;; The label INTX SHOULD BE AT 07 243
1061 07-243 066 126     INTX:      LLI 126                ;Load L with address of MSW of the FPACC
1062 07-245 056 001                LHI \HB\OLDPG1         ;** Load H with the page of the PPACC
1063 07-247 307                    LAM                    ;Fetch the MSW of the FPACC into the accumulator
1064 07-250 240                    NDA                    ;Test the sign of the number in the FPACC. If
1065 07-251 120 327 007            JFS INT1               ;Positive jump ahead to integerize
1066 07-254 066 014                LLI 014                ;If negative, load L with address of FP TEMP registers
1067 07-256 106 255 022            CAL FSTORE             ;Store the value in the FPACC in FP TEMP
1068 07-261 106 000 020            CAL FPFIX              ;Convert the value in FPACC from floating point to
1069 07-264 066 123                LLI 123                ;Fixed point. Load L with address of FPACC
1070 07-266 076 000                LMI 000                ;Extension register and clear it.
1071 07-270 106 064 020            CAL FPFLT              ;Convert fixed binary back to FP to integerize
1072 07-273 066 014                LLI 014                ;Load L with address of FP TEMP registers
1073 07-275 106 266 022            CAL OPLOAD             ;Load the value in FP TEMP into FPOP
1074 07-300 106 032 021            CAL FPSUB              ;Subtract integerized value from original
1075 07-303 066 126                LLI 126                ;Set L to address of MSW of FPACC
1076 07-305 307                    LAM                    ;Fetch the MSW of the FPACC into the accumulator
1077 07-306 240                    NDA                    ;See if original value and integerized value the same
1078 07-307 150 341 007            JTZ INT2               ;If so, have integer value in FP TEMP
1079 07-312 066 014                LLI 014                ;Else, load L with address of FP TEMP registers
1080 07-314 106 244 022            CAL FLOAD              ;Restore FPACC to original (non-integerized) value
1081 07-317 066 024                LLI 024                ;Set L to register containing small value
1082 07-321 106 277 022            CAL FACXOP             ;Set up to add small value to original value in FPACC
1083 07-324 106 211 020            CAL FPADD              ;Perform the addition
1084 07-327 106 000 020 INT1:      CAL FPFIX              ;Convert the number in FPACC from floating point
1085 07-332 066 123                LLI 123                ;To fixed point. Load L with address of FPACC
1086 07-334 076 000                LMI 000                ;Extension register and clear it. Now convert the number
1087 07-336 104 064 020            JMP FPFLT              ;Back to floating point to integerize it and exit to caller
1088 07-341 066 014     INT2:      LLI 014                ;Load L with address of FP TEMP registers. Transfer
1089 07-343 104 244 022            JMP FLOAD              ;Number from FP TEMP (orig) to FPACC and return.
1090 07-346 066 126     ABSX:      LLI 126                ;Load L with address of MSW of the FPACC
1091 07-350 056 001                LHI \HB\OLDPG1         ;** Set H to page of the FPACC
1092 07-352 307                    LAM                    ;Fetch the MSW of the FPACC into the accumulator
1093 07-353 240                    NDA                    ;Test the sign of the number to see if it is positive.
1094 07-354 160 202 020            JTS FPCOMP             ;If negative, complement the number before returning.
1095 07-357 007                    RET                    ;Else, just return with absolute value in the FPACC.
1096 07-360 066 126     SGNX:      LLI 126                ;Load L with address of MSW of the FPACC
1097 07-362 056 001                LHI \HB\OLDPG1         ;** Load H with the page of the FPACC
1098 07-364 307                    LAM                    ;Fetch the MSW of the FPACC into the accumulator
1099 07-365 240                    NDA                    ;Test to see if the FPACC is zero
1100 07-366 053                    RTZ                    ;Return to caller if FPACC is zero
1101 07-367 120 242 006            JFS FPONE              ;If FPACC is positive, load +1.0 into FPACC and exit
1102 07-372 066 024                LLI 024                ;If FPACC is negative, set up to load -1.0 into the
1103 07-374 104 244 022            JMP FLOAD              ;FPACC and exit to caller
1104 07-377 106 000 020 CHRX:      CAL FPFIX              ;Convert contents of FPACC from floating point to
1105 10-002 066 124                LLI 124                ;Fixed point. Load L with address of LSW of fixed
1106 10-004 307                    LAM                    ;Value. Fetch this byte into the accumulator.
1107 10-005 106 202 003            CAL ECHO               ;Display the value.
1108 10-010 066 177                LLI 177                ;Set L to address of the TAB FLAG
1109 10-012 056 026                LHI \HB\OLDPG26        ;** Set H to page of the TAB FLAG
1110 10-014 076 377                LMI 377                ;Set TAB FLAG (to inhibit display of FP value)
1111 10-016 007                    RET                    ;Exit to caller.
1112 10-017 106 000 020 TABX:      CAL FPFIX              ;Convert contents of FPACC from floating point to
1113 10-022 066 124     TAB1:      LLI 124                ;Fixed point. Load L with address of 1,SW of fixed
1114 10-024 307                    LAM                    ;Value. Fetch this byte into the accumulator.
1115 10-025 066 043                LLI 043                ;Load L with address of COLUMN COUNTER
1116 10-027 227                    SUM                    ;Subtract value in C-OLUMN COUNTER from desired
1117 10-030 066 177                LLI 177                ;TAB position. Load L with address of the TAB FLAG.
1118 10-032 056 026                LHI \HB\OLDPG26        ;** Set H to page of the TAB FLAG.
1119 10-034 076 377                LMI 377                ;Set TAB FLAG (to inhibit display of FP value)
1120 10-036 160 217 031            JTS BACKSP             ;If beyond TAB point desired, simulate back spacing
1121 10-041 053                    RTZ                    ;Return to caller if at desired TAB location
1122 10-042 320         TABC:      LCA                    ;Else, put difference count in register C
1123 10-043 006 240                LAI 240                ;Place ASCII code for space in ACC
1124 10-045 106 202 003 TABLOP:    CAL ECHO               ;Display space on output device
1125 10-050 021                    DCC                    ;Decrement displacement counter
1126 10-051 110 045 010            JFZ TABLOP             ;If have not reached TAB position, continue to space
1127 10-054 007                    RET                    ;Else, return to calling routine.
1128                    
1129                    ;;; The label STOSYM should be AT 10 055
1130 10-055 066 201     STOSYM:    LLI 201                ;Load L with address of ARRAY FLAG
1131 10-057 056 027                LHI \HB\OLDPG27        ;** Load H with page of ARRAY FLAG
1132 10-061 307                    LAM                    ;Fetch the value of the ARRAY FLAG into the ACC
1133 10-062 240                    NDA                    ;Check to see if the flag is set indicating processing an
1134 10-063 150 100 010            JTZ STOSY1             ;Array variable value. Jump ahead if flag not set.
1135 10-066 076 000                LMI 000                ;If ARRAY FLAG was set, clear it for next time.
1136 10-070 066 204                LLI 204                ;Then load L with address of array address storage loc
1137 10-072 367                    LLM                    ;Fetch the array storage address as new pointer
1138 10-073 056 057                LHI \HB\OLDPG57        ;tt Set H to ARRAY VALUES page   ****************
1139 10-075 104 255 022            JMP FSTORE             ;Store the array variable value and exit to caller.
1140 10-100 066 370     STOSY1:    LLI 370                ;Load L with address of TEMP CNTR
1141 10-102 056 026                LHI \HB\OLDPG26        ;** Load H with page of TEMP CNTR
1142 10-104 076 000                LMI 000                ;Initialize the TEMP CNTR by clearing it
1143 10-106 066 120                LLI 120                ;Load L with starting address of SYMBOL BUFFER
1144 10-110 036 027                LDI \HB\OLDPG27        ;** Load D with page of VARIABLES LOOK-UP table
1145 10-112 046 210                LEI 210                ;Load E with starting addr of VARIABLES LOOK-UP
1146 10-114 307                    LAM                    ;Table. Fetch the (cc) for the SYMBOL BUFFER into
1147 10-115 074 001                CPI 001                ;The ACC and see if length of variable name is just one
1148 10-117 110 126 010            JFZ STOSY2             ;Character. If not, skip next couple of instructions.
1149 10-122 066 122                LLI 122                ;Else, set pointer to second character location in the
1150 10-124 076 000                LMI 000                ;SYMBOL BUFFER and set it to zero
1151 10-126 066 121     STOSY2:    LLI 121                ;load L with address of first character in the SYMBOL
1152 10-130 056 026                LHI \HB\OLDPG26        ;** BUFFER. Load H with page of the buffer.
1153 10-132 106 356 022            CAL SWITCH             ;Exchange pointer to buffer for pointer to VARIABLES
1154 10-135 307                    LAM                    ;LOOK-UP table. Fetch first char in a name from the
1155 10-136 060                    INL                    ;Table. Advance the pointer to second char in a name.
1156 10-137 317                    LBM                    ;Fetch the second character into register B.
1157 10-140 060                    INL                    ;Advance the pointer to first byte of a value in the table.
1158 10-141 106 356 022            CAL SWITCH             ;Exchange table pointer for pointer to SYMBOL BUFF
1159 10-144 277                    CPM                    ;Compare first character in buffer against first character
1160 10-145 110 156 010            JFZ STOSY3             ;In table entry. If no match, try next entry in the table.
1161 10-150 060                    INL                    ;If match, advance pointer to second character in buffer.
1162 10-151 301                    LAB                    ;Move second character obtained from table into ACC.
1163 10-152 277                    CPM                    ;Compare second characters in table and buffer.
1164 10-153 150 227 010            JTZ STOSY5             ;If same, have found the variable name in the table.
1165 10-156 106 256 006 STOSY3:    CAL AD4DE              ;Add four to pointer in registers D&E to skip over value
1166 10-161 066 370                LLI 370                ;Portion of entry in table. Load L with address of TEMP
1167 10-163 056 026                LHI \HB\OLDPG26        ;** CNTR. Load H with page of TEMP CNTR.
1168 10-165 317                    LBM                    ;Fetch the counter
1169 10-166 010                    INB                    ;Increment the counter
1170 10-167 371                    LMB                    ;Restore it to storage
1171 10-170 066 077                LLI 077                ;Set L to address of VARIABLES CNTR (indicates
1172 10-172 056 027                LHI \HB\OLDPG27        ;** Number of variables currently in table.) Set H too
1173 10-174 301                    LAB                    ;Move the TEMP CNTR value into the ACC. (Number of
1174 10-175 277                    CPM                    ;Entries checked.) Compare with number of entries in
1175 10-176 110 126 010            JFZ STOSY2             ;The table. If have not checked all entries, try next one.
1176 10-201 066 077                LLI 077                ;If have checked all entries, load L with address of the
1177 10-203 056 027                LHI \HB\OLDPG27        ;** VARIABLES CNTR. Set H too. Fetch the counter
1178 10-205 317                    LBM                    ;Value and incrernent it to account for
1179 10-206 010                    INB                    ;New variable nwne that will now be
1180 10-207 371                    LMB                    ;Added to the table. Save the new value.
1181 10-210 301                    LAB                    ;Place the new counter value into the accumulator
1182 10-211 074 025                CPI 025                ;And check to see that adding new variable name to the
1183 10-213 120 222 002            JFS BIGERR             ;Table will not cause table overflow. Big Error if it does!
1184 10-216 066 121                LLI 121                ;If room available in table, set L to address of first
1185 10-220 056 026                LHI \HB\OLDPG26        ;** Caracter in the SYMBOL BUFFER. Set H too.
1186 10-222 016 002                LBI 002                ;Set a counter for number of characters to transfer.
1187 10-224 106 013 021            CAL MOVEIT             ;Move the variable name from buffer to table.
1188 10-227 106 356 022 STOSY5:    CAL SWITCH             ;Exchange buffer pointer for table pointer.
1189 10-232 106 255 022            CAL FSTORE             ;Transfer new mathematical value into the table.
1190 10-235 104 255 002            JMP CLESYM             ;Clear the SYMBOL BUFFER and exit to calling routine.
1191                    
1192                                                      ;The subroutines below are used by some of the routines
1193                                                      ;in this chapter as well as other parts of the program.
1194                    
1195 10-240 066 120     SAVESY:    LLI 120                ;Load L with the address of the start of the SYMBOL
1196 10-242 056 026                LHI \HB\OLDPG26        ;** BUFFER. Load H with the page of the buffer.
1197 10-244 335                    LDH                    ;Load register D with the page of the AUX SYMBOL
1198 10-245 046 144                LEI 144                ;BUFFER and set register E to start of that buffer.
1199 10-247 104 261 010            JMP MOVECP             ;Transfer SYMBOL BF contents to AUX SYMBOL BF
1200                    
1201 10-252 066 144     RESTSY:    LLI 144                ;Load L with address of start of AUX SYMBOL BUFF
1202 10-254 056 026                LHI \HB\OLDPG26        ;** Load H with page of AUX SYMBOL BUFFER
1203 10-256 335                    LDH                    ;Set D to page of SYMBOL BUFFER (same as H)
1204 10-257 046 120                LEI 120                ;Load E with start of SYMBOL BUFFER
1205 10-261 317         MOVECP:    LBM                    ;Load (cc) for source string (first byte in source buffer)
1206 10-262 010                    INB                    ;Add one to (cc) to include (cc) byte itself
1207 10-263 104 013 021            JMP MOVEIT             ;Move the source string to destination buffer
1208                    
1209                    ;;; The label Exec SHOULD BE AT 10 266 (This is the start of the code)
1210 10-266 066 352     EXEC:      LLI 352                ;Load L with address of READY message
1211 10-270 056 001                LHI \HB\OLDPG1         ;** Load H with page of READY message
1212 10-272 106 121 003            CAL TEXTC              ;Call subroutine to display the READY message
1213                    
1214 10-275 066 000     EXEC1:     LLI 000                ;Load L with starting address of INPUT LINE BUFFER
1215 10-277 056 026                LHI \HB\OLDPG26        ;** Load H with page of INPUT LINE BUFFER
1216 10-301 106 014 003            CAL STRIN              ;Call subroutine to input a line into the buffer
1217 10-304 307                    LAM                    ;The STRIN subroutine will exit with pointer set to the
1218 10-305 240                    NDA                    ;CHARACTER COUNT for the line inputted. Fetch the
1219 10-306 150 275 010            JTZ EXEC1              ;Value of the counter, if it is zero then line was blank.
1220 10-311 066 335                LLI 335                ;Load L with address of LIST in look up table
1221 10-313 056 001                LHI \HB\OLDPG1         ;Load H with address of LIST in look up table
1222 10-315 036 026                LDI \HB\OLDPG26        ;Load D with page of line input buffer
1223 10-317 046 000                LEI 000                ;Load E with start of line input buffer
1224 10-321 106 332 002            CAL STRCP              ;Call string compare subroutine to see if first word in
1225 10-324 110 354 010            JFZ NOLIST             ;Input buffer is LIST. Jump 3 ahead if not LIST.
1226 10-327 066 000                LLI 000                ;If LIST, set up pointers to start of USER PROGRAM
1227 10-331 056 033                LHI BGNPGRAM           ;BUFFER. (Note user could alter this starting addr)   *****
1228                    
1229                                                      ;Next portion of program will LIST the contents of the
1230                                                      ;USER PROGRAM BUFFER until an end of buffer
1231                                                      ;(zero byte) indicator is detected.
1232                    
1233 10-333 307         LIST:      LAM                    ;Fetch the first byte of a line in the USER PROGRAM
1234 10-334 240                    NDA                    ;BUFFER and see if it is zero. If so, have finished LIST
1235 10-335 150 266 010            JTZ EXEC               ;So go back to start of Executive and display READY.
1236 10-340 106 121 003            CAL TEXTC              ;Else call subroutine to display a line of information
1237 10-343 106 377 002            CAL ADV                ;Now call subroutine to advance buffer pointer to
1238 10-346 106 141 003            CAL CRLF               ;Character count in next line. Also display a CR & LF.
1239 10-351 104 333 010            JMP LIST               ;Continue LISTing process
1240                    
1241                                                      ;If line inputted by operator did not contain a LIST comman
1242                                                      ;continue program to see if RUN or SCRatch command.
1243                    
1244 10-354 066 342     NOLIST:    LLI 342                ;Load L with address of RUN in look up table
1245 10-356 056 001                LHI \HB\OLDPG1         ;** Load H with address of RUN in look up table
1246 10-360 046 000                LEI 000                ;Load E with start of line input buffer
1247 10-362 036 026                LDI \HB\OLDPG26        ;** Load D with page of line input buffer
1248 10-364 046 000                LEI 000                ;(Reserve 2 locs in case of patching by duplicating above)
1249 10-366 106 332 002            CAL STRCP              ;Call string compare subroutine to see if first word in
1250 10-371 150 070 013            JTZ RUN                ;Input buffer is RUN. Go to RUN routine if match.
1251 10-374 036 026                LDI \HB\OLDPG26        ;** If not RUN command, reset address pointers back
1252 10-376 046 000                LEI 000                ;To the start of the line input buffer
1253 11-000 066 346                LLI 346                ;Load L with address of SCR in look up table
1254 11-002 056 001                LHI \HB\OLDPG1         ;** Load H with page of SCR in look up table
1255 11-004 106 332 002            CAL STRCP              ;Call string compare subroutine to see if first word in
1256 11-007 110 071 011            JFZ NOSCR              ;Input buffer is SCR. If not then jump ahead.
1257 11-012 056 026                LHI \HB\OLDPG26        ;** If found SCR command then load memory pointer
1258 11-014 066 364                LLI 364                ;With address of a pointer storage location. Set that
1259 11-016 076 033                LMI BGNPGRAM           ;tt Storage location to page of start of USER PRO-  *******
1260 11-020 060                    INL                    ;GRAM BUFFER. (Buffer start loc may be altered).
1261 11-021 076 000                LMI 000                ;Then adv pntr and do same for low addr portion of pntr
1262 11-023 066 077                LLI 077                ;Now set pointer to address of VARIABLES counter
1263 11-025 056 027                LHI \HB\OLDPG27        ;** Storage location. Initialize this counter by placing
1264 11-027 076 001                LMI 001                ;The count of one into it. Now change the memory pntr
1265                    ;MGA 3/31/12 put it back to 001; solves nested FOR/NEXT, but limits vars to 19
1266                    ;   as the letter from James Tucker (1/77) mentioned
1267                    ;   apparently, James didn't test FOR/NEXT; original Loboyko didn't have this
1268                    ;;;           LMI 001                ;The count of one into it. Now change the memory pntr
1269                    ;;; Apparently, in Page 3 of Issue 4 of Scelbal update (1/77) they say the above should change.
1270                    ;;; This makes the SCR command clear the whole variable space, otherwise one space is lost.  
1271 11-031 066 075                LLI 075                ;To storage location for number of dimensioned arrays
1272 11-033 076 000                LMI 000                ;@@ And initialize to zero. (@@ = Substitute NOPs if
1273 11-035 066 120                LLI 120                ;@@ DIMension capability not used in package.) Also
1274 11-037 076 000                LMI 000                ;@@ Initialize l'st byte of array name table to zero.
1275 11-041 066 210                LLI 210                ;Set pointer to storage location for the first byte of the
1276 11-043 076 000                LMI 000                ;VARIABLES symbol table. Initialize it to zero too.
1277 11-045 060                    INL                    ;Advance the pointer and zero the second location
1278 11-046 076 000                LMI 000                ;In the Variables table also.
1279 11-050 056 033                LHI BGNPGRAM           ;tt Load H with page of start of USER PROGRAM    **********
1280 11-052 066 000                LLI 000                ;BUFFER. (Buffer start location could be altered.)
1281 11-054 076 000                LMI 000                ;Clear first location to indicate end of user program.
1282 11-056 056 057                LHI \HB\OLDPG57        ;@@ Load H with page of ARRAYS storage
1283 11-060 076 000     SCRLOP:    LMI 000                ;@@ And form a loop to clear out all the locations
1284 11-062 060                    INL                    ;@@ On the ARRAYS storage page. (@@ These become
1285 11-063 110 060 011            JFZ SCRLOP             ;@@ NOPs if DIMension capability deleted fm package.)
1286 11-066 104 266 010            JMP EXEC               ;SCRatch operations completed, go back to EXEC.
1287                    
1288                                                      ;If line inputted did not contain RUN or SCRatch com-
1289                                                      ;mand, program continues by testing for SAVE or LOAD
1290                                                      ;commands. If it does not find either of these com-
1291                                                      ;mands, then operator did not input an executive com-
1292                                                      ;mand. Program then sets up to see if the first entry in
1293                                                      ;the line inputted is a LINE NUMBER.
1294                    
1295 11-071 046 272     NOSCR:     LEI 272                ;Load E with address of SAVE in look up table
1296 11-073 036 001                LDI \HB\OLDPG1         ;Load D with page of look up table
1297 11-075 056 026                LHI \HB\OLDPG26        ;Load H with page of input line buffer
1298 11-077 066 000                LLI 000                ;Set L to start of input line buffer
1299 11-101 106 332 002            CAL STRCP              ;Call string compare subroutine to see if first word in
1300 11-104 150 100 000            JTZ SAVE               ;tt Input buffer is SAVE. If so, go to user's SAVE rtn
1301 11-107 066 277                LLI 277                ;If not SAVE then load L with address of LOAD in look
1302 11-111 056 001                LHI \HB\OLDPG1         ;Up table and load H with page of look up table
1303 11-113 036 026                LDI \HB\OLDPG26        ;Load D with page of input line buffer
1304 11-115 046 000                LEI 000                ;And L to start of input line buffer
1305 11-117 106 332 002            CAL STRCP              ;Call string compare subroutine to see if first word in
1306 11-122 150 100 000            JTZ LOAD               ;tt Input buffer is LOAD. If so, go to user's LOAD rtn
1307 11-125 066 360                LLI 360                ;If not LOAD then set pointer to address of storage loc
1308 11-127 056 026                LHI \HB\OLDPG26        ;** For USER PROGRAM BUFFER pointer. Initialize this
1309 11-131 076 033                LMI BGNPGRAM           ;tt Pointer to the starting address of the program buffer.
1310 11-133 060                    INL                    ;Advance memory pntr. Since pointer storage requires
1311 11-134 076 000                LMI 000                ;Two locations, initialize the low addr portion also.
1312 11-136 106 000 002            CAL SYNTAX             ;Call the SYNTAX subroutine to obtain a TOKEN indi-
1313 11-141 066 203                LLI 203                ;Cator which will be stored in this location. Upon return
1314 11-143 056 026                LHI \HB\OLDPG26        ;** From SYNTAX subroutine set memory pointer to
1315 11-145 307                    LAM                    ;The TOKEN indicator storage location and fetch the
1316 11-146 240                    NDA                    ;Value of the TOKEN. If the value of the syntax TOKEN
1317 11-147 120 161 011            JFS SYNTOK             ;Is positive then have a valid entry.
1318 11-152 006 323     SYNERR:    LAI 323                ;However, if SYNTAX returns a negative value TOKEN
1319 11-154 026 331                LCI 331                ;Then have an error condition. Set up the letters SY in
1320 11-156 104 226 002            JMP ERROR              ;ASCII code and go to display error message to operator.
1321 11-161 066 340     SYNTOK:    LLI 340                ;Set pointer to start of LINE NUMBER storage area
1322 11-163 307                    LAM                    ;First byte there will contain the length of the line
1323 11-164 240                    NDA                    ;Number character string. Fetch that value (cc).
1324 11-165 150 211 013            JTZ DIRECT             ;DIRECT If line number blank, have a DIRECT statement!
1325 11-170 066 360                LLI 360                ;If have a line number must get line in input buffer into
1326 11-172 076 033                LMI BGNPGRAM           ;tt User program buffer. Initialize pointer to user buffer.
1327 11-174 060                    INL                    ;This is a two byte pointer so after initializing page addr
1328 11-175 076 000                LMI 000                ;Advance pointer and initialize location on page address
1329                    
1330                                                      ;If the line in the LINE INPUT BUFFER has a line num-
1331                                                      ;ber then the line is to be placed in the USER PRO-
1332                                                      ;GRAM BUFFER. It is now necessary to determine
1333                                                      ;where the new line is to be placed in the USER PRO-
1334                                                      ;GRAM BUFFER. This is dictated by the value of the
1335                                                      ;new line number in relation to the line numbers cur-
1336                                                      ;rently in the program buffer. The next portion of the
1337                                                      ;program goes through the contents of the USER PRO-
1338                                                      ;GRAM BUFFER comparing the values of the line num-
1339                                                      ;bers already stored against the value of the line number
1340                                                      ;currently being held in the LINE INPUT BUFFER.
1341                                                      ;Appropriate action is then taken to Insert or Append,
1342                                                      ;Change, or Delete a line in the program buffer.
1343                    
1344 11-177 066 201     GETAUX:    LLI 201                ;Set memory pointer to line character pointer storage
1345 11-201 056 026                LHI \HB\OLDPG26        ;** Location and then initialize that storage location
1346 11-203 076 001                LMI 001                ;To point to the 1'st character in a line
1347 11-205 066 350                LLI 350                ;Set memory pointer to addr of start of auxiliary line
1348 11-207 076 000                LMI 000                ;Number storage area and initialize first byte to zero
1349 11-211 066 201     GETAU0:    LLI 201                ;Set memory pointer to line character pointer storage loc
1350 11-213 106 123 012            CAL GETCHP             ;Fetch a char in line pointed to by line pointer
1351 11-216 150 242 011            JTZ GETAU1             ;If character is a space, skip it by going to advance pntrs
1352 11-221 074 260                CPI 260                ;If not a space check to see if character represents a
1353 11-223 160 267 011            JTS GETAU2             ;Valid decimal digit in the range 0 to 9 by testing the
1354 11-226 074 272                CPI 272                ;ASCII code value obtained. If not a deciznal digit then
1355 11-230 120 267 011            JFS GETAU2             ;Assume have obtained the line number. Go process.
1356 11-233 066 350                LLI 350                ;If valid decimal digit want to append the digit to the
1357 11-235 056 026                LHI \HB\OLDPG26        ;** Current string being built up in the auxiliary line
1358 11-237 106 314 002            CAL CONCT1             ;Number storage area so call sub to concat a character.
1359 11-242 066 201     GETAU1:    LLI 201                ;Reset memory pointer to line character pntr storage loc
1360 11-244 056 026                LHI \HB\OLDPG26        ;On the appropriate page.
1361 11-246 317                    LBM
1362 11-247 010                    INB                    ;Fetch the pointer, increment it, and restore new value
1363 11-250 371                    LMB
1364 11-251 066 360                LLI 360                ;Set memory pointer to pgm buff line pntr storage loc
1365 11-253 056 026                LHI \HB\OLDPG26
1366 11-255 327                    LCM                    ;Bring the high order byte of this double byte pointer
1367 11-256 060                    INL                    ;Into CPU register C. Then advance the memory pntr
1368 11-257 367                    LLM                    ;And bring the low order byte into register L. Now trans-
1369 11-260 352                    LHC                    ;Fer the higher order portion into memory pointer H.
1370 11-261 307                    LAM                    ;Obtain the char cntr (cc) which indicates the length of
1371 11-262 011                    DCB                    ;The line being pointed to by the user program line pntr
1372 11-263 271                    CPB                    ;Compare this with the value of the chars processed so
1373 11-264 110 211 011            JFZ GETAU0             ;Far in current line. If not equal, continue getting line n
1374 11-267 066 360     GETAU2:    LLI 360                ;Reset mem pntr to pgm buffer line pntr storage
1375 11-271 056 026                LHI \HB\OLDPG26        ;** On this page and place the high order byte
1376 11-273 337                    LDM                    ;Of this pointer into CPU register D
1377 11-274 060                    INL                    ;Advance the memory pointer, fetch the second
1378 11-275 367                    LLM                    ;Byte of the pgm buffer line pointer into register L
1379 11-276 353                    LHD                    ;Now make the memory pointer equal to this value
1380 11-277 307                    LAM                    ;Fetch the first byte of a line in the program buffer
1381 11-300 240                    NDA                    ;Test to see if end of contents of pgm buff (zero byte)
1382 11-301 110 336 011            JFZ NOTEND             ;If not zero continue processing. If zero have reached
1383 11-304 104 005 012            JMP NOSAME             ;End of buffer contents so go APPEND line to buffer.
1384                    ;;; there are some open addresses here.  Above JUMP starts at 11-304;
1385                    ;;; The below label patch3 should start at 11 307
1386 11-307 066 201     PATCH3:	   LLI 201		; ptr to A/V storage
1387 11-311 056 027     	   LHI \HB\OLDPG27      ; MGA 3/31/12 make relocatable; prev: LHI 027
1388 11-313 076 000     	   LMI 000		; clear A/V flag
1389 11-315 104 266 010 	   JMP EXEC
1390                    
1391                    	ORG 011#336		
1392 11-336 066 350     NOTEND:    LLI 350                ;Load L with addr of auxiliary line number storage loc
1393 11-340 056 026                LHI \HB\OLDPG26        ;Load H with addr of aux line number storage loc
1394 11-342 036 026                LDI \HB\OLDPG26        ;Load D with addr of line number buffer location
1395 11-344 046 340                LEI 340                ;Load E with address of line number buffer location
1396 11-346 106 332 002            CAL STRCP              ;Compare line nr in input buffer with line number in
1397 11-351 160 073 012            JTS CONTIN             ;User program buffer. If lesser in value keep looking.
1398 11-354 110 005 012            JFZ NOSAME             ;If greater in value then go to Insert line in pgm buffer
1399 11-357 066 360                LLI 360                ;If same values then must remove the line with the same
1400 11-361 056 026                LHI \HB\OLDPG26        ;** Line number from the user program buffer. Set up
1401 11-363 327                    LCM                    ;The CPU memory pointer to point to the current
1402 11-364 060                    INL                    ;Position in the user program buffer by retrieving that
1403 11-365 367                    LLM                    ;Pointer from its storage location. Then obtain the first
1404 11-366 352                    LHC                    ;Byte of data pointed to which will be the character
1405 11-367 317                    LBM                    ;Count for that line (cc). Add one to the cc value to take
1406 11-370 010                    INB                    ;Account of the (cc) byte itself and then remove that
1407 11-371 106 144 012            CAL REMOVE             ;Many bytes to effectively delete the line fm the user
1408 11-374 066 203                LLI 203                ;Program buffer. Now see if line in input buffer consists
1409 11-376 056 026                LHI \HB\OLDPG26        ;** Only of a line number by checking SYNTAX
1410 12-000 307                    LAM                    ;TOKEN value. Fetch the TOKEN value from its
1411 12-001 240                    NDA                    ;Storage location. If it is zero then input buffer only
1412 12-002 150 266 010            JTZ EXEC               ;Contains a line number. Action is a pure Delete.
1413 12-005 066 360     NOSAME:    LLI 360                ;Reset memory pointer to program buffer
1414 12-007 056 026                LHI \HB\OLDPG26        ;Line pointer storage location
1415 12-011 337                    LDM                    ;Load high order byte into CPU register D
1416 12-012 060                    INL                    ;Advance memory pointer
1417 12-013 347                    LEM                    ;Load low order byte into CPU register E
1418 12-014 066 000                LLI 000                ;Load L with address of start of line input buffer
1419 12-016 056 026                LHI \HB\OLDPG26        ;** Do same for CPU register H
1420 12-020 317                    LBM                    ;Get length of line input buffer
1421 12-021 010                    INB                    ;Advance length by one to include (cc) byte
1422 12-022 106 205 012            CAL INSERT             ;Go make room to insert line into user program buffer
1423 12-025 066 360                LLI 360                ;Reset memory pointer to program buffer
1424 12-027 056 026                LHI \HB\OLDPG26        ;** Line pointer storage location
1425 12-031 337                    LDM                    ;Load higher byte into CPU register D
1426 12-032 060                    INL                    ;Advance memory pointer
1427 12-033 347                    LEM                    ;Load low order byte into CPU register E
1428 12-034 066 000                LLI 000                ;Load L with address of start of line input buffer
1429 12-036 056 026                LHI \HB\OLDPG26        ;** Do same for CPU register H
1430 12-040 106 046 012            CAL MOVEC              ;Call subroutine to Insert line in input buffer into the
1431 12-043 104 275 010            JMP EXEC1              ;User program buffer then go back to start of EXEC.
1432 12-046 317         MOVEC:     LBM                    ;Fetch length of string in line input buffer
1433 12-047 010                    INB                    ;Increment that value to provide for (cc)
1434 12-050 307         MOVEPG:    LAM                    ;Fetch character from line input buffer
1435 12-051 106 377 002            CAL ADV                ;Advance pointer for line input buffer
1436 12-054 106 356 022            CAL SWITCH             ;Switch memory pointer to point to user pgm buffer
1437 12-057 370                    LMA                    ;Deposit character fm input buff into user pgm buff
1438 12-060 106 377 002            CAL ADV                ;Advance pointer for user program buffer
1439 12-063 106 356 022            CAL SWITCH             ;Switch memory pntr back to point to input buffer
1440 12-066 011                    DCB                    ;Decrement character counter stored in CPU register B
1441 12-067 110 050 012            JFZ MOVEPG             ;If counter does not go to zero continue transfer ops
1442 12-072 007                    RET                    ;When counter equals zero return to calling routine
1443 12-073 066 360     CONTIN:    LLI 360                ;Reset memory pointer to program buffer
1444 12-075 056 026                LHI \HB\OLDPG26        ;** Line pointer storage location
1445 12-077 337                    LDM                    ;Load high order byte into CPU register D
1446 12-100 060                    INL                    ;Advance memory pointer
1447 12-101 347                    LEM                    ;Load low order byte into CPU register E
1448 12-102 353                    LHD                    ;Now set CPU register H to high part of address
1449 12-103 364                    LLE                    ;And set CPU register L to low part of address
1450 12-104 317                    LBM                    ;Fetch the character counter (cc) byte fm line in
1451 12-105 010                    INB                    ;Program buffer and add one to compensate for (cc)
1452 12-106 106 305 012            CAL ADBDE              ;Add length of line value to old value to get new pointer
1453 12-111 066 360                LLI 360                ;Reset memory pointer to program buffer
1454 12-113 056 026                LHI \HB\OLDPG26        ;** Line pointer storage location
1455 12-115 373                    LMD                    ;Restore new high portion
1456 12-116 060                    INL                    ;Advance memory pointer
1457 12-117 374                    LME                    ;And restore new low portion
1458 12-120 104 177 011            JMP GETAUX             ;Continue til find point at which to enter new line
1459 12-123 056 026     GETCHP:    LHI \HB\OLDPG26        ;** Load H with pointer page (low portion set upon
1460 12-125 317                    LBM                    ;Entry). Now fetch pointer into CPU register B.
1461 12-126 066 360                LLI 360                ;Reset pntr to pgm buffer line pointer storage location
1462 12-130 337                    LDM                    ;Load high order byte into CPU register D
1463 12-131 060                    INL                    ;Advance memory pointer
1464 12-132 347                    LEM                    ;Load low order byte into CPU register E
1465 12-133 106 305 012            CAL ADBDE              ;Add pointer to pgm buffer pointer to obtain address of
1466 12-136 353                    LHD                    ;Desired character. Place high part of new addr in H.
1467 12-137 364                    LLE                    ;And low part of new address in E.
1468 12-140 307                    LAM                    ;Fetch character from position in line in user pgm buffer
1469 12-141 074 240                CPI 240                ;See if it is the ASCII code for space
1470 12-143 007                    RET                    ;Return to caller with flags set to indicate result
1471 12-144 106 174 003 REMOVE:    CAL INDEXB             ;Add (cc) plus one to addr of start of line
1472 12-147 327                    LCM                    ;Obtain byte from indexed location and
1473 12-150 106 113 003            CAL SUBHL              ;Subtract character count to obtain old location
1474 12-153 372                    LMC                    ;Put new byte in old location
1475 12-154 302                    LAC                    ;As well as in the Accumulator
1476 12-155 240                    NDA                    ;Test to see if zero byte to indicate end of user pgm buff
1477 12-156 150 167 012            JTZ REMOV1             ;If it is end of user pgm buffer, go complete process
1478 12-161 106 377 002            CAL ADV                ;Otherwise add one to the present pointer value
1479 12-164 104 144 012            JMP REMOVE             ;And continue removing chamcters from the user pgm bf
1480 12-167 066 364     REMOV1:    LLI 364                ;Load L with end of user pgm buffer pointer storage loc
1481 12-171 056 026                LHI \HB\OLDPG26        ;** Load H with page of that pointer storage location
1482 12-173 337                    LDM                    ;Get page portion of end of pgm buffer address
1483 12-174 060                    INL                    ;Advance memory pointer
1484 12-175 307                    LAM                    ;And get low portion of end of pgm buffer address into
1485 12-176 221                    SUB                    ;Accumulator then subtract displacement value in B
1486 12-177 370                    LMA                    ;Restore new low portion of end of pgm buffer address
1487 12-200 003                    RFC                    ;If subtract did not cause carry can return now
1488 12-201 061                    DCL                    ;Otherwise decrement memory pointer back to page
1489 12-202 031                    DCD                    ;Storage location, decrement page value to give new page
1490 12-203 373                    LMD                    ;And store new page value back in buffer pntr storage loc
1491 12-204 007                    RET                    ;Then return to calling routine
1492 12-205 066 364     INSERT:    LLI 364                ;Load L with end of user pgm buffer pointer storage loc
1493 12-207 056 026                LHI \HB\OLDPG26        ;** Load H with page of that pointer storage location
1494 12-211 307                    LAM                    ; Get page portion of end of program buffer address
1495 12-212 060                    INL                    ;Advance memory pointer
1496 12-213 367                    LLM                    ;Load low portion of end of program buffer address
1497 12-214 350                    LHA                    ;Into L and finish setting up memory pointer
1498 12-215 106 174 003            CAL INDEXB             ;Add (cc) of line in input buffer to form new end of
1499 12-220 305                    LAH                    ;Program buffer address. Fetch new end of buffer page
1500 12-221 074 055                CPI ENDPGRAM           ;tt Address and see if this value would exceed user's
1501 12-223 120 222 002            JFS BIGERR             ;System capabilit'y. Go display error message if so!
1502 12-226 106 113 003            CAL SUBHL              ;Else restore original value of end of buffer address
1503 12-231 327         INSER1:    LCM                    ;Bring byte pointed to by H & L into CPU register C
1504 12-232 106 174 003            CAL INDEXB             ;Add displacement value to current memory pointer
1505 12-235 372                    LMC                    ;Store the byte in the new location
1506 12-236 106 113 003            CAL SUBHL              ;Now subtract displacement value from H & L
1507 12-241 106 277 012            CAL CPHLDE             ;Compare this with the address stored in D & E
1508 12-244 150 255 012            JTZ INSER3             ;If same then go finish up Insert operation
1509 12-247 106 164 003            CAL DEC                ;Else set pointer to the byte before the byte just
1510 12-252 104 231 012            JMP INSER1             ;Processed and continue the Insert operation
1511                    INSER3:
1512 12-255 066 000     INCLIN:    LLI 000                ;Load L with start of line input buffer
1513 12-257 056 026                LHI \HB\OLDPG26        ;** Load H with page of start of line input buffer
1514 12-261 317                    LBM                    ;Fetch length of the line in line input buffer
1515 12-262 010                    INB                    ;Increment value by one to include (cc) byte
1516 12-263 066 364                LLI 364                ;Set memory pointer to end of user pgrn buffer pointer
1517 12-265 337                    LDM                    ;Storage location on same page and fetch page address
1518 12-266 060                    INL                    ;Of this pointer into D. Then advance memory pointer
1519 12-267 347                    LEM                    ;And get low part of this pointer into CPU register E.
1520 12-270 106 305 012            CAL ADBDE              ;Now add displacement (cc) of line in input buffer to
1521 12-273 374                    LME                    ;The end of program buffer pointer. Replace the updated
1522 12-274 061                    DCL                    ;Low portion of the new pointer value back in stomge
1523 12-275 373                    LMD                    ;And restore the new page value back into storage
1524 12-276 007                    RET                    ;Then return to calling routine
1525 12-277 305         CPHLDE:    LAH                    ;Subroutine to compare if the contents of CPU registers
1526 12-300 273                    CPD                    ;H & L are equal to registers D & E. First compare
1527 12-301 013                    RFZ                    ;Register H to D. Return with flags set if not equal. If
1528 12-302 306                    LAL                    ;Equal continue by comparing register L to E.
1529 12-303 274                    CPE                    ;IF L equals E then H & L equal to D & E so return to
1530 12-304 007                    RET                    ;Calling routines with flags set to equality status
1531 12-305 304         ADBDE:     LAE                    ;Subroutine to add the contents of CPU register B (single
1532 12-306 201                    ADB                    ;Byte value) to the double byte value in registers D & E.
1533 12-307 340                    LEA                    ;First add B to E to form new least significant byte
1534 12-310 003                    RFC                    ;Restore new value to E and exit if no carry resulted
1535 12-311 030                    IND                    ;If had a carry then must increment most significant byte
1536 12-312 007                    RET                    ;In register D before returning to calling routine
1537 12-313 006 336     CTRLC:     LAI 336                ;Set up ASCII code for t (up arrow) in Accumulator.
1538 12-315 026 303                LCI 303                ;Set up ASCII code for letter 'C' in CPU register C.
1539 12-317 104 226 002            JMP ERROR              ;Go display the 'Control C' condition message.
1540 12-322 066 340     FINERR:    LLI 340                ;Load L with starting address of line number storage area
1541 12-324 056 026                LHI \HB\OLDPG26        ;** Load H with page of line number storage area
1542 12-326 307                    LAM                    ;Get (cc) for line number string. If length is zero meaning
1543 12-327 240                    NDA                    ;There is no line number stored in the buffer then jump
1544 12-330 150 351 012            JTZ FINER1             ;Ahead to avoid displaying "AT LINE" message
1545 12-333 066 366                LLI 366                ;Else load L with address of start of "AT LINE" message
1546 12-335 056 001                LHI \HB\OLDPG1         ;** Stored on this page
1547 12-337 106 121 003            CAL TEXTC              ;Call subroutine to display the "AT LINE" message
1548 12-342 066 340                LLI 340                ;Now reset L to starting address of line number storage
1549 12-344 056 026                LHI \HB\OLDPG26        ;** Area and do same for CPU register H
1550 12-346 106 121 003            CAL TEXTC              ;Call subroutine to display the line number
1551 12-351 106 141 003 FINER1:    CAL CRLF               ;Call subroutine to provide a carriage-return and line-feed
1552 12-354 104 307 011 	   JMP PATCH3 
1553                    ;;; The following is the old code, before patch 3
1554                    ;;;           JMP EXEC               ;To the display device then return to EXECUTIVE.
1555 12-357 006 304     DVERR:     LAI 304                ;Set up ASCII code for letter 'D' in Accumulator
1556 12-361 026 332                LCI 332                ;Set up ASCII code for letter 'Z' in CPU register C
1557 12-363 104 226 002            JMP ERROR              ;Go display the 'DZ' (divide by zero) error message
1558 12-366 006 306     FIXERR:    LAI 306                ;Set up ASCII code for letter 'F' in Accumulator
1559 12-370 026 330                LCI 330                ;Set up ASCII code for letter 'X' in CPU register C
1560 12-372 104 226 002            JMP ERROR              ;Go display the 'FX' (FiX) error message
1561 12-375 006 311     NUMERR:    LAI 311                ;Set up ASCII code for letter 'I' in Accumulator
1562 12-377 026 316                LCI 316                ;Set up ASCII code for letter 'N' in CPU register C
1563 13-001 066 220                LLI 220                ;Load L with address of pointer used by DINPUT
1564 13-003 056 001                LHI \HB\OLDPG1         ;** Routine. Do same for register H.
1565 13-005 076 000                LMI 000                ;Clear the location
1566 13-007 104 226 002            JMP ERROR              ;Go display the'IN'(Illegal Number) error message
1567                    
1568                                                      ;The following subroutine, used by various sections of
1569                                                      ;SCELBAL, will search the LINE INPUT BUGGER for
1570                                                      ;a character string which is contained in a buffer starting
1571                                                      ;at the address pointed to by CPU registers H & L when
1572                                                      ;the subroutine is entered.
1573                    
1574 13-012 036 026     INSTR:     LDI \HB\OLDPG26        ;**Set D to starting page of LINE INPUT BUFFER
1575 13-014 046 000                LEI 000                ;Load E with starting location of LINE INPUT BUFFER
1576 13-016 106 064 013 INSTR1:    CAL ADVDE              ;Advancer D & E pointer to the next location (input
1577 13-021 106 317 022            CAL SAVEHL             ;Buffer). Now save contents of d, E, H & L vefore the
1578 13-024 317                    LBM                    ;Compare operations. Get length of TEST buffer in B.
1579 13-025 106 377 002            CAL ADV                ;Advance H & L buffer to first char in TEST buffer.
1580 13-030 106 370 002            CAL STRCPC             ;Compare contents of TEST buffer against input buffer
1581 13-033 150 337 022            JTZ RESTHL             ;For length B. If match, restore pntrs and exit to caller.
1582 13-036 106 337 022            CAL RESTHL             ;If no match, restore pointers for loop test.
1583 13-041 066 000                LLI 000                ;Load L with start of input buffer (to get the char cntr).
1584 13-043 056 026                LHI \HB\OLDPG26        ;**Load H with page of input buffer.
1585 13-045 307                    LAM                    ;Get length of buffer (cc) into the accumulator.
1586 13-046 274                    CPE                    ;Compare with current input buffer pointer value.
1587 13-047 150 061 013            JTZ INSTR2             ;If at end of buffer, jump ahead.
1588 13-052 106 337 022            CAL RESTHL             ;Else restore test string address (H&L) and input buffer
1589 13-055 104 016 013            JMP INSTR1             ;Address (D&E). Look gor occurrence of test string in ln.
1590 13-060 001                    HLT                    ;Safety halt. If program reaches here have system failure.
1591 13-061 046 000     INSTR2:    LEI 000                ;If reach end of input buffer without finding a match
1592 13-063 007                    RET                    ;Load E with 000 as an indicator and return to caller.
1593 13-064 040         ADVDE:     INE                    ;Subroutine to advance the pointer in the register
1594 13-065 013                    RFZ                    ;Pair D & E. Advance contents of E. Return if not zero.
1595 13-066 030                    IND                    ;If register E goes to 0 when advanced, then advance
1596 13-067 007                    RET                    ;Register D too. Exit to calling routine.
1597                    
1598                    ;;; The label RUN should start at 13-170
1599 13-070 066 073     RUN:       LLI 073                ;Load L with addr of GOSUB/RETURN stack pointer
1600 13-072 056 027                LHI \HB\OLDPG27        ;** Load H with page of same pointer
1601 13-074 076 000                LMI 000                ;Initialize the GOSUB/RETURN stack pointer to zero
1602 13-076 066 205                LLI 205                ;Load L with addr of FOR/NEXT stack pointer
1603 13-100 076 000                LMI 000                ;Initialize the FOR/NEXT stack pointer to zero
1604 13-102 066 360                LLI 360                ;Load L with addr of user pgm buffer line pointer
1605 13-104 056 026                LHI \HB\OLDPG26        ;** Load H with page of user pgm buffer line pointer
1606 13-106 076 033                LMI BGNPGRAM           ;tt Initialize pointer (may be altered by user)   *******
1607 13-110 060                    INL                    ;Advance memory pointer to low portion of user pgm
1608 13-111 076 000                LMI 000                ;Buffer pointer and initialize to start of buffer
1609 13-113 104 156 013            JMP SAMLIN             ;Start executing user program with first line in buffer
1610 13-116 066 360     NXTLIN:    LLI 360                ;Load L with addr of user program buffer line pointer
1611 13-120 056 026                LHI \HB\OLDPG26        ;** Load H with page of user pgm buffer line pointer
1612 13-122 337                    LDM                    ;Place page addr of pgm buffer line pointer in D
1613 13-123 060                    INL                    ;Advance the memory pointer
1614 13-124 347                    LEM                    ;Place low addr of pgm buffer line pointer in E
1615 13-125 353                    LHD                    ;Also put page addr of pgm buffer line pointer in H
1616 13-126 364                    LLE                    ;And low addr of pgm buffer line pointer in L
1617 13-127 317                    LBM                    ;Now fetch the (cc) of current line into register B
1618 13-130 010                    INB                    ;Add one to account for (cc) byte itself
1619 13-131 106 305 012            CAL ADBDE              ;Add value in B to D&E to point to next line in
1620 13-134 066 360                LLI 360                ;User program buffer. Reset L to addr of user logrn
1621 13-136 056 026                LHI \HB\OLDPG26        ;** Buffer pointer storage location. Store the new
1622 13-140 373                    LMD                    ;Updated user pgm line pointer in pointer storage
1623 13-141 060                    INL                    ;Location. Store both the high portion
1624 13-142 374                    LME                    ;And low portion. (Now points to next line to be
1625 13-143 066 340                LLI 340                ;Processed from user program buffer.) Change pointer
1626 13-145 056 026                LHI \HB\OLDPG26        ;** To address of line number buffer. Fetch the last
1627 13-147 307                    LAM                    ;Line number (length) processed. Test to see if it was
1628 13-150 240                    NDA                    ;Blank. If it was blank
1629 13-151 150 266 010            JTZ EXEC               ;Then stop processing and return to the Executive
1630 13-154 300                    LAA                    ;Insert two effective NOPs here
1631 13-155 300                    LAA                    ;In case of patching
1632 13-156 066 360     SAMLIN:    LLI 360                ;Load L with addr of user program buffer line pointer
1633 13-160 056 026                LHI \HB\OLDPG26        ;** Load H with page of same pointer
1634 13-162 327                    LCM                    ;Fetch the high portion of the pointer into register C
1635 13-163 060                    INL                    ;Advance the memory pointer
1636 13-164 367                    LLM                    ;Fetch the low portion of the pointer into register L
1637 13-165 352                    LHC                    ;Now move the high portion into register H
1638 13-166 036 026                LDI \HB\OLDPG26        ;** Set D to page of line input buffer
1639 13-170 046 000                LEI 000                ;Set E to address of start of line input buffer
1640 13-172 106 046 012            CAL MOVEC              ;Move the line ftom the user program buffer into the
1641 13-175 066 000                LLI 000                ;Line input buffer. Now reset the pointer to the start
1642 13-177 056 026                LHI \HB\OLDPG26        ;** Of the line input buffer.
1643 13-201 307                    LAM                    ;Fetch the first byte of the line input buffer (cc)
1644 13-202 240                    NDA                    ;Test (cc) value to see if fetched a blank line
1645 13-203 150 266 010            JTZ EXEC               ;If fetched a blank line, return to the Executive
1646 13-206 106 000 002            CAL SYNTAX             ;Else call subrtn to strip off line nr & set statement toke
1647                    
1648 13-211 066 203     DIRECT:    LLI 203                ;Load L with address of syntax TOKEN storage location
1649 13-213 056 026                LHI \HB\OLDPG26        ;** Load H with page of syntax TOKEN location
1650 13-215 307                    LAM                    ;Fetch the TOKEN value into the accumulator
1651 13-216 074 001                CPI 001                ;Is it token value for REM statement? If so, ignore the
1652 13-220 150 116 013            JTZ NXTLIN             ;Current line and go on to the next line in pgm buffer.
1653 13-223 074 002                CPI 002                ;Is it token value for IF statement?
1654 13-225 150 027 016            JTZ IF                 ;If yes, then go to the IF statement routine.
1655 13-230 074 003                CPI 003                ;Is it token value for LET statement? (Using keyword)
1656 13-232 150 031 015            JTZ LET                ;If yes, then go to the LET statement routine.
1657 13-235 074 004                CPI 004                ;Is it token value for GOTO statement?
1658 13-237 150 174 015            JTZ GOTO               ;If yes, then go to the GOTO statement routine.
1659 13-242 074 005                CPI 005                ;Is it token value for PRINT statement?
1660 13-244 150 345 013            JTZ PRINT              ;If yes, then go to the PRINT statement routine.
1661 13-247 074 006                CPI 006                ;Is it token value for INPUT statement?
1662 13-251 150 365 016            JTZ INPUT              ;If yes, then go to the INPUT statement routine.
1663 13-254 074 007                CPI 007                ;Is it token value for FOR statement?
1664 13-256 150 164 017            JTZ FOR                ;If yes, then go to the FOR statement routine.
1665 13-261 074 010                CPI 010                ;Is it token value for NEXT statement?
1666 13-263 150 013 030            JTZ NEXT               ;If yes, then go to the NEXT statement routine.
1667 13-266 074 011                CPI 011                ;Is it token value for GOSUB statement?
1668 13-270 150 236 016            JTZ GOSUB              ;If yes, then go to the GOSUB statement routine.
1669 13-273 074 012                CPI 012                ;Is it token value for RETURN statement?
1670 13-275 150 304 016            JTZ RETURN             ;If yes, then go to the RETURN statement routine.
1671 13-300 074 013                CPI 013                ;Is it token value for DIM statement?
1672 13-302 150 365 055            JTZ DIM                ;If yes, then go to the DIM statement routine.
1673 13-305 074 014                CPI 014                ;Is it token value for END statement?
1674 13-307 150 266 010            JTZ EXEC               ;If yes, then go back to the Executive, user pgm finished!
1675 13-312 074 015                CPI 015                ;Is it token value for IMPLIED LET statement?
1676 13-314 150 013 015            JTZ LET0               ;If yes, then go to special LET entry point.
1677 13-317 074 016                CPI 016                ;@@ Is it token value for ARRAY IMPLIED LET?
1678 13-321 110 152 011            JFZ SYNERR             ;If not, then assume a syntax error condition.
1679 13-324 106 153 055            CAL ARRAY1             ;@@ Else, perform array storage set up subroutine.
1680 13-327 066 206                LLI 206                ;@@ Set L to array pointer storage location.
1681 13-331 056 026                LHI \HB\OLDPG26        ;@@ * * Set H to array pointer storage location.
1682 13-333 317                    LBM                    ;@@ Fetch array pointer to register B.
1683 13-334 066 202                LLI 202                ;@@ Change memory pointer to syntax pntr storage loc.
1684 13-336 371                    LMB                    ;@@ Save array pointer value there.
1685 13-337 106 240 010            CAL SAVESY             ;@@ Save array name in auxiliary symbol buffer
1686 13-342 104 042 015            JMP LET1
1687 13-345 066 202     PRINT:     LLI 202                ;Load L with address of SCAN pointer storage location
1688 13-347 056 026                LHI \HB\OLDPG26        ;** Load H with page of SCAN pointer
1689 13-351 307                    LAM                    ;Fetch the pointer value (last character scanned by the
1690 13-352 066 000                LLI 000                ;SYNTAX routine). Change pointer to line buffer (cc).
1691 13-354 277                    CPM                    ;Compare pointer value to buffer length. If not equal
1692 13-355 160 366 013            JTS PRINT1             ;Then line contains more than stand alone PRINT state-
1693 13-360 106 141 003            CAL CRLF               ;Ment. However, if just have PRINT statement then issue
1694 13-363 104 116 013            JMP NXTLIN             ;A carriage-return & line-feed combination, then exit.
1695 13-366 106 255 002 PRINT1:    CAL CLESYM             ;Initialize the SYMBOL buffer for new entry.
1696 13-371 066 202                LLI 202                ;Load L with address of SCAN buffer pointer
1697 13-373 056 026                LHI \HB\OLDPG26        ;** Load H with page of SCAN pointer
1698 13-375 317                    LBM                    ;Pointer points to last char scanned by SYNTAX. Need
1699 13-376 010                    INB                    ;To increment it to point to next char in statement line.
1700 13-377 066 203                LLI 203                ;Load L with address of former TOKEN value. Use it as
1701 14-001 371                    LMB                    ;Storage location for a PRINT statement pointer.
1702 14-002 066 203     PRINT2:    LLI 203                ;Set memory pointer to PRINT pointer storage location
1703 14-004 106 240 002            CAL GETCHR             ;Fetch character in input buffer pointed to by PRINT
1704 14-007 074 247                CPI 247                ;Pointer. See if it is ASCII code for single quote mark.
1705 14-011 150 203 014            JTZ QUOTE              ;If so, go to QUOTE section to process text string.
1706 14-014 074 242                CPI 242                ;If not, see if it is ASCII code for double quote mark.
1707 14-016 150 203 014            JTZ QUOTE              ;If so, go to QUOTE section to process text string.
1708 14-021 074 254                CPI 254                ;If not, see if it is ASCII code for comma sign.
1709 14-023 150 043 014            JTZ PRINT3             ;If so, go evaluate expression.
1710 14-026 074 273                CPI 273                ;If not, see if it is ASCII code for semi-colon sign.
1711 14-030 150 043 014            JTZ PRINT3             ;If so, go evaluate expression.
1712 14-033 066 203                LLI 203                ;Load L with address of PRINT pointer storage location.
1713 14-035 106 003 003            CAL LOOP               ;Increment pointer and test for end of line.
1714 14-040 110 002 014            JFZ PRINT2             ;If not end of line, fetch the next character.
1715 14-043 066 202     PRINT3:    LLI 202                ;Load L with address of SCAN pointer storage location
1716 14-045 317                    LBM                    ;Fetch value of the pointer (last letter of KEYWORD)
1717 14-046 010                    INB                    ;Add one to point to first character of expression
1718 14-047 066 276                LLI 276                ;Load L with addr of EVAL pointer storage location
1719 14-051 371                    LMB                    ;Store addr at which EVAL should start scanning
1720 14-052 066 203                LLI 203                ;Load L with address of PRINT pointer
1721 14-054 317                    LBM                    ;Which points to field terminator
1722 14-055 011                    DCB                    ;Decrement pointer value to last character of expression
1723 14-056 066 277                LLI 277                ;Load L with address of EVAL FINISH pntr storage loc.
1724 14-060 371                    LMB                    ;Place address value of last char in PRINT field there
1725 14-061 066 367                LLI 367                ;Load L with address of QUOTE flag
1726 14-063 307                    LAM                    ;Fetch the value of the QUOTE flag into the ACC
1727 14-064 240                    NDA                    ;Test the QUOTE flag status
1728 14-065 150 075 014            JTZ PRINT4             ;If field not quoted, proceed to evaluate expression
1729 14-070 076 000                LMI 000                ;If field quoted, then clear the QUOTE flag for next field
1730 14-072 104 125 014            JMP PRINT6             ;And skip the evaluation procedure
1731 14-075 106 224 003 PRINT4:    CAL EVAL               ;Evaluate the current PRINT field
1732 14-100 066 177                LLI 177                ;Then load L,with address of the TAB flag
1733 14-102 056 026                LHI \HB\OLDPG26        ;** Load H with the page of the TAB flag
1734 14-104 307                    LAM                    ;Fetch the value of the TAB flag into the accumulator
1735 14-105 240                    NDA                    ;Test the TAB flag
1736 14-106 066 110                LLI 110                ;Change L to the FIXED/FLOAT flag location
1737 14-110 056 001                LHI \HB\OLDPG1         ;** Change H to the FIXED/FLOAT flag page
1738 14-112 076 377                LMI 377                ;Set FIXED/FLOAT flag to fixed point
1739 14-114 152 314 014 PRINT5:    CTZ PFPOUT             ;If TAB flag not set, display value of expression
1740 14-117 066 177                LLI 177                ;Load L with address of TAB flag
1741 14-121 056 026                LHI \HB\OLDPG26        ;** Load H with page of TAB flag
1742 14-123 076 000                LMI 000                ;Reset TAB flag for next PRINT field
1743 14-125 066 203     PRINT6:    LLI 203                ;Load L with address of PRINT pointer stomge location
1744 14-127 106 240 002            CAL GETCHR             ;Fetch the character pointed to by the PRINT pointer
1745 14-132 074 254                CPI 254                ;See if the last character scanned was a comma sign
1746 14-134 152 357 014            CTZ PCOMMA             ;If so, then display spaces to next TA.B location
1747 14-137 066 203                LLI 203                ;Reset L to address of PRINT pointer storage location
1748 14-141 056 026                LHI \HB\OLDPG26        ;** Reset H to page of PRINT pointer stomge location
1749 14-143 317                    LBM                    ;Fetch the value of the pointer into register B
1750 14-144 066 202                LLI 202                ;Change L to SCAN pointer storage location
1751 14-146 371                    LMB                    ;Place end of last field processed into SCAN pointer
1752 14-147 066 000                LLI 000                ;Change pointer to start of line input buffer
1753 14-151 301                    LAB                    ;Place pntr to last char scanned into the accumulator
1754 14-152 277                    CPM                    ;Compare this value to the (cc) for the line buffer
1755 14-153 160 366 013            JTS PRINT1             ;If not end of line, continue to process next field
1756 14-156 066 000                LLI 000                ;If end of line, fetch the last character in the line
1757 14-160 106 240 002            CAL GETCHR             ;And check to see if it
1758 14-163 074 254                CPI 254                ;Was a comma. If it was, go on to the next line in the
1759 14-165 150 116 013            JTZ NXTLIN             ;User program buffer without displaying a CR & LF.
1760 14-170 074 273                CPI 273                ;If not a comma, check to see if it was a semi-colon.
1761 14-172 150 116 013            JTZ NXTLIN             ;If so, do not provide a CR & LF combination.
1762 14-175 106 141 003            CAL CRLF               ;If not comma or semi-colon, provide CR & LF at end
1763 14-200 104 116 013            JMP NXTLIN             ;Of a PRINT statement. Go process next line of pgrm.
1764 14-203 066 367     QUOTE:     LLI 367                ;Load L with address of QUOTE flag
1765 14-205 370                    LMA                    ;Store type of quote in flag storage location
1766 14-206 106 255 002            CAL CLESYM             ;Initialize the SYMBOL buffer for new entry
1767 14-211 066 203                LLI 203                ;Load L with address of PRINT pointer
1768 14-213 317                    LBM                    ;Fetch the PRINT pointer into register B
1769 14-214 010                    INB                    ;Add one to advance over quote character
1770 14-215 066 204                LLI 204                ;Load L with address of QUOTE pointer
1771 14-217 371                    LMB                    ;Store the beginning of the QUOTE field pointer
1772 14-220 066 204     QUOTE1:    LLI 204                ;Load L with address of QUOTE pointer
1773 14-222 106 240 002            CAL GETCHR             ;Fetch the next character in the TEXT field
1774 14-225 066 367                LLI 367                ;Load L with the QUOTE flag (type of quote)
1775 14-227 277                    CPM                    ;Compare to see if latest character this quote mark
1776 14-230 150 263 014            JTZ QUOTE2             ;If so, finish up this quote field
1777 14-233 106 202 003            CAL ECHO               ;If not, display the character as part of TEXT
1778 14-236 066 204                LLI 204                ;Reset L to QUOTE pointer storage location
1779 14-240 106 003 003            CAL LOOP               ;Increment QUOTE pointer and test for end of line
1780 14-243 110 220 014            JFZ QUOTE1             ;If not end of line, continue processing TEXT field
1781 14-246 006 311     QUOTER:    LAI 311                ;If end of line before closing quote mark have an error
1782 14-250 026 321                LCI 321                ;So load ACC with I and register C with Q
1783 14-252 066 367                LLI 367                ;Load L with the address of the QUOTE flag
1784 14-254 056 026                LHI \HB\OLDPG26        ;** Load H with the page of the QUOTE flag
1785 14-256 076 000                LMI 000                ;Clear the QUOTE flag for future use
1786 14-260 104 226 002            JMP ERROR              ;Go display the IQ (Illegal Quote) error message
1787 14-263 066 204     QUOTE2:    LLI 204                ;Load L with address of QUOTE pointer
1788 14-265 317                    LBM                    ;Fetch the QUOTE pointer into register B
1789 14-266 066 202                LLI 202                ;Load L with address of SCAN pointer storage location
1790 14-270 371                    LMB                    ;Store former QUOTE vointer as start of next field
1791 14-271 301                    LAB                    ;Place QUOTE pointer into the accumulator
1792 14-272 066 000                LLI 000                ;Change L to point to start of the input line buffer
1793 14-274 277                    CPM                    ;Compare QUOTE pointer value with (cc) value
1794 14-275 110 366 013            JFZ PRINT1             ;If not end of line, process next PRINT field
1795 14-300 106 141 003            CAL CRLF               ;Else display a CR & LF combination at the end of line
1796 14-303 066 367                LLI 367                ;Load L with the address of the TAB flag
1797 14-305 056 026                LHI \HB\OLDPG26        ;** Load H with the page of the TAB flag
1798 14-307 076 000                LMI 000                ;Clear the TAB flag for future use
1799 14-311 104 116 013            JMP NXTLIN             ;Go process next line of the program.
1800                    
1801                                                      ;The following subroutines are utilized by the PRINT
1802                                                      ;routine.
1803                    ;;; The label PFPOUT SHOULD BE AT 14 314
1804 14-314 066 126     PFPOUT:    LLI 126                ;Load L with the address of the FPACC MSW (Floating
1805 14-316 056 001                LHI \HB\OLDPG1         ;** Point ACC). Load H with page of the FPACC MSW.
1806 14-320 307                    LAM                    ;Fetch the FPACC MSW into the accumulator. Test to
1807 14-321 240                    NDA                    ;See if the FPACC MSW is zero. If so, then simply go and
1808 14-322 150 336 014            JTZ ZERO               ;Display the value "0"
1809 14-325 060                    INL                    ;Else advance the pointer to the FPACC Exponent
1810 14-326 307                    LAM                    ;Fetch the FPACC Exponent into the accumulator
1811 14-327 240                    NDA                    ;See if any exponent value. If not, mantissa is in range
1812 14-330 150 350 014            JTZ FRAC               ;0.5 to 1.0. Treat number as a fraction.
1813 14-333 104 165 024            JMP FPOUT              ;Else perform regular numerical output routine.
1814 14-336 006 240     ZERO:      LAI 240                ;Load ASCII code for space into the ACC
1815 14-340 106 202 003            CAL ECHO               ;Display the space
1816 14-343 006 260                LAI 260                ;Load ASCII code for 0 into the ACC
1817 14-345 104 202 003            JMP ECHO               ;Display 0 and exit to calling routine
1818 14-350 066 110     FRAC:      LLI 110                ;Load L with address of FIXED/FLOAT flag
1819 14-352 076 000                LMI 000                ;Reset it to indicate floating point mode
1820 14-354 104 165 024            JMP FPOUT              ;Display floating point number and return to caller
1821 14-357 066 000     PCOMMA:    LLI 000                ;Load L with address of (cc) in line input buffer
1822 14-361 307                    LAM                    ;Fetch the (cc) for the line into the ACC
1823 14-362 066 203                LLI 203                ;Change pointer to PRINT pointer storage location
1824 14-364 227                    SUM                    ;Subtract value of PRINT pointer from line (cc)
1825 14-365 063                    RTS                    ;If at end of buffer, do not TAB
1826 14-366 066 043                LLI 043                ;If not end, load L with address of COLUMN COUNTER
1827 14-370 056 001                LHI \HB\OLDPG1         ;** Set H to page of COLUMN COUNTER
1828 14-372 307                    LAM                    ;Fetch COLUMN COUNTER into the accumulator
1829 14-373 044 360                NDI 360                ;Find the last TAB position (multiple of 16 decimal)
1830 14-375 004 020                ADI 020                ;Add 16 (decimal) to get new TAB position
1831 14-377 227                    SUM                    ;Subtract current position from next TAB position
1832 15-000 320                    LCA                    ;Store this value in register C as a counter
1833 15-001 006 240                LAI 240                ;Load the ACC with the ASCII code for space
1834 15-003 106 202 003 PCOM1:     CAL ECHO               ;Display the space
1835 15-006 021                    DCC                    ;Decrement the loop counter
1836 15-007 110 003 015            JFZ PCOM1              ;Continue displaying spaces until loop counter is zero
1837 15-012 007                    RET                    ;Then return to calling routine
1838 15-013 106 240 010 LET0:      CAL SAVESY             ;Entry point for IMPLIED LET statement. Save the
1839 15-016 066 202                LLI 202                ;Variable (to left of the equal sign). Set L to the SCAN
1840 15-020 056 026                LHI \HB\OLDPG26        ;** Pointer. Set H to the page of the SCAN pointer.
1841 15-022 317                    LBM                    ;Fetch value of SCAN pointer. (Points to = sign in In bf)
1842 15-023 066 203                LLI 203                ;Change pointer to LET pointer (was TOKEN value)
1843 15-025 371                    LMB                    ;Place the SCAN pointer value into the LET pointer
1844 15-026 104 141 015            JMP LET5               ;Continue processing the LET statement line
1845 15-031 106 255 002 LET:       CAL CLESYM             ;Initialize the SYMBOL BUFFER for new entry
1846 15-034 066 144                LLI 144                ;Load L with address of start of AUX SYMBOL BUFF
1847 15-036 056 026                LHI \HB\OLDPG26        ;** Load H with page of AUX SYMBOL BUFFER
1848 15-040 076 000                LMI 000                ;Initialize AUX SYMBOL BUFFER
1849 15-042 066 202     LET1:      LLI 202                ;Entry point for ARRAY IMPLIED LET statement.
1850 15-044 056 026                LHI \HB\OLDPG26        ;** Set pointer to SCAN pointer storage location
1851 15-046 317                    LBM                    ;Fetch the SCAN pointer value (last letter scanned by
1852 15-047 010                    INB                    ;SYNTAX subroutine) and add one to next character
1853 15-050 066 203                LLI 203                ;Change L to LET pointer storage location
1854 15-052 371                    LMB                    ;Store former SCAN value (updated) in LET pointer
1855 15-053 066 203     LET2:      LLI 203                ;Set L to gtorage location of LET pointer
1856 15-055 106 240 002            CAL GETCHR             ;Fetch the character pointed to by the LET pointer
1857 15-060 150 122 015            JTZ LET4               ;If character is a space, ignore it
1858 15-063 074 275                CPI 275                ;See if character is the equal (=) sign
1859 15-065 150 141 015            JTZ LET5               ;If so, go process other side of the statement (after
1860 15-070 074 250                CPI 250                ;@@ If not, see if character is a right parenthesis
1861 15-072 110 113 015            JFZ LET3               ;If not, continue looking for equal sign
1862 15-075 106 145 055            CAL ARRAY              ;@@ If so, have subscript. Call array set up subroutine.
1863 15-100 066 206                LLI 206                ;@@ Load L with address of ARRAY pointer
1864 15-102 056 026                LHI \HB\OLDPG26        ;@@ ** Load H with page of ARRAY pointer
1865 15-104 317                    LBM                    ;@@ Fetch value (points to ")" character of subscript)
1866 15-105 066 203                LLI 203                ;@@ Load L with address of LET pointer
1867 15-107 371                    LMB                    ;@@ Place ARRAY pointer value as new LET pointer
1868 15-110 104 122 015            JMP LET4               ;@@ Continue to look for = sign in statement line
1869 15-113 066 144     LET3:      LLI 144                ;Reset L to start of AUX SYMBOL BUFFER
1870 15-115 056 026                LHI \HB\OLDPG26        ;** Load H with page of AUX SYMBOL BUFFER
1871 15-117 106 314 002            CAL CONCT1             ;Concatenate character to the AUX SYMBOL BUFFER
1872 15-122 066 203     LET4:      LLI 203                ;Load L with address of LET pointer storage location
1873 15-124 106 003 003            CAL LOOP               ;Add one to pointer and test for end of line input buffer
1874 15-127 110 053 015            JFZ LET2               ;If not end of line, continue looking for the equal sign
1875 15-132 006 314     LETERR:    LAI 314                ;If do not find an equal sign in the LET statement line
1876 15-134 026 305                LCI 305                ;Then have a LE (Let Error). Load the code for L and E
1877 15-136 104 226 002            JMP ERROR              ;Into registers ACC and C and go display the error msg.
1878 15-141 066 203     LET5:      LLI 203                ;When find the equal sign, reset L to point to the LET
1879 15-143 056 026                LHI \HB\OLDPG26        ;** Pointer and H to the proper page. Fetch the pointer
1880 15-145 317                    LBM                    ;Value into register B and add one to advance pointer
1881 15-146 010                    INB                    ;Over the equal sign to first char in the expression.
1882 15-147 066 276                LLI 276                ;Set L to point to the address of the EVAL pointer
1883 15-151 371                    LMB                    ;Set EVAL pointer to start evaluating right after the
1884 15-152 066 000                LLI 000                ;Equal sign. Now change L to start of line input buffer.
1885 15-154 317                    LBM                    ;Fetch the (cc) value into register B. (Length of line.)
1886 15-155 066 277                LLI 277                ;Load L with EVAL FINISH pointer storage location.
1887 15-157 371                    LMB                    ;Set it to stop evaluating at end of the line.
1888 15-160 106 224 003            CAL EVAL               ;Call the subroutine to evaluate the expression.
1889 15-163 106 252 010            CAL RESTSY             ;Restore the name of the variable to receive new value.
1890 15-166 106 055 010            CAL STOSYM             ;Store the new value for the variable in variables table.
1891 15-171 104 116 013            JMP NXTLIN             ;Go process next line of the program.
1892 15-174 066 350     GOTO:      LLI 350                ;Load L with start of AUX LINE NR BUFFER
1893 15-176 056 026                LHI \HB\OLDPG26        ;** Load H with page of AUX LINE NR BUFFER
1894 15-200 076 000                LMI 000                ;Initialize the AUX LINE NR BUFFER to zero
1895 15-202 066 202                LLI 202                ;Load L with address of SCAN pointer storage location
1896 15-204 317                    LBM                    ;Fetch pointer value (last char scanned by SYNTAX)
1897 15-205 010                    INB                    ;Add one to skip over the last 0 in GOTO keyword
1898 15-206 066 203                LLI 203                ;Change pointer to GOTO pointer (formerly TOKEN)
1899 15-210 371                    LMB                    ;Store the updated SCAN pointer as the GOTO pointer
1900 15-211 066 203     GOTO1:     LLI 203                ;Load L with address of GOTO pointer
1901 15-213 106 240 002            CAL GETCHR             ;Fetch the character pointed to by the GOTO pointer
1902 15-216 150 240 015            JTZ GOTO2              ;If character was a space, ignore it
1903 15-221 074 260                CPI 260                ;See if character is in the range of a decimal digit
1904 15-223 160 250 015            JTS GOTO3              ;If not, must have end of the line number digit string
1905 15-226 074 272                CPI 272                ;Continue to test for decitnal digit
1906 15-230 120 250 015            JFS GOTO3              ;If not, mugt have end of the line number digit string
1907 15-233 066 350                LLI 350                ;If valid decimal digit, load L with addr of AUX LINE
1908 15-235 106 314 002            CAL CONCT1             ;NR BUFFER and concatenate digit to the buffer.
1909 15-240 066 203     GOTO2:     LLI 203                ;Reset pointer to GOTO pointer storage location
1910 15-242 106 003 003            CAL LOOP               ;Advance the pointer value and test for end of line
1911 15-245 110 211 015            JFZ GOTO1              ;If not end of line, fetch next digit in GOTO line number
1912 15-250 066 360     GOTO3:	   LLI 360                ;Set L to user program buffer pointer storage location
1913 15-252 056 026                LHI \HB\OLDPG26        ;** Set H to page of program buffer pointer
1914 15-254 076 033                LMI BGNPGRAM           ;Initialize high part of pointer to start of pgm buffer
1915 15-256 060                    INL                    ;Advance the memory point
1916 15-257 076 000                LMI 000                ;Initialize the low part of pointer to start of pgm buffer
1917 15-261 106 255 002 GOTO4:     CAL CLESYM             ;Clear the SYMBOL BUFFER
1918 15-264 066 204                LLI 204                ;Load L with address of GOTO SEARCH pointer
1919 15-266 076 001                LMI 001                ;Initialize to one for first char of line
1920 15-270 066 204     GOTO5:     LLI 204                ;Load L with address of GOTO SEARCH pointer
1921 15-272 106 123 012            CAL GETCHP             ;Fetch character pointed to by GOTO SEARCH pointer
1922 15-275 150 315 015            JTZ GOTO6              ;From line pointed to in user program buffer. Ignore
1923 15-300 074 260                CPI 260                ;Spaces. Check to see if character is a decirnal digit.
1924 15-302 160 340 015            JTS GOTO7              ;If not, then have processed line number at the start of
1925 15-305 074 272                CPI 272                ;The current line. Continue the check for a valid decimal
1926 15-307 120 340 015            JFS GOTO7              ;Digit. If have a decirnal digit then concatenate the digit
1927 15-312 106 310 002            CAL CONCTS             ;Onto the current string in the SYMBOL BUFFER,
1928 15-315 066 204     GOTO6:     LLI 204                ;Change L to the address of the GOTO SEARCH pointer
1929 15-317 056 026                LHI \HB\OLDPG26        ;** And H to the proper page of the pointer
1930 15-321 317                    LBM                    ;Fetch the GOTO SEARCH pointer value
1931 15-322 010                    INB                    ;Increment the GOTO SEARCH pointer
1932 15-323 371                    LMB                    ;And restore it back to memory
1933 15-324 066 360                LLI 360                ;Change L to address of user program buffer pointer
1934 15-326 327                    LCM                    ;Save the high part of this pointer value in register C
1935 15-327 060                    INL                    ;Advance L to the low part of the pgrn buffer pointer
1936 15-330 367                    LLM                    ;Now load it into L
1937 15-331 352                    LHC                    ;And transfer C into H to point to start of the line
1938 15-332 307                    LAM                    ;Fetch the (cc) of the current line being pointed to in the
1939 15-333 011                    DCB                    ;User pgm buff. Decrernent B to previous value. Compare
1940 15-334 271                    CPB                    ;GOTO SEARCH pointer value to length of current line.
1941 15-335 110 270 015            JFZ GOTO5              ;If not end of line then continue getting current line nr.
1942 15-340 066 120     GOTO7:     LLI 120                ;Load L with address of start of the SYMBOL BUFFER
1943 15-342 056 026                LHI \HB\OLDPG26        ;Set H to the page of the SYMBOL BUFFER
1944 15-344 036 026                LDI \HB\OLDPG26        ;Set D to the page of the AUX LINE NR BUFFER
1945 15-346 046 350                LEI 350                ;Set E to the start of the AUX LINE NR BUFFER
1946 15-350 106 332 002            CAL STRCP              ;Compare GOTO line number against current line nr.
1947 15-353 150 156 013            JTZ SAMLIN             ;If they match, found GOTO line. Pick up ops there!
1948 15-356 066 360                LLI 360                ;Else, set L to user program buffer pntr storage location
1949 15-360 056 026                LHI \HB\OLDPG26        ;** Set H to page of user program buffer pointer
1950 15-362 337                    LDM                    ;Fetch the high part of this pointer into register D
1951 15-363 060                    INL                    ;Advance the memory pointer
1952 15-364 347                    LEM                    ;Fetch the low part into register E
1953 15-365 353                    LHD                    ;Transfer the pointer to H
1954 15-366 364                    LLE                    ;And L. Fetch the (cc) of the current line into register
1955 15-367 317                    LBM                    ;B and then add one to account for the (cc) byte to get
1956 15-370 010                    INB                    ;Total length of the current line in the user pgm buffer
1957 15-371 106 305 012            CAL ADBDE              ;Add the total length to the pointer value in D & E
1958 15-374 066 360                LLI 360                ;To get the starting address of the next line in the user
1959 15-376 056 026                LHI \HB\OLDPG26        ;** User program buffer. Place the new value for the user
1960 16-000 373                    LMD                    ;Program buffer pointer back into the user program
1961 16-001 060                    INL                    ;Buffer pointer storage locations so that it points to the
1962 16-002 374                    LME                    ;Next line to be processed in the user program buffer.
1963 16-003 066 364                LLI 364                ;Load L with address of end of user pgm buffer storage
1964 16-005 303                    LAD                    ;Location (page address) and fetch end of buffer page.
1965 16-006 277                    CPM                    ;Compare this with next line pointer (updated).
1966 16-007 110 261 015            JFZ GOTO4              ;If not end of buffer, keep looking for the specified line
1967 16-012 060                    INL                    ;If have same page addresses, check the low address
1968 16-013 304                    LAE                    ;Portions to see if
1969 16-014 277                    CPM                    ;Have reached end of user program buffer
1970 16-015 110 261 015            JFZ GOTO4              ;If not, continue looking. If end of buffer without
1971 16-020 006 325     GOTOER:    LAI 325                ;Finding specified line, then have an error condition.
1972 16-022 026 316                LCI 316                ;Load ACC and register C with code for "UN" and go
1973 16-024 104 226 002            JMP ERROR              ;Display "Undefined Line" error message.
1974 16-027 066 202     IF:        LLI 202                ;Set L to SCAN pointer storage location.
1975 16-031 056 026                LHI \HB\OLDPG26        ;** Load H to page of SCAN pointer storage location.
1976 16-033 317                    LBM                    ;Fetch the SCAN pointer value to register B.
1977 16-034 010                    INB                    ;Add one to advance pointer over last char scanned.
1978 16-035 066 276                LLI 276                ;Change L to address of EVAL pointer. Set up EVAL
1979 16-037 371                    LMB                    ;Pointer to begin evaluation with next char in the line.
1980 16-040 106 255 002            CAL CLESYM             ;Clear the SYMBOL BUFFER.
1981 16-043 066 320                LLI 320                ;Set L to starting address of THEN in look-up table.
1982 16-045 056 001                LHI \HB\OLDPG1         ;** Set H to page of the look-up table.
1983 16-047 106 012 013            CAL INSTR              ;Search for occurrence of THEN in the line input buffer.
1984 16-052 304                    LAE                    ;Transfer register E to ACC. If THEN not found
1985 16-053 240                    NDA                    ;The value in E will be zero.
1986 16-054 110 102 016            JFZ IF1                ;If THEN found, can evaluate the IF expression.
1987 16-057 066 013                LLI 013                ;If THEN not found, set L to Auting address of GOTO
1988 16-061 056 027                LHI \HB\OLDPG27        ;** In the KEYWORD look-up table. Set H to table
1989 16-063 106 012 013            CAL INSTR              ;Search for occurrence of GOTO in the line input buffer.
1990 16-066 304                    LAE                    ;Transfer E to ACC. If GOTO not found
1991 16-067 240                    NDA                    ;The value in E will be zero.
1992 16-070 110 102 016            JFZ IF1                ;If GOTO found, can evaluate the IF expression.
1993 16-073 006 311     IFERR:     LAI 311                ;Set ASCII code for letter I in ACC
1994 16-075 026 306                LCI 306                ;And code for letter F in register C
1995 16-077 104 226 002            JMP ERROR              ;Go display the IF error message
1996 16-102 066 277     IF1:       LLI 277                ;Load L with addr of EVAL FINISH pointer storage loc
1997 16-104 056 026                LHI \HB\OLDPG26        ;** Load H with page of storage location
1998 16-106 041                    DCE                    ;Subtract one from pointer in E and set the EVAL
1999 16-107 374                    LME                    ;FINISH pointer so that it will evaluate up to the THEN
2000 16-110 106 224 003            CAL EVAL               ;Or GOTO directive. Evaluate the expression.
2001 16-113 066 126                LLI 126                ;Load L with address of FPACC Most Significant Word
2002 16-115 056 001                LHI \HB\OLDPG1         ;** Load H with page of FPACC MSW
2003 16-117 307                    LAM                    ;Fetch the FPACC MSW into the accumulator
2004 16-120 240                    NDA                    ;Test the value of the FPACC MSW
2005 16-121 150 116 013            JTZ NXTLIN             ;If it is zero, IF condition failed, ignore rest of line.
2006 16-124 066 277                LLI 277                ;If not, load L with addr of EVAL FINISH pointer
2007 16-126 056 026                LHI \HB\OLDPG26        ;** Set H to the appmpriate page
2008 16-130 307                    LAM                    ;Fetch the value in the EVAL FINISH pointer
2009 16-131 004 005                ADI 005                ;Add five to skip over THEN or GOTO directive
2010 16-133 066 202                LLI 202                ;Change L to SCAN pointer stomge location
2011 16-135 370                    LMA                    ;Set up the SCAN pointer to location after THEN or
2012 16-136 310                    LBA                    ;GOTO directive. Also put this value in register B.
2013 16-137 010                    INB                    ;Add one to the value in B to point to next character
2014 16-140 066 204                LLI 204                ;After THEN or GOTO. Change L to addr of THEN pntr
2015 16-142 371                    LMB                    ;Storage location and store the pointer value.
2016 16-143 066 204     IF2:       LLI 204                ;Load L with the address of the THEN pointer
2017 16-145 106 240 002            CAL GETCHR             ;Fetch the character pointed to by the THEN pointer
2018 16-150 110 166 016            JFZ IF3                ;If character is not a space, exit this loop
2019 16-153 066 204                LLI 204                ;If fetch a space, ignore. Reset L to the THEN pointer
2020 16-155 106 003 003            CAL LOOP               ;Add one to the THEN pointer and test for end of line
2021 16-160 110 143 016            JFZ IF2                ;If not end of line, keep looking for a character other
2022 16-163 104 073 016            JMP IFERR              ;Than a space. If reach end of line first, then error
2023 16-166 074 260     IF3:       CPI 260                ;When find a character see if it is numeric.
2024 16-170 160 200 016            JTS IF4                ;If not numeric, then should have a new type of
2025 16-173 074 272                CPI 272                ;Statement. If numeric, then should have a line number.
2026 16-175 160 174 015            JTS GOTO               ;So process as though have a GOTO statement!
2027 16-200 066 000     IF4:       LLI 000                ;Load L with addr of start of line input buffer.
2028 16-202 307                    LAM                    ;Fetch the (cc) byte to get length of line value.
2029 16-203 066 204                LLI 204                ;Change L to current value of THEN pointer (where first
2030 16-205 227                    SUM                    ;Non-space char. found after THEN or GOTO). Subtract
2031 16-206 310                    LBA                    ;This value from length of line to get remainder. Now
2032 16-207 010                    INB                    ;Have length of second statement portion. Add one for
2033 16-210 327                    LCM                    ;(cc) count. Save THEN pointer value in register C.
2034 16-211 066 000                LLI 000                ;Reset L to start of line input buffer. Now put length of
2035 16-213 371                    LMB                    ;Second statement into (cc) position of input buffer.
2036 16-214 362                    LLC                    ;Set L to where second statement starts.
2037 16-215 036 026                LDI \HB\OLDPG26        ;** Set D to page of line input buffer.
2038 16-217 046 001                LEI 001                ;Set E to first character position of line input buffer.
2039 16-221 106 013 021            CAL MOVEIT             ;Move the second statement up in line to become first!
2040 16-224 066 202                LLI 202                ;Load L with address of new SCAN pointer. Load
2041 16-226 076 001                LMI 001                ;It with starting position for SYNTAX scan.
2042 16-230 106 067 002            CAL SYNTX4             ;Use special entry to SYNTAX to get new TOKEN value.
2043 16-233 104 211 013            JMP DIRECT             ;Process the second statement in the original line.
2044 16-236 066 340     GOSUB:     LLI 340                ;Load L with start of LINE NUMBER BUFFER
2045 16-240 056 026                LHI \HB\OLDPG26        ;Fetch (cc) of cuffent line number into register D
2046 16-242 337                    LDM                    ;Fetch high value (page) of pgm line pointer to D
2047 16-243 030                    IND                    ;Test contents of register by first incrementing
2048 16-244 031                    DCD                    ;And then decrementing the value in the register
2049 16-245 150 255 016            JTZ GOSUB1             ;If no line number, then processing a DIRECT statement
2050 16-250 066 360                LLI 360                ;Else, load L with address of user pgm buff line pointer
2051 16-252 337                    LDM                    ;Fetch high value (page) of pgm line pointer to D
2052 16-253 060                    INL                    ;Advance the memory pointer
2053 16-254 347                    LEM                    ;Fetch the low part of pgm line pointer to E
2054 16-255 066 073     GOSUB1:    LLI 073                ;Set L to address of GOSUB STACK POINTER
2055 16-257 056 027                LHI \HB\OLDPG27        ;** Set H to page of GOSUB STACK POINTER
2056 16-261 307                    LAM                    ;Fetch value in GOSUB stack pointer to ACC
2057 16-262 004 002                ADI 002                ;Add two to current stack pointer for new data to be
2058 16-264 074 021                CPI 021                ;Placed on the stack and see if stack overflows
2059 16-266 120 347 016            JFS GOSERR             ;If stack filled, have an error condition
2060 16-271 370                    LMA                    ;Else, store updated stack pointer
2061 16-272 066 076                LLI 076                ;Load L with address of start of stack less offset (2)
2062 16-274 206                    ADL                    ;Add GOSUB stack pointer to base address
2063 16-275 360                    LLA                    ;To get pointer to top of stack (page byte)
2064 16-276 373                    LMD                    ;Store page part of pgm buffer line pointer in stack
2065 16-277 060                    INL                    ;Advance pointer to next byte in stack
2066 16-300 374                    LME                    ;Store low part of pgm buffer line pointer in stack
2067 16-301 104 174 015            JMP GOTO               ;Proceed from here as though processing a GOTO
2068 16-304 066 073     RETURN:    LLI 073                ;Set L to address of GOSUB STACK POINTER
2069 16-306 056 027                LHI \HB\OLDPG27        ;** Set H to page of GOSUB STACK POINTER
2070 16-310 307                    LAM                    ;Fetch the value of GOSUB stack pointer to ACC
2071 16-311 024 002                SUI 002                ;Subtract two for data to be removed from stack
2072 16-313 160 356 016            JTS RETERR             ;If stack underflow, then have an error condition
2073 16-316 370                    LMA                    ;Restore new stack pointer to memory
2074 16-317 004 002                ADI 002                ;Add two to point to previous top of stack
2075 16-321 066 076                LLI 076                ;Load L with address of start of GOSUB stack less two
2076 16-323 206                    ADL                    ;Add address of previous top of stack to base value
2077 16-324 360                    LLA                    ;Set pointer to high address value in the stack
2078 16-325 337                    LDM                    ;Fetch the high address value from stack to register D
2079 16-326 030                    IND                    ;Exercise the register contents to see if high address
2080 16-327 031                    DCD                    ;Obtained is zero. If so, original GOSUB statement was
2081 16-330 150 266 010            JTZ EXEC               ;A DIRECT statement. Must return to Executive!
2082 16-333 060                    INL                    ;Else, advance pointer to get low address value from the
2083 16-334 347                    LEM                    ;Stack into CPU register E.
2084 16-335 066 360                LLI 360                ;Load L with address of user pgm line pointer storage
2085 16-337 056 026                LHI \HB\OLDPG26        ;** Location. Load H with page of user pgm line pntr.
2086 16-341 373                    LMD                    ;Put high address from stack into pgm line pointer.
2087 16-342 060                    INL                    ;Advance the memory pointer
2088 16-343 374                    LME                    ;Put low address from stack into pgrn line pointer.
2089 16-344 104 116 013            JMP NXTLIN             ;Execute the next line after originating GOSUB line!
2090 16-347 006 307     GOSERR:    LAI 307                ;Load ASCII code for letter G into accumulator
2091 16-351 026 323                LCI 323                ;Load ASCII code for letter S into register C
2092 16-353 104 226 002            JMP ERROR              ;Go display GoSub (GS) error message.
2093 16-356 006 322     RETERR:    LAI 322                ;Load ASCII code for letter R into accumulator
2094 16-360 026 324                LCI 324                ;Load ASCII code for letter T into register C
2095 16-362 104 226 002            JMP ERROR              ;Go display ReTurn (RT) error message.
2096 16-365 106 255 002 INPUT:     CAL CLESYM             ;Clear the SYMBOL BUFFER
2097 16-370 066 202                LLI 202                ;Load L with address of SCAN pointer storage location
2098 16-372 317                    LBM                    ;Fetch value of SCAN pointer to register B
2099 16-373 010                    INB                    ;Increment value to point to next chamcter
2100 16-374 066 203                LLI 203                ;Change L to point to INPUT pointer (formerly TOKEN)
2101 16-376 371                    LMB                    ;Updated SCAN pointer becomes INPUT pointer
2102 16-377 066 203     INPUT1:    LLI 203                ;Load L with address of INPUT pointer
2103 17-001 106 240 002            CAL GETCHR             ;Fetch a character from the line input buffer
2104 17-004 150 042 017            JTZ INPUT3             ;If character is a space, ignore it. Else,
2105 17-007 074 254                CPI 254                ;See if character is a comma. If so, process the
2106 17-011 150 063 017            JTZ INPUT4             ;Variable that preceeds the comma.
2107 17-014 074 250                CPI 250                ;If not, see if character is a left parenthesis.
2108 17-016 110 037 017            JFZ INPUT2             ;If not, continue processing to build up symbolic variable
2109 17-021 106 160 055            CAL ARRAY2             ;@@ If so, call array subscripting subroutine
2110 17-024 066 206                LLI 206                ;@@ Load L with address of array set up pointer
2111 17-026 056 026                LHI \HB\OLDPG26        ;@@ ** Load H with page of array set up pointer
2112 17-030 317                    LBM                    ;@@ Fetch pointer value (point to ")" of subscript)
2113 17-031 066 203                LLI 203                ;@@ Change pointer to address of INPUT pointer
2114 17-033 371                    LMB                    ;@@ Update INPUT pointer
2115 17-034 104 042 017            JMP INPUT3             ;@@ Jump over concatenate instruction below
2116 17-037 106 310 002 INPUT2:    CAL CONCTS             ;Concatenate character to SYMBOL BUFFER
2117 17-042 066 203     INPUT3:    LLI 203                ;Load L with address of INPUT pointer
2118 17-044 106 003 003            CAL LOOP               ;Increment INPUT pointer and test for end of line
2119 17-047 110 377 016            JFZ INPUT1             ;If not end of line, go get next character
2120 17-052 106 104 017            CAL INPUTX             ;If end of buffer, get input for variable in the SYMBOL
2121 17-055 106 055 010            CAL STOSYM             ;BUFFER and store the value in the VARIABLES table
2122 17-060 104 116 013            JMP NXTLIN             ;Then continue to interpret next statement line
2123 17-063 106 104 017 INPUT4:    CAL INPUTX             ;Get input from user for variable in SYMBOL BUFFER
2124 17-066 106 055 010            CAL STOSYM             ;Store the inputted value in the VARIABLES table
2125 17-071 056 026                LHI \HB\OLDPG26        ;** Set H to page of INPUT pointer
2126 17-073 066 203                LLI 203                ;Set L to location of INPUT pointer
2127 17-075 317                    LBM                    ;Fetch pointer value for last character examined
2128 17-076 066 202                LLI 202                ;Change L to point to SCAN pointer storage location
2129 17-100 371                    LMB                    ;Update the SCAN pointer
2130 17-101 104 365 016            JMP INPUT              ;Continue processing statement line for next variable
2131 17-104 066 120     INPUTX:    LLI 120                ;Load L with start of SYMBOL BUFFER (contains cc)
2132 17-106 307                    LAM                    ;Fetch the (cc) (length of symbol in the buffer) to ACC
2133 17-107 206                    ADL                    ;Add (cc) to base address to set up
2134 17-110 360                    LLA                    ;Pointer to last character in the SYMBOL BUFFER
2135 17-111 307                    LAM                    ;Fetch the last character in the SYMBOL BUFFER
2136 17-112 074 244                CPI 244                ;See if the last chamcter was a $ sign
2137 17-114 110 140 017            JFZ INPUTN             ;If not a $ sign, get variable value as a numerical entry
2138 17-117 066 120                LLI 120                ;If $ sign, reset L to start of the SYMBOL BUFFER
2139 17-121 317                    LBM                    ;Fetch the (cc) for the variable in the SYMBOL BUFF
2140 17-122 011                    DCB                    ;Subtract one from (cc) to chop off the $ sign
2141 17-123 371                    LMB                    ;Restore the new (cc) for the SYMBOL BUFFER
2142 17-124 106 157 017            CAL FP0                ;Call subroutine to zero the floating point accumulator
2143 17-127 106 221 003            CAL CINPUT             ;Input one character from system input device
2144 17-132 066 124                LLI 124                ;Load L with address of the LSW of the FPACC
2145 17-134 370                    LMA                    ;Place the ASCII code for the character inputted there
2146 17-135 104 064 020            JMP FPFLT              ;Convert value to floating point format in FPACC
2147 17-140 066 144     INPUTN:    LLI 144                ;Load L with address of start of AUX SYMBOL BUFF
2148 17-142 056 026                LHI \HB\OLDPG26        ;** Load H with page of AUX SYMBOL BUFFER
2149 17-144 006 277                LAI 277                ;Load accumulator with ASCII code for ? mark
2150 17-146 106 202 003            CAL ECHO               ;Call output subroutine to display the ? mark
2151 17-151 106 014 003            CAL STRIN              ;Input string of characters (number) fm input device
2152 17-154 104 044 023            JMP DINPUT             ;Convert decimal string into binary floating point nr.
2153 17-157 056 001     FP0:       LHI \HB\OLDPG1         ;** Load H with floating point working registers page
2154 17-161 104 247 006            JMP CFALSE             ;Zero the floating point accumulator & exit to caller
2155 17-164 066 144     FOR:       LLI 144                ;Load L with address of AUX SYMBOL BUFFER
2156 17-166 056 026                LHI \HB\OLDPG26        ;** Load H with page of AUX SYMBOL BUFFER
2157 17-170 076 000                LMI 000                ;Initialize buffer by clearing first byte
2158 17-172 066 146                LLI 146                ;Load L with location of second character in buffer
2159 17-174 076 000                LMI 000                ;Clear that location in case of single character variable
2160 17-176 066 205                LLI 205                ;Load L with address of FOR/NEXT STACK pointer
2161 17-200 056 027                LHI \HB\OLDPG27        ;** Load H with page of FOR/NEXT STACK pointer
2162 17-202 317                    LBM                    ;Fetch the FOR/NEXT STACK pointer
2163 17-203 010                    INB                    ;Increment it in preparation for pushing operation
2164 17-204 371                    LMB                    ;Restore it back to its storage location
2165 17-205 066 360                LLI 360                ;Load L with address of user pgrn buffer line pointer
2166 17-207 056 026                LHI \HB\OLDPG26        ;** Set H to page of line pointer
2167 17-211 337                    LDM                    ;Fetch page address of pgm buffer line pntr into D
2168 17-212 060                    INL                    ;Advance the memory pointer to pick up low part
2169 17-213 347                    LEM                    ;Fetch low address of pgm buffer line pntr into E
2170 17-214 301                    LAB                    ;Restore updated FOR/NEXT STACK pointer to ACC
2171 17-215 002                    RLC                    ;Rotate it left to multiply by two, then rotate it again to
2172 17-216 002                    RLC                    ;Multiply by four. Add this value to the base address of
2173 17-217 004 134                ADI 134                ;The FOR/NEXT STACK to point to the new top of
2174 17-221 360                    LLA                    ;The FOR/NEXT STACK and set up to point to stack
2175 17-222 056 027                LHI \HB\OLDPG27        ;** Set H for page of the FOR/NEXT STACK
2176 17-224 373                    LMD                    ;Store the page portion of the user pgrn buffer line pntr
2177 17-225 060                    INL                    ;In the FORINEXT STACK, advance register 4 then
2178 17-226 374                    LME                    ;Store the low portion of the pgrn line pntr on the stack
2179 17-227 066 325                LLI 325                ;Change L to point to start of TO string which is stored
2180 17-231 056 001                LHI \HB\OLDPG1         ;** In a text strings storage area on this page
2181 17-233 106 012 013            CAL INSTR              ;Search the statement line for the occurrence of TO
2182 17-236 304                    LAE                    ;Register E wiU be zero if TO not found. Move E to ACC
2183 17-237 240                    NDA                    ;To make a test
2184 17-240 110 252 017            JFZ FOR1               ;If TO found then proceed with FOR statement
2185 17-243 006 306     FORERR:    LAI 306                ;Else have a For Error. Load ACC with ASCII code for
2186 17-245 026 305                LCI 305                ;Letter F and register C with code for letter E.
2187 17-247 104 226 002            JMP ERROR              ;Then go display the FE message.
2188 17-252 066 202     FOR1:      LLI 202                ;Load L with address of SCAN pointer storage location
2189 17-254 056 026                LHI \HB\OLDPG26        ;** Set H to page of the SCAN pointer
2190 17-256 317                    LBM                    ;Fetch pointer value to ACC (points to letter R in the
2191 17-257 010                    INB                    ;For directive). Increment it to point to next character
2192 17-260 066 204                LLI 204                ;In the line. Change register L and set this value up
2193 17-262 371                    LMB                    ;As an updated FOR pointer.
2194 17-263 066 203                LLI 203                ;Set L to address of TO pointer (formerly TOKEN)
2195 17-265 374                    LME                    ;Save pointer to TO in the TO pointer!
2196 17-266 066 204     FOR2:      LLI 204                ;Load L with address of the FOR pointer
2197 17-270 106 240 002            CAL GETCHR             ;Fetch a character from the statement line
2198 17-273 150 310 017            JTZ FOR3               ;If it is a space, ignore it
2199 17-276 074 275                CPI 275                ;Test to see if character is the "=" sign
2200 17-300 150 323 017            JTZ FOR4               ;If so, variable name is in the AUX SYMBOLBUFFER
2201 17-303 066 144                LLI 144                ;If not, then set L to point to start of the AUX SYMBOL
2202 17-305 106 314 002            CAL CONCT1             ;BUFFER and concatenate the character onto the buffer
2203 17-310 066 204     FOR3:      LLI 204                ;Reset L to address of the FOR pointer
2204 17-312 106 003 003            CAL LOOP               ;Increment the pointer and see if end of line
2205 17-315 110 266 017            JFZ FOR2               ;If not end of line, continue looking for the "=" sign
2206 17-320 104 243 017            JMP FORERR             ;If reach end of line before "=" sign, then have error
2207 17-323 066 204     FOR4:      LLI 204                ;Set L with address of the FOR pointer
2208 17-325 317                    LBM                    ;Fetch pointer value to ACC (pointing to sign)
2209 17-326 010                    INB                    ;Increment it to skip over the "=" sign
2210 17-327 066 276                LLI 276                ;Set L to address of the EVAL pointer
2211 17-331 371                    LMB                    ;Restore the updated pointer to storage
2212 17-332 066 203                LLI 203                ;Set L to the address of the TO pointer
2213 17-334 317                    LBM                    ;Fetch pointer value to ACC (pointing to letter T in TO)
2214 17-335 011                    DCB                    ;Decrement it to point to character before the T in TO
2215 17-336 066 277                LLI 277                ;Set L to EVAL FINISH pointer storage location
2216 17-340 371                    LMB                    ;Store the EVAL FINISH pointer value
2217 17-341 106 224 003            CAL EVAL               ;Evaluate the expression between the "=" sign and TO
2218 17-344 106 252 010            CAL RESTSY             ;Directive. Place the variable name in the variables table.
2219 17-347 066 144                LLI 144                ;Load L with starting address of the AUX SYMBOL BF
2220 17-351 056 026                LHI \HB\OLDPG26        ;** Load H with the page of the AUX SYMBOL BUFF
2221 17-353 307                    LAM                    ;Fetch the (cc) for the name in the buffer
2222 17-354 074 001                CPI 001                ;See if the symbol (name) length is just one character
2223 17-356 110 246 031            JFZ FOR5               ;If not, go directly to place name in FOR/NEXT STACK
2224 17-361 066 146                LLI 146                ;If so, set L to point to second character location in the
2225 17-363 076 000                LMI 000                ;AUX SYMBOL BUFFER and set it equal to zero.
2226 17-365 104 246 031            JMP FOR5               ;This jump directs program over ontrs/cntrs/table area
2227                    ;;; LAST LINE SHOULD START AT 17 365
2228                    ;;; PATCH AREA FOLLOWS THIS
2229                    	
2230                    	ORG 020#000
2231 20-000 066 126     FPFIX:     LLI 126                ;Set L to point to MSW of FPACC
2232 20-002 056 001                LHI \HB\OLDPG1         ;** Set H to point to page of FPACC
2233 20-004 307                    LAM                    ;Fetch MSW of FPACC
2234 20-005 066 100                LLI 100                ;Change pointer to SIGN indicator on same page
2235 20-007 370                    LMA                    ;Place MSW of FPACC into SIGN indicator
2236 20-010 240                    NDA                    ;Now test sign bit of MSW of FPACC
2237 20-011 162 202 020            CTS FPCOMP             ;Two's complement value in FPACC if negative
2238 20-014 066 127                LLI 127                ;Change pointer to FPACC Exponent register
2239 20-016 006 027                LAI 027                ;Set accumulator to 23 (decimal) for number of bits
2240 20-020 317                    LBM                    ;Load FPACC Exponent into CPU register B
2241 20-021 010                    INB                    ;Exercise the value in register B
2242 20-022 011                    DCB                    ;To set CPU flags
2243 20-023 160 051 020            JTS FPZERO             ;If FPACC Exponent is negative set FPACC to zero
2244 20-026 221                    SUB                    ;Subtract value of FPACC Exponent from 23 decimal
2245 20-027 160 366 012            JTS FIXERR             ;If Exp larger than 23 decimal cannot convert
2246 20-032 320                    LCA                    ;Else place result in register C as counter for number
2247 20-033 066 126     FPFIXL:    LLI 126                ;Of rotate ops. Set pointer to MSW of FPACC
2248 20-035 016 003                LBI 003                ;Set precision counter (number of bytes in mantissa)
2249 20-037 106 211 022            CAL ROTATR             ;Rotate FPACC right the number of places indicated
2250 20-042 021                    DCC                    ;By count in register C to effectively rotate all the
2251 20-043 110 033 020            JFZ FPFIXL             ;Significant bits to the left of the floating point decimal
2252 20-046 104 175 020            JMP RESIGN             ;Point. Go check original sign & negate answer if req'd.
2253                    
2254                                                      ;Following subroutine clears the FPACC to the zero
2255                                                      ;condition.
2256                    
2257 20-051 066 126     FPZERO:    LLI 126                ;Set L to point to MSW of FPACC
2258 20-053 250                    XRA                    ;Clear the accumulator
2259 20-054 370                    LMA                    ;Set the MSW of FPACC to zero
2260 20-055 061                    DCL                    ;Decrement the pointer
2261 20-056 370                    LMA                    ;Set the next significant word of FPACC to zero
2262 20-057 061                    DCL                    ;Decrement the pointer
2263 20-060 370                    LMA                    ;Set the LSW of FPACC to zero
2264 20-061 061                    DCL                    ;Decrement the pointer
2265 20-062 370                    LMA                    ;Set the auxiliary FPACC byte to zero
2266 20-063 007                    RET                    ;Exit to calling routine
2267                    
2268                                                      ;The next instruction is a special entry point to
2269                                                      ;the FPNORM subroutine that is used when a number is
2270                                                      ;converted from fixed to floating point. The FPNORM
2271                                                      ;label is the entry point when a number already in float-
2272                                                      ;ing point fonnat is to be normalized.
2273                    
2274 20-064 016 027     FPFLT:     LBI 027                ;For fixed to float set CPU register B to 23 decimal
2275 20-066 301         FPNORM:    LAB                    ;Get CPU register B into ACC to check for special case
2276 20-067 056 001                LHI \HB\OLDPG1         ;** Set H to page of FPACC
2277 20-071 066 127                LLI 127                ;Set L to FPACC Exponent byte
2278 20-073 240                    NDA                    ;Set CPU flags to test what was in CPU register B
2279 20-074 150 100 020            JTZ NOEXC0             ;If B was zero then do standard normalization
2280 20-077 371                    LMB                    ;Else set Exponent of FPACC to 23 decimal
2281 20-100 061         NOEXC0:    DCL                    ;Change pointer to MSW of FPACC
2282 20-101 307                    LAM                    ;Fetch MSW of FPACC into accumulator
2283 20-102 066 100                LLI 100                ;Change pointer to SIGN indicator storage location
2284 20-104 370                    LMA                    ;Place the MSW of FPACC there for future reference
2285 20-105 240                    NDA                    ;Set CPU flags to test MSW of FPACC
2286 20-106 120 120 020            JFS ACZERT             ;If sign bit not set then jump ahead to do next test
2287 20-111 016 004                LBI 004                ;If sign bit set, number in FPACC is negative. Set up
2288 20-113 066 123                LLI 123                ;For two's complement operation
2289 20-115 106 150 022            CAL COMPLM             ;And negate the value in the FPACC to make it positive
2290 20-120 066 126     ACZERT:    LLI 126                ;Reset pointer to MSW of FPACC
2291 20-122 016 004                LBI 004                ;Set precision counter to number of bytes in FPACC
2292 20-124 307         LOOK0:     LAM                    ;Plus one. Fetch a byte of the FPACC.
2293 20-125 240                    NDA                    ;Set CPU flags
2294 20-126 110 143 020            JFZ ACNONZ             ;If find anything then FPACC is not zero
2295 20-131 061                    DCL                    ;Else decrement pointer to NSW of FPACC
2296 20-132 011                    DCB                    ;Decrement precision counter
2297 20-133 110 124 020            JFZ LOOK0              ;Continue checking to see if FPACC contains anything
2298 20-136 066 127                LLI 127                ;Until precision counter is zero. If reach here then
2299 20-140 250                    XRA                    ;Reset pointer to FPACC Exponent. Clear the ACC and
2300 20-141 370                    LMA                    ;Clear out the FPACC Exponent. Value of FPACC is zip!
2301 20-142 007                    RET                    ;Exit to calling routine
2302 20-143 066 123     ACNONZ:    LLI 123                ;If FPACC has any value set pointer to LSW minus one
2303 20-145 016 004                LBI 004                ;Set precision counter to number of bytes in FPACC
2304 20-147 106 177 022            CAL ROTATL             ;Plus one for special cases. Rotate the contents of the
2305 20-152 307                    LAM                    ;FPACC to the LEFT. Pointer will be set to MSW after
2306 20-153 240                    NDA                    ;Rotate ops. Fetch MSW and see if have anything in
2307 20-154 160 166 020            JTS ACCSET             ;Most significant bit position. If so, have rotated enough
2308 20-157 060                    INL                    ;If not, advance pointer to FPACC Exponent. Fetch
2309 20-160 317                    LBM                    ;The value of the Exponent and decrement it by one
2310 20-161 011                    DCB                    ;To compensate for the rotate left of the mantissa
2311 20-162 371                    LMB                    ;Restore the new value of the Exponent
2312 20-163 104 143 020            JMP ACNONZ             ;Continue rotating ops to normalize the FPACC
2313 20-166 066 126     ACCSET:    LLI 126                ;Set pntr to FPACC MSW. Now must provide room for
2314 20-170 016 003                LBI 003                ;Sign bit in nonnalized FPACC. Set precision counter.
2315 20-172 106 211 022            CAL ROTATR             ;Rotate the FPACC once to the right now.
2316 20-175 066 100     RESIGN:    LLI 100                ;Set the pointer to SIGN indicator storage location
2317 20-177 307                    LAM                    ;Fetch the original sign of the FPACC
2318 20-200 240                    NDA                    ;Set CPU flags
2319 20-201 023                    RFS                    ;If original sign of FPACC was positive, can exit now.
2320                    
2321 20-202 066 124     FPCOMP:    LLI 124                ; However, if original sign was negative, must now restore
2322 20-204 016 003                LBI 003                ;The FPACC to negative by performing two's comple-
2323 20-206 104 150 022            JMP COMPLM             ;Ment on FPACC. Return to caring rtn via COMPLM.
2324                    
2325                                                      ;Floating point ADDITION. Adds contents of FPACC to
2326                                                      ;FPOP and leaves result in FPACC. Routine first checks
2327                                                      ;to see if either register contains zero. If so addition
2328                                                      ;result is already present!
2329                    
2330 20-211 066 126     FPADD:     LLI 126                ;Set L to point to MSW of FPACC
2331 20-213 056 001                LHI \HB\OLDPG1         ;** Do same for register H
2332 20-215 307                    LAM                    ;Fetch MSW of FPACC to accumulator
2333 20-216 240                    NDA                    ;Set CPU flags after loading op
2334 20-217 110 235 020            JFZ NONZAC             ;If accumulator non-zero then FPACC has some value
2335 20-222 066 124     MOVOP:     LLI 124                ;But, if accumulator was zero then normalized FPACC
2336 20-224 335                    LDH                    ;Must also be zero. Thus answer to addition is simply the
2337 20-225 346                    LEL                    ;Value in FPOP. Set up pointers to transfer contents of
2338 20-226 066 134                LLI 134                ;FPOP to FPACC by pointing to the LSW of both
2339 20-230 016 004                LBI 004                ;Registers and perform the transfer. Then exit to calling
2340 20-232 104 013 021            JMP MOVEIT             ;Routine with answer in FPACC via MOVEIT.
2341 20-235 066 136     NONZAC:    LLI 136                ;If FPACC was non-zero then check to see if FPOP has
2342 20-237 307                    LAM                    ;Some value by obtaining MSW of FPOP
2343 20-240 240                    NDA                    ;Set CPU flags after loading op. If MSW zero then
2344 20-241 053                    RTZ                    ;Normalized FPOP must be zero. Answer is in FPACC!
2345                    
2346                                                      ;If neither FPACC or FPOP was zero then must perform
2347                                                      ;addition operation. Must first check to see if two num-
2348                                                      ;bers are within significant mnge. If not, largest number
2349                                                      ;is answer. If numbers within range, then must align ex-
2350                                                      ;ponents before perforrning the addition of the man-
2351                                                      ;tissa.
2352                    
2353 20-242 066 127     CKEQEX:    LLI 127                ;Set pointer to FPACC Exponent storage location.
2354 20-244 307                    LAM                    ;Fetch the Exponent value to the accumulator.
2355 20-245 066 137                LLI 137                ;Change the pointer to the FPOP Exponent
2356 20-247 277                    CPM                    ;Compare the values of the exponents. If they are the
2357 20-250 150 341 020            JTZ SHACOP             ;Same then can immediately proceed to add operations.
2358 20-253 310                    LBA                    ;If not the same, store FPACC Exponent size in regis B
2359 20-254 307                    LAM                    ;Fetch the FPOP Exponent size into the ACC
2360 20-255 231                    SBB                    ;Subtract the FPACC Exponent from the FPOP Exp.
2361 20-256 120 264 020            JFS SKPNEG             ;If result is positive jump over the next few instructions
2362 20-261 310                    LBA                    ;If result was negative, store the result in B
2363 20-262 250                    XRA                    ;Clear the accumulator
2364 20-263 231                    SBB                    ;Subtract register B to negate the original value
2365 20-264 074 030     SKPNEG:    CPI 030                ;See if difference is less than 24 decimal.
2366 20-266 160 303 020            JTS LINEUP             ;If so, can align exponents. Go do it.
2367 20-271 307                    LAM                    ;If not, find out which number is largest. Fetch FPOP
2368 20-272 066 127                LLI 127                ;Exponent into ACC. Change pointer to FPACC Exp.
2369 20-274 227                    SUM                    ;Subtract FPACC from FPOP. If result is negative then
2370 20-275 063                    RTS                    ;was larger. Return with answer in FPACC.
2371 20-276 066 124                LLI 124                ;If result was positive, larger value in FPOP. Set pointers
2372 20-300 104 222 020            JMP MOVOP              ;To transfer FPOP into FPACC and then exit to caller.
2373 20-303 307         LINEUP:    LAM                    ;Fetch FPOP Exponent into accumulator.
2374 20-304 066 127                LLI 127                ;Change pointer to FPACC Exponent.
2375 20-306 227                    SUM                    ;Subtract FPACC Exponent from FPOP Exponent. If
2376 20-307 160 327 020            JTS SHIFT0             ;Result is negative FPACC is larger. Go shift FPOP.
2377 20-312 320                    LCA                    ;If result positive FPOP larger, must shift FPACC. Store
2378 20-313 066 127     MORACC:    LLI 127                ;Difference count in C. Reset pointer to FPACC Exp
2379 20-315 106 374 020            CAL SHLOOP             ;Call the SHift LOOP to rotate FPACC mantissa RIGHT
2380 20-320 021                    DCC                    ;And INCREMENT Exponent. Decr difference counter
2381 20-321 110 313 020            JFZ MORACC             ;Continue rotate operations until diff counter is zero
2382 20-324 104 341 020            JMP SHACOP             ;Go do final alignment and perform addition process
2383 20-327 320         SHIFT0:    LCA                    ;Routine to shift FPOP. Set difference count into reg. C
2384 20-330 066 137     MOROP:     LLI 137                ;Set pointer to FPOP Exponent.
2385 20-332 106 374 020            CAL SHLOOP             ;Call the SHift LOOP to rotate FPOP mantissa RIGHT
2386 20-335 020                    INC                    ;And INCREMENT Exponent. Then incr difference cntr
2387 20-336 110 330 020            JFZ MOROP              ;Continue rotate opemtions until diff counter is zero
2388                    ;;; The below two instructions are changed by PATCH NR.1
2389                    ;;;SHACOP:    LLI 123                ;Set pointer to FPACC LSW minus one to provide extra
2390                    ;;;           LMI 000                ;Byte for addition ops. Clear that location to zero.
2391 20-341 106 000 030 SHACOP:	   CAL PATCH1		; patch 1 inserts a few lines at 30-000
2392 20-344 300         	   LAA
2393                    	
2394                    ;;;           LLI 133
2395                    ;;;           LMI 000                ;THIS IS PATCH #1
2396 20-345 066 127                LLI 127                ;Change pointer to FPACC Exponent
2397 20-347 106 374 020            CAL SHLOOP             ;Rotate FPACC mantissa RIGHT & Increment Exponent
2398 20-352 066 137                LLI 137                ;Change pointer to FPOP Exponent
2399 20-354 106 374 020            CAL SHLOOP             ;Rotate FPOP mantissa RIGHT & Increment Exponent
2400 20-357 335                    LDH                    ;Rotate ops provide room for overflow. Now set up
2401 20-360 046 123                LEI 123                ;Pointers to LSW minus one for both FPACC & FPOP
2402 20-362 016 004                LBI 004                ;(FPOP already set after SHLOOP). Set precision counter
2403 20-364 106 127 022            CAL ADDER              ;Call quad precision ADDITION subroutine.
2404 20-367 016 000                LBI 000                ;Set CPU register B to indicate standard normalization
2405 20-371 104 066 020            JMP FPNORM             ;Go normalize the result and exit to caller.
2406 20-374 317         SHLOOP:    LBM                    ;Shifting loop. First fetch Exponent currently being
2407 20-375 010                    INB                    ;Pointed to and Increment the value by one.
2408 20-376 371                    LMB                    ;Return the updated Exponent value to memory.
2409 20-377 061                    DCL                    ;Decrement the pointer to mantissa portion MSW
2410 21-000 016 004                LBI 004                ;Set precision counter
2411 21-002 307         FSHIFT:    LAM                    ;Fetch MSW of mantissa
2412 21-003 240                    NDA                    ;Set CPU flags after load ops
2413 21-004 120 211 022            JFS ROTATR             ;If MSB not a one can do normal rotate ops
2414 21-007 022         BRING1:    RAL                    ;If MSB is a one need to set up carrv bit for the negative
2415 21-010 104 212 022            JMP ROTR               ;Number case. Then make special entry to ROTATR sub
2416                    
2417                                                      ;The following subroutine moves the contents of a string
2418                                                      ;of memory locations from the address pointed to by
2419                                                      ;CPU registers H & L to the address specified by the con-
2420                                                      ;tents of registers D & E when the routine is entered. The
2421                                                      ;process continues until the counter in register B is zero.
2422                    
2423 21-013 307         MOVEIT:    LAM                    ;Fetch a word from memory string A
2424 21-014 060                    INL                    ;Advance A string pointer
2425 21-015 106 356 022            CAL SWITCH             ;Switch pointer to string B
2426 21-020 370                    LMA                    ;Put word from string A into string B
2427 21-021 060                    INL                    ;Advance B string pointer
2428 21-022 106 356 022            CAL SWITCH             ;Switch pointer back to string A
2429 21-025 011                    DCB                    ;Decrement loop counter
2430 21-026 053                    RTZ                    ;Return to calling routine when counter reaches zero
2431 21-027 104 013 021            JMP MOVEIT             ;Else continue transfer operations
2432                    
2433                                                      ;The following subroutine SUBTRACTS the
2434                                                      ;contents of the FLOATING POINT ACCUMULATOR from the
2435                                                      ;contents of the FLOATING POINT OPERAND and
2436                                                      ;leaves the result in the FPACC. The routine merely
2437                                                      ;negates the value in the FPACC and then goes to the
2438                                                      ;FPADD subroutine just presented.
2439                    
2440 21-032 066 124     FPSUB:     LLI 124                ;Set L to address of LSW of FPACC
2441 21-034 056 001                LHI \HB\OLDPG1         ;** Set H to page of FPACC
2442 21-036 016 003                LBI 003                ;Set precision counter
2443 21-040 106 150 022            CAL COMPLM             ;Two's complement the value in the FPACC
2444 21-043 104 211 020            JMP FPADD              ;Now go add the negated value to perform subtraction!
2445                    
2446                                                      ;The first part of the FLOATING POINT MULTIPLI-
2447                                                      ;CATION subroutine calls a subroutine to check the
2448                                                      ;original signs of the numbers that are to be multi-
2449                                                      ;plied and perform working register clearing functions.
2450                                                      ;Next the exponents of the numbers to be multiplied
2451                                                      ;are added together.
2452                    
2453 21-046 106 166 021 FPMULT:    CAL CKSIGN             ;Call routine to set up registers & ck signs of numbers
2454 21-051 066 137     ADDEXP:    LLI 137                ;Set pointer to FPOP Exponent
2455 21-053 307                    LAM                    ;Fetch FPOP Exponent into the accumulator
2456 21-054 066 127                LLI 127                ;Change pointer to FPACC Exponent
2457 21-056 207                    ADM                    ;Add FPACC Exponent to FPOP Exponent
2458 21-057 004 001                ADI 001                ;Add one more to total for algorithm compensation
2459 21-061 370                    LMA                    ;Store result in FPACC Exponent location
2460 21-062 066 102     SETMCT:    LLI 102                ;Change pointer to bit counter storage location
2461 21-064 076 027                LMI 027                ;Initialize bit counter to 23 decimal
2462                    
2463                                                      ;Next portion of the FPMULT routine is the iinplernen-
2464                                                      ;tation of the algorithm illustrated in the flow chart
2465                                                      ;above. This portion multiplies the values of the two
2466                                                      ;mantissas. The final value is rounded off to leave the
2467                                                      ;23 most significant bits as the answer that is stored
2468                                                      ;back in the FPACC.
2469                    
2470 21-066 066 126     MULTIP:    LLI 126                ;Set pointer to MSW of FPACC mantissa
2471 21-070 016 003                LBI 003                ;Set precision counter
2472 21-072 106 211 022            CAL ROTATR             ;Rotate FPACC (multiplier) RIGHT into carry bit
2473 21-075 142 270 021            CTC ADOPPP             ;If carry is a one, add multiplicand to partial-product
2474 21-100 066 146                LLI 146                ;Set pointer to partial-product most significant byte
2475 21-102 016 006                LBI 006                ;Set precision counter (p-p register is double length)
2476 21-104 106 211 022            CAL ROTATR             ;Shift partial-product RIGHT
2477 21-107 066 102                LLI 102                ;Set pointer to bit counter storage location
2478 21-111 327                    LCM                    ;Fetch current value of bit counter
2479 21-112 021                    DCC                    ;Decrement the value of the bit counter
2480 21-113 372                    LMC                    ;Restore the updated bit counter to its storage location
2481 21-114 110 066 021            JFZ MULTIP             ;If have not multiplied for 23 (deciinal) bits, keep going
2482 21-117 066 146                LLI 146                ;If have done 23 (decimal) bits, set pntr to p-p MSW
2483 21-121 016 006                LBI 006                ;Set precision counter (for double length)
2484 21-123 106 211 022            CAL ROTATR             ;Shift partial-product once more to the RIGHT
2485 21-126 066 143                LLI 143                ;Set pointer to access 24'th bit in partial-product
2486 21-130 307                    LAM                    ;Fetch the byte containing the 24'th bit
2487 21-131 022                    RAL                    ;Position the 24'th bit to be MSB in the accumulator
2488 21-132 240                    NDA                    ;Set the CPU flags after to rotate operation and test to
2489 21-133 162 302 021            CTS MROUND             ;See if 24'th bit of p-p is a ONE. If so, must round-off
2490 21-136 066 123                LLI 123                ;Now set up pointers
2491 21-140 346                    LEL                    ;To perform transfer
2492 21-141 335                    LDH                    ;Of the multiplication results
2493 21-142 066 143                LLI 143                ;From the partial-product location
2494 21-144 016 004                LBI 004                ;To the FPACC
2495                    
2496                    	
2497 21-146 106 013 021 EXMLDV:    CAL MOVEIT             ;Perform the transfer from p-p to FPACC
2498 21-151 016 000                LBI 000                ;Set up CPU register B to indicate regular normalization
2499 21-153 106 066 020            CAL FPNORM             ;Normalize the result of multiplication
2500 21-156 066 101                LLI 101                ;Now set the pointer to the original SIGNS indicator
2501 21-160 307                    LAM                    ;Fetch the indicator
2502 21-161 240                    NDA                    ;Exercise the CPU flags
2503 21-162 013                    RFZ                    ;If indicator is non-zero, answer is positive, can exit her
2504 21-163 104 202 020            JMP FPCOMP             ;If not, answer must be negated, exit via 2's complement.
2505                    
2506                                                      ;The following portions of the FPMULT
2507                                                      ;routine set up working locations in memory by clearing
2508                                                      ;locations for an expanded FPOP area and the partial-produc
2509                                                      ;area. Next, the signs of the two numbers to be multiplied
2510                                                      ;are examined. Negative numbers are negated
2511                                                      ;in preparation for the multiplication
2512                                                      ;algorithm. A SIGNS indicator register is set up during
2513                                                      ;this process to indicate whether the final result of the
2514                                                      ;multiplication should be positive or negative. (Negative
2515                                                      ;if original signs of the two numbers to be multiplied are
2516                                                      ;different.)
2517                    
2518 21-166 066 140     CKSIGN:    LLI 140                ;Set pointer to start of partial-product working area
2519 21-170 056 001                LHI \HB\OLDPG1         ;** Set H to proper page
2520 21-172 016 010                LBI 010                ;Set up a loop counter in CPU register B
2521 21-174 250                    XRA                    ;Clear the accumulator
2522                    
2523 21-175 370         CLRNEX:    LMA                    ;Now clear out locations for the partial-product
2524 21-176 060                    INL                    ;Working registers
2525 21-177 011                    DCB                    ;Until the loop counter
2526 21-200 110 175 021            JFZ CLRNEX             ;Is zero
2527 21-203 016 004     CLROPL:    LBI 004                ;Set a loop counter
2528 21-205 066 130                LLI 130                ;Set up pointer
2529 21-207 370         CLRNX1:    LMA                    ;Clear out some extra registers so that the
2530 21-210 060                    INL                    ;FPOP may be extended in length
2531 21-211 011                    DCB                    ;Perform clearing ops until loop counter
2532 21-212 110 207 021            JFZ CLRNX1             ;Is zero
2533 21-215 066 101                LLI 101                ;Set pointer to M/D SIGNS indicator storage location
2534 21-217 076 001                LMI 001                ;Set initial value of SIGNS indicator to plus one
2535 21-221 066 126                LLI 126                ;Change pointer to MSW of FPACC
2536 21-223 307                    LAM                    ;Fetch MSW of mantissa into accumulator
2537 21-224 240                    NDA                    ;Test flags
2538 21-225 160 251 021            JTS NEGFPA             ;If MSB in MSW of FPACC is a one, number is negative
2539 21-230 066 136     OPSGNT:    LLI 136                ;Set pointer to MSW of FPOP
2540 21-232 307                    LAM                    ;Fetch MSW of mantissa into accumulator
2541 21-233 240                    NDA                    ;Test flags
2542 21-234 023                    RFS                    ;Return to caller if number in FPOP is positive
2543 21-235 066 101                LLI 101                ;Else change pointer to M/D SIGNS indicator
2544 21-237 327                    LCM                    ;Fetch the value in the SIGNS indicator
2545 21-240 021                    DCC                    ;Decrement the value by one
2546 21-241 372                    LMC                    ;Restore the new value back to storage location
2547 21-242 066 134                LLI 134                ;Set pointer to LSW of FPOP
2548 21-244 016 003                LBI 003                ;Set precision counter
2549 21-246 104 150 022            JMP COMPLM             ;Two's complement value of FPOP & return to caller
2550 21-251 066 101     NEGFPA:    LLI 101                ;Set pointer to M/D SIGNS indicator
2551 21-253 327                    LCM                    ;Fetch the value in the SIGNS indicator
2552 21-254 021                    DCC                    ;Decrement the value by one
2553 21-255 372                    LMC                    ;Restore the new value back to storage location
2554 21-256 066 124                LLI 124                ;Set pointer to LSW of FPACC
2555 21-260 016 003                LBI 003                ;Set precision counter
2556 21-262 106 150 022            CAL COMPLM             ;Two's complement value of FPACC
2557 21-265 104 230 021            JMP OPSGNT             ;Proceed to check sign of FPOP
2558                    
2559                                                      ;The following subroutine adds the double length (six regis
2560                                                      ;multiplicand in FPOP to the partial-product register when
2561                                                      ;called on by the multiplication algorithm.
2562                    
2563 21-270 046 141     ADOPPP:    LEI 141                ;Pointer to LSW of partial-product
2564 21-272 335                    LDH                    ;On same page as FPOP
2565 21-273 066 131                LLI 131                ;LSIV of FPOP which contains extended multiplicand
2566 21-275 016 006                LBI 006                ;Set precision counter (double length working registers)
2567 21-277 104 127 022            JMP ADDER              ;Add multiplicand to partial-product & return to caller
2568                    
2569 21-302 016 003     MROUND:    LBI 003                ;Set up precision counter
2570 21-304 006 100                LAI 100                ;Prepare to add one to 24'th bit of partial-product
2571 21-306 207                    ADM                    ;Add one to the 24'th bit of the partial-product
2572 21-307 370         CROUND:    LMA                    ;Restore the updated byte to memory
2573 21-310 060                    INL                    ;Advance the memory pointer to next most significant
2574 21-311 006 000                LAI 000                ;Byte of partial-product, then clear ACC without
2575 21-313 217                    ACM                    ;Disturbing carry bit. Now perform add with carry to
2576 21-314 011                    DCB                    ;Propagate any rounding in the partial-product registers.
2577 21-315 110 307 021            JFZ CROUND             ;If cotinter is not zero continue propagating any carry
2578 21-320 370                    LMA                    ;Restore final byte to memory
2579 21-321 007                    RET                    ;Exit to calling routine
2580                    
2581 21-322 106 166 021 FPDIV:     CAL CKSIGN             ;Call routine to set up registers & ck signs of numbers
2582 21-325 066 126                LLI 126                ;Set pointer to MSW of FPACC (divisor)
2583 21-327 307                    LAM                    ;Fetch MSW of FPACC to accumulator
2584 21-330 240                    NDA                    ;Exercise CPU flags
2585 21-331 150 357 012            JTZ DVERR              ;If MSW of FPACC is zero go display 'DZ' error message
2586 21-334 066 137     SUBEXP:    LLI 137                ;Set pointer to FPOP (dividend) Exponent
2587 21-336 307                    LAM                    ;Get FPOP Exponent into accumulator
2588 21-337 066 127                LLI 127                ;Change pointer to FPACC (divisor) Exponent
2589 21-341 227                    SUM                    ;Subtract divisor exponent from dividend exponent
2590 21-342 004 001                ADI 001                ;Add one for algorithm compensation
2591 21-344 370                    LMA                    ;Place result in FPACC Exponent
2592 21-345 066 102     SETDCT:    LLI 102                ;Set pointer to bit counter storage location
2593 21-347 076 027                LMI 027                ;Initialize bit counter to 23 decimal
2594                    
2595                                                      ;Main division algorithm for mantissas
2596                    
2597 21-351 106 101 022 DIVIDE:    CAL SETSUB             ;Go subtmct divisor from dividend
2598 21-354 160 376 021            JTS NOGO               ;If result is negative then place a zero bit in quotient
2599 21-357 046 134                LEI 134                ;If result zero or positive then move remainder after
2600 21-361 066 131                LLI 131                ;Subtraction from working area to become new dividend
2601 21-363 016 003                LBI 003                ;Set up moving pointers and initialize precision counter
2602 21-365 106 013 021            CAL MOVEIT             ;Perform the transfer
2603 21-370 006 001                LAI 001                ;Place a one into least significant bit of accumulator
2604 21-372 032                    RAR                    ;And rotate it out into the carry bit
2605 21-373 104 377 021            JMP QUOROT             ;Proceed to rotate the carry bit into the current quotient
2606 21-376 250         NOGO:      XRA                    ;When result is negative, put a zero in the carry bit, then
2607 21-377 066 144     QUOROT:    LLI 144                ;Set up pointer to LSW of quotient register
2608 22-001 016 003                LBI 003                ;Set precision counter
2609 22-003 106 200 022            CAL ROTL               ;Rotate carry bit into quotient by using special entry to
2610 22-006 066 134                LLI 134                ;ROTATL subroutine. Now set up pointer to dividend
2611 22-010 016 003                LBI 003                ;LSW and set precision counter
2612 22-012 106 177 022            CAL ROTATL             ;Rotate the current dividend to the left
2613 22-015 066 102                LLI 102                ;Set pointer to bit counter storage location
2614 22-017 327                    LCM                    ;Fetch the value of the bit counter
2615 22-020 021                    DCC                    ;Decrement the value by one
2616 22-021 372                    LMC                    ;Restore the new counter value to storage
2617 22-022 110 351 021            JFZ DIVIDE             ;If bit counter is not zero, continue division process
2618 22-025 106 101 022            CAL SETSUB             ;After 23 (decimal) bits, do subtraction once more for
2619 22-030 160 070 022            JTS DVEXIT             ;Possible rounding. Jump ahead if no rounding required.
2620 22-033 066 144                LLI 144                ;If rounding required set pointer to LSW of quotient
2621 22-035 307                    LAM                    ;Fetch LSW of quotient to accumulator
2622 22-036 004 001                ADI 001                ;Add one to 23rd bit of quotient
2623 22-040 370                    LMA                    ;Restore updated LSW of quotient
2624 22-041 006 000                LAI 000                ;Clear accumulator without disturbing carry bit
2625 22-043 060                    INL                    ;Advance pointer to next significant byte of quotient
2626 22-044 217                    ACM                    ;Propagate any carry as part of rounding process
2627 22-045 370                    LMA                    ;Restore the updated byte of quotient
2628 22-046 006 000                LAI 000                ;Clear ACC again without disturbing carry bit
2629 22-050 060                    INL                    ;Advance pointer to MSW of quotient
2630 22-051 217                    ACM                    ;Propagate any carry to finish rounding process
2631 22-052 370                    LMA                    ;Restore the updated byte of quotient
2632 22-053 120 070 022            JFS DVEXIT             ;If most significant bit of quotient is zero, go finish up
2633 22-056 016 003                LBI 003                ;If not, set precision counter
2634 22-060 106 211 022            CAL ROTATR             ;And rotate quotient to the right to clear the sign bit
2635 22-063 066 127                LLI 127                ;Set pointer to FPACC Exponent
2636 22-065 317                    LBM                    ;Fetch FPACC exponent
2637 22-066 010                    INB                    ;Increment the value to compensate for the rotate right
2638 22-067 371                    LMB                    ;Restore the updated exponent value
2639 22-070 066 143     DVEXIT:    LLI 143                ;Set up pointers
2640 22-072 046 123                LEI 123                ;To transfer the quotient into the FPACC
2641 22-074 016 004                LBI 004                ;Set precision counter
2642                                                      ;THIS IS A CORRECTION FOUND IN THE NOTES
2643 22-076 104 146 021            JMP EXMLDV             ;And exit through FPMULT routine at EXMLDV
2644                    
2645                                                      ;Subroutine to subtract divisor from dividend. Used by
2646                                                      ;main DIVIDE subroutine.
2647                    
2648 22-101 046 131     SETSUB:    LEI 131                ;Set pointer to LSW of working area
2649 22-103 335                    LDH                    ;On same page as FPACC
2650 22-104 066 124                LLI 124                ;Set pointer to LSW of FPACC (divisor)
2651 22-106 016 003                LBI 003                ;Set precision counter
2652 22-110 106 013 021            CAL MOVEIT             ;Perform transfer
2653 22-113 046 131                LEI 131                ;Reset pointer to LSW of working area (now divisor)
2654 22-115 066 134                LLI 134                ;Reset pointer to LSW of FPOP (dividend)
2655 22-117 016 003                LBI 003                ;Set precision counter
2656 22-121 106 223 022            CAL SUBBER             ;Subtract divisor from dividend
2657 22-124 307                    LAM                    ;Get MSW of the result of the subtraction operations
2658 22-125 240                    NDA                    ;Exercise CPU flags
2659 22-126 007                    RET                    ;Return to caller with status
2660 22-127 240         ADDER:     NDA                    ;Initialize the carry bit to zero upon entry
2661 22-130 307         ADDMOR:    LAM                    ;Fetch byte from register group A
2662 22-131 106 356 022            CAL SWITCH             ;Switch memory pointer to register group B
2663 22-134 217                    ACM                    ;Add byte from A to byte from B with carry
2664 22-135 370                    LMA                    ;Leave result in register group B
2665 22-136 011                    DCB                    ;Decrement number of bytes (precision) counter
2666 22-137 053                    RTZ                    ;Return to caller when all bytes in group processed
2667 22-140 060                    INL                    ;Else advance pointer for register group B
2668 22-141 106 356 022            CAL SWITCH             ;Switch memory pointer back to register group A
2669 22-144 060                    INL                    ;Advance the pointer for register group A
2670 22-145 104 130 022            JMP ADDMOR             ;Continue the multi-byte addition operation
2671                    
2672                                                      ;N'th precision two's complement (negate)
2673                                                      ;subroutine. Performs a two's complement on the multi-byte
2674                                                      ;registers tarting at the address pointed
2675                                                      ; to by H & L (least significant byte) upon entry.
2676                    
2677 22-150 307         COMPLM:    LAM                    ;Fetch the least significant byte of the number to ACC
2678 22-151 054 377                XRI 377                ;Exclusive OR to complement the byte
2679 22-153 004 001                ADI 001                ;Add one to form two's complement of byte
2680 22-155 370         MORCOM:    LMA                    ;Restore the negated byte to memory
2681 22-156 032                    RAR                    ;Save the carry bit
2682 22-157 330                    LDA                    ;In CPU register D
2683 22-160 011                    DCB                    ;Decrement number of bytes (precision) counter
2684 22-161 053                    RTZ                    ;Return to caller when all bytes in number processed
2685 22-162 060                    INL                    ;Else advance the pointer
2686 22-163 307                    LAM                    ;Fetch the next byte of the number to ACC
2687 22-164 054 377                XRI 377                ;Exclusive OR to complement the byte
2688 22-166 340                    LEA                    ;Save complemented value in register E temporarily
2689 22-167 303                    LAD                    ;Restore previous carry status to ACC
2690 22-170 022                    RAL                    ;And rotate it out to the carry bit
2691 22-171 006 000                LAI 000                ;Clear ACC without disturbing carry status
2692 22-173 214                    ACE                    ;Add in any carry to complemented value
2693 22-174 104 155 022            JMP MORCOM             ;Continue the two's complement procedure as req'd
2694                    
2695                                                      ;N'th precision rotate left subroutine. Rotates a multi-
2696                                                      ;byte number left starting at the address initially
2697                                                      ;specified by the contents of CPU registers H & L upon
2698                                                      ;subroutine entry (LSW). First entry point will clear
2699                                                      ;the carry bit before beginning rotate operations. Second
2700                                                      ;entry point does not clear the carry bit.
2701                    
2702 22-177 240         ROTATL:    NDA                    ;Clear the carry bit at this entry point
2703 22-200 307         ROTL:      LAM                    ;Fetch a byte from memory
2704 22-201 022                    RAL                    ;Rotate it left (bring carry into LSB, push MSB to carry)
2705 22-202 370                    LMA                    ;Restore rotated word to memory
2706 22-203 011                    DCB                    ;Decrement precision counter
2707 22-204 053                    RTZ                    ;Exit to caller when finished
2708 22-205 060                    INL                    ;Else advance pointer to next byte
2709 22-206 104 200 022            JMP ROTL               ;Continue rotate left operations
2710                    
2711                    
2712                                                      ;N'th precision rotate
2713                                                      ;right subroutine. Opposite of
2714                                                      ;above subroutine.
2715                    
2716 22-211 240         ROTATR:    NDA                    ;Clear the carry bit at this entry point
2717 22-212 307         ROTR:      LAM                    ;Fetch a byte from memory
2718 22-213 032                    RAR                    ;Rotate it right (carry into MSB, LSB to carry)
2719 22-214 370                    LMA                    ;Restore rotated word to memory
2720 22-215 011                    DCB                    ;Decrement precision counter
2721 22-216 053                    RTZ                    ;Exit to caller when finished
2722 22-217 061                    DCL                    ;Else decrement pointer to next byte
2723 22-220 104 212 022            JMP ROTR               ;Continue rotate right operations
2724                    
2725                                                      ;N'th precision subtraction subroutine.
2726                                                      ;Number starting at location pointed to by D & E (least
2727                                                      ;significant byte) is subtracted from number starting at
2728                                                      ;address specified by contents of H & L.
2729                    
2730 22-223 240         SUBBER:    NDA                    ;Initialize the carry bit to zero upon entry
2731 22-224 307         SUBTRA:    LAM                    ;Fetch byte from register group A
2732 22-225 106 356 022            CAL SWITCH             ;Switch memory pointer to register group B
2733 22-230 237                    SBM                    ;Subtract byte from group B ftom that in group A
2734 22-231 370                    LMA                    ;Leave result in register group B
2735 22-232 011                    DCB                    ;Decrement number of bytes (precision) counter
2736 22-233 053                    RTZ                    ;Return to caller when all bytes in group processed
2737 22-234 060                    INL                    ;Else advance pointer for register group B
2738 22-235 106 356 022            CAL SWITCH             ;Switch memory pointer back to register group A
2739 22-240 060                    INL                    ;Advance the pointer for register group A
2740 22-241 104 224 022            JMP SUBTRA             ;Continue the multi-byte subtraction operation
2741                    
2742                                                      ;The next subroutine will transfer the four byte
2743                                                      ;register string (generally a number in floating point
2744                                                      ;format) from the starting address pointed to by CPU
2745                                                      ;registers H & L when the subroutine is entered to
2746                                                      ;the FPACC (floating point accumulator registers).
2747                    
2748 22-244 036 001     FLOAD:     LDI \HB\OLDPG1         ;** Set page address of FPACC
2749 22-246 046 124                LEI 124                ;Set address of least signficant byte of FPACC
2750 22-250 016 004                LBI 004                ;Set precision counter to four bytes (mantissa bytes
2751 22-252 104 013 021            JMP MOVEIT             ;Plus Exponent) and exit via the transfer routine
2752                    
2753                                                      ;The next several subroutines are used to perform
2754                                                      ;floating pojnt register loading and transfer operations.
2755                    
2756 22-255 346         FSTORE:    LEL                    ;Transfer contents of register L to E
2757 22-256 335                    LDH                    ;Transfer contents of register H to D
2758 22-257 066 124                LLI 124                ;Set L to least significant byte of FPACC mantissa
2759 22-261 056 001                LHI \HB\OLDPG1         ;** Set page to FPACC storage area
2760 22-263 104 272 022            JMP SETIT              ;Go transfer FPACC contents to area pointed to by D&E
2761 22-266 036 001     OPLOAD:    LDI \HB\OLDPG1         ;** Set page to FPOP storage area
2762 22-270 046 134                LEI 134                ;Set pointer to least significant byte of FPOP
2763 22-272 016 004     SETIT:     LBI 004                ;Set precision counter. Transfer from H & L area to
2764 22-274 104 013 021            JMP MOVEIT             ;Locations pointed to by D & E
2765                    
2766                                                      ;The next subroutine perforins a double transfer opera-
2767                                                      ;tion. It first transfers the contents of the FPACC into
2768                                                      ;the FPOP. It then transfers new data (as pointed to by
2769                                                      ;H & L upon entry to the subroutine) into the FPACC.
2770                    
2771 22-277 106 317 022 FACXOP:    CAL SAVEHL             ;Save contents of H & L upon entry to subroutine
2772 22-302 066 124                LLI 124                ;Set pointer to FPACC LSW
2773 22-304 056 001                LHI \HB\OLDPG1         ;** Set pointer to page of FPACC
2774 22-306 106 266 022            CAL OPLOAD             ;Transfer FPACC to FPOP
2775 22-311 106 337 022            CAL RESTHL             ;Recover original subroutine entry values for H & L
2776 22-314 104 244 022            JMP FLOAD              ;Transfer registers pointed to by H & L into the FPACC
2777                    
2778                                                      ;Subroutine to save the contents of CPU registers D, E, H
2779                                                      ;and L in a temporary storage area in memory.
2780                    
2781 22-317 305         SAVEHL:    LAH                    ;Transfer value in H to ACC
2782 22-320 316                    LBL                    ;And value in L to B
2783 22-321 066 200                LLI 200                ;Now set L to start of tempomry storage locations
2784 22-323 056 001                LHI \HB\OLDPG1         ;** And set H to storage area page
2785 22-325 370                    LMA                    ;Save A (entry value of H) in memory
2786 22-326 060                    INL                    ;Advance pointer
2787 22-327 371                    LMB                    ;Save B (entry value of L) in memory
2788 22-330 060                    INL                    ;Advance pointer
2789 22-331 373                    LMD                    ;Save D in memory
2790 22-332 060                    INL                    ;Advance pointer
2791 22-333 374                    LME                    ;Save E in memory
2792 22-334 350                    LHA                    ;Restore entry value of H
2793 22-335 361                    LLB                    ;Restore entry value of L
2794 22-336 007                    RET                    ;Exit to calling routine
2795                    
2796                                                      ;Subroutine to restore the contents of CPU registers D,
2797                                                      ;E, H and L from temporary storage in memory.
2798                    
2799 22-337 066 200     RESTHL:    LLI 200                ;Set L to start of temporary storage locations
2800 22-341 056 001                LHI \HB\OLDPG1         ;** Set H to storage area page
2801 22-343 307                    LAM                    ;Fetch stored value for li iii ACC
2802 22-344 060                    INL                    ;Advance pointer
2803 22-345 317                    LBM                    ;Fetch stored value for L into B
2804 22-346 060                    INL                    ;Advance pointer
2805 22-347 337                    LDM                    ;Fetch stored value for T.)
2806 22-350 060                    INL                    ;Advance pointer
2807 22-351 347                    LEM                    ;Fetch stored value for
2808 22-352 350                    LHA                    ;Restore  saved value for H
2809 22-353 361                    LLB                    ;Restore saved value for L
2810 22-354 307                    LAM                    ;Leave stored value for E in ACC
2811 22-355 007                    RET                    ;Exit to calling routine
2812                    
2813                                                      ;Subroutine to exchange the contents of H & L with
2814                                                      ;D & E.
2815                    
2816 22-356 325         SWITCH:    LCH                    ;Transfer register H to C temporarily
2817 22-357 353                    LHD                    ;Place value of D into H
2818 22-360 332                    LDC                    ;Now put former H from C into D
2819 22-361 326                    LCL                    ;Transfer register L to C temporarily
2820 22-362 364                    LLE                    ;Place value of E into L
2821 22-363 342                    LEC                    ;Now put former L from C into E
2822 22-364 007                    RET                    ;Exit to calling routine
2823 22-365 056 001     GETINP:    LHI \HB\OLDPG1         ;** Set H to page of GETINP character counter
2824 22-367 066 220                LLI 220                ;Set L to address of GETINP character counter
2825 22-371 327                    LCM                    ;Load counter value into CPU register C
2826 22-372 020                    INC                    ;Exercise the counter in order
2827 22-373 021                    DCC                    ;To set CPU flags. If counter is non-zero, then indexing
2828 22-374 110 010 023            JFZ NOT0               ;Register (GETINP counter) is all set so jump ahead.
2829 22-377 364                    LLE                    ;But, if counter zero, then starting to process a new
2830 23-000 353                    LHD                    ;Character string. Transfer char string buffer pointer into
2831 23-001 327                    LCM                    ;H & L and fetch the string's character count value (cc)
2832 23-002 020                    INC                    ;Increment the (cc) by one to take account of (cc) byte
2833 23-003 106 036 023            CAL INDEXC             ;Add contents of regis C to H & L to point to end of the
2834 23-006 076 000                LMI 000                ;Character string in buffer and place a zero byte marker
2835 23-010 066 220     NOT0:      LLI 220                ;Set L back to address of GETINP counter which is used
2836 23-012 056 001                LHI \HB\OLDPG1         ;** As an indexing value. Set H to correct page.
2837 23-014 327                    LCM                    ;Fetch the value of GETINP counter into register C
2838 23-015 020                    INC                    ;Increment the value in C
2839 23-016 372                    LMC                    ;Restore the updated value for future use
2840 23-017 364                    LLE                    ;Bring the base address of the character string buffer into
2841 23-020 353                    LHD                    ;CPU registers H & L
2842 23-021 106 036 023            CAL INDEXC             ;Add contents of register C to form indexed address of
2843 23-024 307                    LAM                    ;Next character to be fetched as input. Fetch the next
2844 23-025 240                    NDA                    ;Character. Exercise the CPU flags.
2845 23-026 056 001                LHI \HB\OLDPG1         ;** Restore page pointer to floating point working area
2846 23-030 013                    RFZ                    ;If character is non-zero, not end of string, exit to calle
2847 23-031 066 220                LLI 220                ;If zero character, must reset GETINP counter for next
2848 23-033 076 000                LMI 000                ;String. Reset pointer and clear GETINP counter to zero
2849 23-035 007                    RET                    ;Then exit to calling routine
2850                    
2851                                                      ;Following subroutine causes register C to be used as an
2852                                                      ;indexing register. Value in C is added to address in H
2853                                                      ;and L to form new address.
2854                    
2855 23-036 306         INDEXC:    LAL                    ;Place value from register L into accumulator
2856 23-037 202                    ADC                    ;Add quantity in register C
2857 23-040 360                    LLA                    ;Restore updated value back to L
2858 23-041 003                    RFC                    ;Exit to caller if no carry from addition
2859 23-042 050                    INH                    ;But, if have carry then must increment register H
2860 23-043 007                    RET                    ;Before returning to calling routine
2861                    
2862                                                      ;Main Decimal INPUT subroutine to convert strings of
2863                                                      ;ASCII characters representing decimal fixed or floating
2864                                                      ;point numbers to binary floating point numbers.
2865                    
2866 23-044 346         DINPUT:    LEL                    ;Save entry value of register L in E. (Pointer to buffer
2867 23-045 335                    LDH                    ;Containing ASCII character string.) Do same for H to D.
2868 23-046 056 001                LHI \HB\OLDPG1         ;** Set H to page of floating point working registers
2869 23-050 066 150                LLI 150                ;Set L to start of decirnal-to-binary working area
2870 23-052 250                    XRA                    ;Clear the accumulator
2871 23-053 016 010                LBI 010                ;Set up a loop counter
2872 23-055 370         CLRNX2:    LMA                    ;Deposit zero in working area to initialize
2873 23-056 060                    INL                    ;Advance the memory pointer
2874 23-057 011                    DCB                    ;Decrement the loop counter
2875 23-060 110 055 023            JFZ CLRNX2             ;Clear working area until loop counter is zero
2876 23-063 066 103                LLI 103                ;Set pointer to floating point temporary registers and
2877 23-065 016 004                LBI 004                ;Indicators working area. Set up a loop counter.
2878 23-067 370         CLRNX3:    LMA                    ;Deposit zero in working area to initialize
2879 23-070 060                    INL                    ;Advance the memory pointer
2880 23-071 011                    DCB                    ;Decrement the loop counter
2881 23-072 110 067 023            JFZ CLRNX3             ;Clear working area until loop counter is zero
2882 23-075 106 365 022            CAL GETINP             ;Fetch a character from the ASCII chax string buffer
2883 23-100 074 253                CPI 253                ;(Typically the SYMBOL/TOKEN buffer). See if it is
2884 23-102 150 115 023            JTZ NINPUT             ;Code for + sign. Jump ahead if code for + sign.
2885 23-105 074 255                CPI 255                ;See if code for minus (-) sign.
2886 23-107 110 120 023            JFZ NOTPLM             ;Jump ahead if not code for minus sign. If code for
2887 23-112 066 103                LLI 103                ;Minus sign, set pointer to MINUS flag storage location.
2888 23-114 370                    LMA                    ;Set the MINUS flag to indicate a minus number
2889 23-115 106 365 022 NINPUT:    CAL GETINP             ;Fetch another character from the ASCII char string
2890 23-120 074 256     NOTPLM:    CPI 256                ;See if character represents a period (decimal point) in
2891 23-122 150 201 023            JTZ PERIOD             ;Input string. Jump ahead if yes.
2892 23-125 074 305                CPI 305                ;If not period, see if code for E as in Exponent
2893 23-127 150 221 023            JTZ FNDEXP             ;Jump ahead if yes.
2894 23-132 074 240                CPI 240                ;Else see if code for space.
2895 23-134 150 115 023            JTZ NINPUT             ;Ignore space character, go fetch another character.
2896 23-137 240                    NDA                    ;If none of the above see if zero byte
2897 23-140 150 311 023            JTZ ENDINP             ;Indicating end of input char string. If yes, jumn ahead.
2898 23-143 074 260                CPI 260                ;If not end of string, check to see
2899 23-145 160 375 012            JTS NUMERR             ;If character represents
2900 23-150 074 272                CPI 272                ;A valid decimal number (0 to 9)
2901 23-152 120 375 012            JFS NUMERR             ;Display error message if not a valid digit at this point!
2902 23-155 066 156                LLI 156                ;For valid digit, set pointer to MSW of temporary
2903 23-157 320                    LCA                    ;Decimal to binary holding registers. Save character in C.
2904 23-160 006 370                LAI 370                ;Form mask for sizing in accumulator. Now see if
2905 23-162 247                    NDM                    ;Holding register has enough room for the conversion of
2906 23-163 110 115 023            JFZ NINPUT             ;Another digit. Ignore the input if no more room.
2907 23-166 066 105                LLI 105                ;If have room in register then set pointer to input digit
2908 23-170 317                    LBM                    ;Counter location. Fetch the present value.
2909 23-171 010                    INB                    ;Increment it to account for incoming digit.
2910 23-172 371                    LMB                    ;Restore updated count to storage location.
2911 23-173 106 056 024            CAL DECBIN             ;Call the DECimal to BINary conversion routine to add
2912 23-176 104 115 023            JMP NINPUT             ;In the new digit in holding registers. Continue inputting.
2913 23-201 310         PERIOD:    LBA                    ;Save character code in register B
2914 23-202 066 106                LLI 106                ;Set pointer to PERIOD indicator storage location
2915 23-204 307                    LAM                    ;Fetch value in PERIOD indicator
2916 23-205 240                    NDA                    ;Exercise CPU flags
2917 23-206 110 375 012            JFZ NUMERR             ;If already have a period then display error message
2918 23-211 066 105                LLI 105                ;If not, change pointer to digit counter storage location
2919 23-213 370                    LMA                    ;Clear the digit counter back to zero
2920 23-214 060                    INL                    ;Advance pointer to PERIOD indicator
2921 23-215 371                    LMB                    ;Set the PERIOD indicator
2922 23-216 104 115 023            JMP NINPUT             ;Continue processing the input character string
2923 23-221 106 365 022 FNDEXP:    CAL GETINP             ;Get next character in Exponent
2924 23-224 074 253                CPI 253                ;See if it is code for + sign
2925 23-226 150 241 023            JTZ EXPINP             ;Jump ahead if yes.
2926 23-231 074 255                CPI 255                ;If not + sign, see if minus sign
2927 23-233 110 244 023            JFZ NOEXPS             ;If not minus sign then jump ahead
2928 23-236 066 104                LLI 104                ;For minus sign, set pointer to EXP SIGN indicator
2929 23-240 370                    LMA                    ;Set the EXP SIGN indicator for a minus exponent
2930 23-241 106 365 022 EXPINP:    CAL GETINP             ;Fetch the next character in the decimal exponent
2931 23-244 240         NOEXPS:    NDA                    ;Exercise the CPU flags
2932 23-245 150 311 023            JTZ ENDINP             ;If character inputted was zero, then end of input string
2933 23-250 074 260                CPI 260                ;If not end of string, check to see
2934 23-252 160 375 012            JTS NUMERR             ;If character represents
2935 23-255 074 272                CPI 272                ;A valid decimal number (0 to 9)
2936 23-257 120 375 012            JFS NUMERR             ;Display error message if not a valid digit at this point!
2937 23-262 044 017                NDI 017                ;Else trim the ASCII code to BCD
2938 23-264 310                    LBA                    ;And save in register B
2939 23-265 066 157                LLI 157                ;Set pointer to input exponent storage location
2940 23-267 006 003                LAI 003                ;Set accumulator equal to three
2941 23-271 277                    CPM                    ;See if any previous digit in exponent greater than three
2942 23-272 160 375 012            JTS NUMERR             ;Display error message if yes
2943 23-275 327                    LCM                    ;Else save any previous value in register C
2944 23-276 307                    LAM                    ;And also place any previous value in accumulator
2945 23-277 240                    NDA                    ;Clear the carry bit with this instruction
2946 23-300 022                    RAL                    ;Single precision multiply by ten algorithm
2947 23-301 022                    RAL                    ;Two rotate lefts equals times four
2948 23-302 202                    ADC                    ;Adding in the digit makes total times five
2949 23-303 022                    RAL                    ;Rotating left again equals times ten
2950 23-304 201                    ADB                    ;now add in digit just inputted
2951 23-305 370                    LMA                    ;Restore the value to exponent storage location
2952 23-306 104 241 023            JMP EXPINP             ;Go get any additional exponent int)ut
2953 23-311 066 103     ENDINP:    LLI 103                ;Set pointer to mantissa SIGN indicator
2954 23-313 307                    LAM                    ;Fetch the SIGN indicator to the acclimulator
2955 23-314 240                    NDA                    ;Exercise the CPU flags
2956 23-315 150 327 023            JTZ FININP             ;If SIGN indicator is zero, go finish up as nr is positive
2957 23-320 066 154                LLI 154                ;But, if indicator is non-zero, number is negative
2958 23-322 016 003                LBI 003                ;Set pntr to LSW of storage registers, set precision entr
2959 23-324 106 150 022            CAL COMPLM             ;Negate the triple-precision number in holding registers
2960 23-327 066 153     FININP:    LLI 153                ;Set pointer to input storage LS~V minus one
2961 23-331 250                    XRA                    ;Clear the accumulator
2962 23-332 370                    LMA                    ;Clear the LSW minus one location
2963 23-333 335                    LDH                    ;Set register D to floating point working page
2964 23-334 046 123                LEI 123                ;Set E to address of FPACC LSW minus one
2965 23-336 016 004                LBI 004                ;Set precision counter
2966 23-340 106 013 021            CAL MOVEIT             ;Move number from input register to FPACC
2967 23-343 106 064 020            CAL FPFLT              ;Now convert the binary fixed point to floating point
2968 23-346 066 104                LLI 104                ;Set pointer to Exponent SIGN indicator location
2969 23-350 307                    LAM                    ;Fetch the value of the EXP SIGN indicator
2970 23-351 240                    NDA                    ;Exercise the CPU flags
2971 23-352 066 157                LLI 157                ;Reset pointer to input exponent storage location
2972 23-354 150 365 023            JTZ POSEXP             ;If EXP SIGN indicator zero, exponent is positive
2973 23-357 307                    LAM                    ;Else, exponent is negative so must negate
2974 23-360 054 377                XRI 377                ;The value in the input exponent storage location
2975 23-362 004 001                ADI 001                ;By performing this two's complement
2976 23-364 370                    LMA                    ;Restore the negated value to exponent storage location
2977 23-365 066 106     POSEXP:    LLI 106                ;Set pointer to PERIOD indicator storage location
2978 23-367 307                    LAM                    ;Fetch the contents of the PERIOD indicator
2979 23-370 240                    NDA                    ;Exercise the CPU flags
2980 23-371 150 000 024            JTZ EXPOK              ;If PERIOD indicator clear, no decimal point involved
2981 23-374 066 105                LLI 105                ;If have a decimal point, set pointer to digit counter
2982 23-376 250                    XRA                    ;Storage location. Clear the accumulator.
2983 23-377 227                    SUM                    ;And get a negated value of the digit counter in ACC
2984 24-000 066 157     EXPOK:     LLI 157                ;Change pointer to input exponent storage location
2985 24-002 207                    ADM                    ;Add this value to negated digit counter value
2986 24-003 370                    LMA                    ;Restore new value to storage location
2987 24-004 160 033 024            JTS MINEXP             ;If new value is minus, skip over next subroutine
2988 24-007 053                    RTZ                    ;If new value is zero, no further processing required
2989                    
2990                                                      ;Following subroutine will multiply the floating point
2991                                                      ;binary number stored in FPACC by ten tirnes the
2992                                                      ;value stored in the deciinal exponent storage location.
2993                    
2994 24-010 066 210     FPX10:     LLI 210                ;Set pointer to registers containing floating point
2995 24-012 056 001                LHI \HB\OLDPG1         ;** Binary representation of 10 (decimal).
2996 24-014 106 277 022            CAL FACXOP             ;Transfer FPACC to FPOP and 10 (dec) to FPACC
2997 24-017 106 046 021            CAL FPMULT             ;Multiply FPOP (formerly FPACC) by 10 (decimal)
2998 24-022 066 157                LLI 157                ;Set pointer to decimal exponent storage location
2999 24-024 327                    LCM                    ;Fetch the exponent value
3000 24-025 021                    DCC                    ;Decrement
3001 24-026 372                    LMC                    ;Restore to storage
3002 24-027 110 010 024            JFZ FPX10              ;If exponent value is not zero, continue multiplication
3003 24-032 007                    RET                    ;When exponent is zero can exit. Conversion completed.
3004                    
3005                                                      ;Following subroutine will multiply the floating point
3006                                                      ;binary number stored in PPACC by 0.1 times the value
3007                                                      ;(negative) stored in the decimal exponent storage location
3008                    
3009                    MINEXP:
3010 24-033 066 214     FPD10:     LLI 214                ;Set pointer to registers containing floating point
3011 24-035 056 001                LHI \HB\OLDPG1         ;** Binary representation of 0.1 (decimal).
3012 24-037 106 277 022            CAL FACXOP             ;Transfer FPACC to FPOP and 0.1 (dec) to FPACC
3013 24-042 106 046 021            CAL FPMULT             ;Multitply FPOP (formerly FPACC) by 0.1 (decimal)
3014 24-045 066 157                LLI 157                ;Set pointer to decimal exponent storage location
3015 24-047 317                    LBM                    ;Fetch the exponent value
3016 24-050 010                    INB                    ;Increment
3017 24-051 371                    LMB                    ;Restore to storage
3018 24-052 110 033 024            JFZ FPD10              ;If exponent value is not zero, continue multiplication
3019 24-055 007                    RET                    ;When exponent is zero can exit. Conversion completed.
3020                    
3021                                                      ;Following subroutine is used
3022                                                      ;to convert decimal charac-
3023                                                      ;ters to binary fixed point forinat
3024                                                      ;in a triple-precision format.
3025                    
3026 24-056 106 317 022 DECBIN:    CAL SAVEHL             ;Save entry value of D, E, H and L in memory
3027 24-061 066 153                LLI 153                ;Set pointer to temporary storage location
3028 24-063 302                    LAC                    ;Restore character inputted to accumulator
3029 24-064 044 017                NDI 017                ;Trim ASCII code to BCD
3030 24-066 370                    LMA                    ;Store temporarily
3031 24-067 046 150                LEI 150                ;Set pointer to working area LSW of multi-byte register
3032 24-071 066 154                LLI 154                ;Set another pointer to LSW of conversion register
3033 24-073 335                    LDH                    ;Make sure D set to page of working area
3034 24-074 016 003                LBI 003                ;Set precision counter
3035 24-076 106 013 021            CAL MOVEIT             ;Move original value of conversion register to working
3036 24-101 066 154                LLI 154                ;Register. Reset pointer to LSW of conversion register.
3037 24-103 016 003                LBI 003                ;Set precision counter
3038 24-105 106 177 022            CAL ROTATL             ;Rotate register left, (Multiplies value by two.)
3039 24-110 066 154                LLI 154                ;Reset pointer to LSW.
3040 24-112 016 003                LBI 003                ;Set precision counter
3041 24-114 106 177 022            CAL ROTATL             ;Multiply by two again (total now times four).
3042 24-117 046 154                LEI 154                ;Set pointer to LSW of conversion register.
3043 24-121 066 150                LLI 150                ;Set pointer to LSW of working register (original value).
3044 24-123 016 003                LBI 003                ;Set precision counter.
3045 24-125 106 127 022            CAL ADDER              ;Add original value to rotated value (now times five).
3046 24-130 066 154                LLI 154                ;Reset pointer to LSW
3047 24-132 016 003                LBI 003                ;Set precision counter
3048 24-134 106 177 022            CAL ROTATL             ;Multiply by two once more (total now times ten).
3049 24-137 066 152                LLI 152                ;Set pointer to clear working register locatiotis
3050 24-141 250                    XRA                    ;Clear the accumulator
3051 24-142 370                    LMA                    ;Clear MSW of working register
3052 24-143 061                    DCL                    ;Decrement pointer
3053 24-144 370                    LMA                    ;Clear next byte
3054 24-145 066 153                LLI 153                ;Set pointer to current digit storage location
3055 24-147 307                    LAM                    ;Fetch the current digit
3056 24-150 066 150                LLI 150                ;Change pointer to LSW of working register
3057 24-152 370                    LMA                    ;Deposit the current digit in LSW of working register
3058 24-153 046 154                LEI 154                ;Set pointer to conversion register LSW
3059 24-155 016 003                LBI 003                ;Set precision counter
3060 24-157 106 127 022            CAL ADDER              ;Add current digit to conversion register to complete
3061 24-162 104 337 022            JMP RESTHL             ;Conversion. Exit to caller by restoring CPU registers.
3062 24-165 056 001     FPOUT:     LHI \HB\OLDPG1         ;** Set H to working area for floating point routines
3063 24-167 066 157                LLI 157                ;Set pointer to decimal exponent storage location
3064 24-171 076 000                LMI 000                ;Initialize storage location to zero
3065 24-173 066 126                LLI 126                ;Change pointer to FPACC (number to be outputted)
3066 24-175 307                    LAM                    ;And fetch MSW of FPACC
3067 24-176 240                    NDA                    ;Test the contents of MSW of FPACC
3068 24-177 160 207 024            JTS OUTNEG             ;If most significant bit of MSW is a one, have a minus nr.
3069 24-202 006 240                LAI 240                ;Else number is positive, set ASCII code for space for a
3070 24-204 104 220 024            JMP AHEAD1             ;Positive number and go display a space
3071 24-207 066 124     OUTNEG:    LLI 124                ;If number in FPACC is negative must negate in order
3072 24-211 016 003                LBI 003                ;To display. Set pntr to LSW of FPACC & set prec. cntr.
3073 24-213 106 150 022            CAL COMPLM             ;Negate the number in the FPACC to make it positive
3074 24-216 006 255                LAI 255                ;But load ACC with ASCII code for minus sign
3075 24-220 106 202 003 AHEAD1:    CAL ECHO               ;Call user display driver to output space or minus sign
3076 24-223 066 110                LLI 110                ;Set pointer to FIXED/FLOAT indicator
3077 24-225 307                    LAM                    ;Fetch value of FIXED/FLOAT indicator
3078 24-226 240                    NDA                    ;Test contents of indicator. If contents are zero, calling
3079 24-227 150 253 024            JTZ OUTFLT             ;Routine has directed floating point output format.
3080 24-232 066 127                LLI 127                ;If indicator non-zero, fixed point fonnat requested if
3081 24-234 006 027                LAI 027                ;Possible. Point to FPACC Exponent. Put 23 decimal in
3082 24-236 317                    LBM                    ;Accumulator. Fetch FPACC Exponent into register B
3083 24-237 010                    INB                    ;And exercise the register to test its
3084 24-240 011                    DCB                    ;Original contents. If FPACC Exponent is negative in
3085 24-241 160 253 024            JTS OUTFLT             ;Value then go to floating point output forrnat. If value
3086 24-244 221                    SUB                    ;Is positive, subtract value from 23 (decimal). If result
3087 24-245 160 253 024            JTS OUTFLT             ;Negative, number is too big to use fixed format.
3088 24-250 104 271 024            JMP OUTFIX             ;Else, can use fixed format so skip next routine
3089 24-253 066 110     OUTFLT:    LLI 110                ;Set pointer to FIXED/FLOAT indicator.
3090 24-255 076 000                LMI 000                ;Clear indicator to indicate floating point output format
3091 24-257 006 260                LAI 260                ;Load ASCII code for '0' into accumulator
3092 24-261 106 202 003            CAL ECHO               ;Call user display driver to output '0' as first character
3093 24-264 006 256                LAI 256                ;Number string. Now load ASCII code for decimal point.
3094 24-266 106 202 003            CAL ECHO               ;Call user display driver to output '.'as second character.
3095 24-271 066 127     OUTFIX:    LLI 127                ;Set pointer to FPACC Exponent
3096 24-273 006 377                LAI 377                ;Load accumulator with minus one
3097 24-275 207                    ADM                    ;Add value in FPACC Exponent
3098 24-276 370                    LMA                    ;Restore compensated exponent value
3099                    
3100                                                      ;Next portion of routine establishes the value for the
3101                                                      ;decimal exponent that will be outputted by processing
3102                                                      ;the binary exponent value in the FPACC.
3103                    
3104 24-277 120 336 024 DECEXT:    JFS DECEXD             ;If compensated exponent value is zero or positive
3105 24-302 006 004                LAI 004                ;Then go multiply FPACC by 0.1 (decimal). Else,
3106 24-304 207                    ADM                    ;Add four to the exponent value.
3107 24-305 120 360 024            JFS DECOUT             ;If exponent now zero or positive, ready to output
3108 24-310 066 210                LLI 210                ;If exponent negative, multiply FPACC by 10 (decimal)
3109 24-312 056 001                LHI \HB\OLDPG1         ;** Set pointer to registers holding 10 (dec) in binary
3110 24-314 106 277 022            CAL FACXOP             ;Floating point format. Set up for multiplication.
3111 24-317 106 046 021            CAL FPMULT             ;Perform the multiplication. Answer in FPACC.
3112 24-322 066 157                LLI 157                ;Set pointer to decimal exponent storage location.
3113 24-324 327                    LCM                    ;Each time the FPACC is multiplied by ten, need to
3114 24-325 021                    DCC                    ;Decrement the value in the decinial exponent storage
3115 24-326 372                    LMC                    ;Location. (This establishes decimal exponent value!)
3116 24-327 066 127     DECREP:    LLI 127                ;Reset pointer to FPACC Exponent
3117 24-331 307                    LAM                    ;Fetch value in exponent
3118 24-332 240                    NDA                    ;Test value
3119 24-333 104 277 024            JMP DECEXT             ;Repeat process as required
3120 24-336 066 214     DECEXD:    LLI 214                ;If exponent is positive, multiply FPACC by 0.1
3121 24-340 056 001                LHI \HB\OLDPG1         ;** Set pointer to registers holding 0.1 dec in binary
3122 24-342 106 277 022            CAL FACXOP             ;Floating point format. Set up for multipli(-ation.
3123 24-345 106 046 021            CAL FPMULT             ;Perform the multiplication. Answer in FPACC.
3124 24-350 066 157                LLI 157                ;Set pointer to decimal exponent storage location.
3125 24-352 317                    LBM                    ;Each time the FPACC is multiplied by one tenth, need
3126 24-353 010                    INB                    ;To increment the value in the decimal exponent storage
3127 24-354 371                    LMB                    ;Location. (This establishes decimal exponent value!)
3128 24-355 104 327 024            JMP DECREP             ;Repeat process as required
3129                    
3130                                                      ;The next section outputs the mantissa
3131                                                      ;(or fixed point number) by converting the value remaining
3132                                                      ;in the FPACC (after the decimal exponent equivalent has
3133                                                      ;been extracted from the original value if required by the
3134                                                      ;previous routines) to a string of decirnal digits.
3135 24-360 046 164     DECOUT:    LEI 164                ;Set pointer to LSW of output working register
3136 24-362 335                    LDH                    ;Set D to same page value as H
3137 24-363 066 124                LLI 124                ;Set pointer to LSW of FPACC
3138 24-365 016 003                LBI 003                ;Set precision counter
3139 24-367 106 013 021            CAL MOVEIT             ;Move value in FPACC to output working register
3140 24-372 066 167                LLI 167                ;Set pointer to MSW plus one of output working register
3141 24-374 076 000                LMI 000                ;Clear that location to 0
3142 24-376 066 164                LLI 164                ;Set pointer to LSW of output working register
3143 25-000 016 003                LBI 003                ;Set precision counter
3144 25-002 106 177 022            CAL ROTATL             ;Rotate register left once to compensate for sign bit
3145 25-005 106 223 025            CAL OUTX10             ;Multiply output register by 10, overflow into N4SW+ 1
3146 25-010 066 127     COMPEN:    LLI 127                ;Set pointer back to FPACC Exponent
3147 25-012 317                    LBM                    ;Compensate for any remainder in the binary exponent
3148 25-013 010                    INB                    ;By performing a rotate right on the output working
3149 25-014 371                    LMB                    ;Register until the binary exponent becomes zero
3150 25-015 150 032 025            JTZ OUTDIG             ;Go output decimal digits when this loop is finished
3151 25-020 066 167                LLI 167                ;Binary exponent compensating loop. Setpointe'r to
3152 25-022 016 004                LBI 004                ;Working register MSW+L. Set precision counter.
3153 25-024 106 211 022            CAL ROTATR             ;Rotate working register to the right.
3154 25-027 104 010 025            JMP COMPEN             ;Repeat loop as required.
3155 25-032 066 107     OUTDIG:    LLI 107                ;Set pointer to output digit counter storage location
3156 25-034 076 007                LMI 007                ;Initialize to value of seven
3157 25-036 066 167                LLI 167                ;Change pointer to output working register MSW+L
3158 25-040 307                    LAM                    ;Fetch MSW+L byte containing BCD of digit to be
3159 25-041 240                    NDA                    ;Displayed. Test the contents of this byte.
3160 25-042 150 165 025            JTZ ZERODG             ;If zero jump to ZERODG routine.
3161 25-045 066 167     OUTDGS:    LLI 167                ;Reset pointer to working register MSW+L
3162 25-047 307                    LAM                    ;Fetch BCD of digit to be outputted
3163 25-050 240                    NDA                    ;Exercise CPU flags
3164 25-051 110 105 025            JFZ OUTDGX             ;If not zero, go display the digit
3165 25-054 066 110                LLI 110                ;If zero, change pointer to FIXED/FLOAT indicator
3166 25-056 307                    LAM                    ;Fetch the indicator into the accumulator
3167 25-057 240                    NDA                    ;Test value of indicator
3168 25-060 150 104 025            JTZ OUTZER             ;If in floating point mode, go display the digit
3169 25-063 066 157                LLI 157                ;Else change pointer to decimal exponent storage
3170 25-065 327                    LCM                    ;Location, which, for fixed point, will have a positive
3171 25-066 021                    DCC                    ;Value for all digits before the decimal point. Decrement
3172 25-067 020                    INC                    ;And increment to exercise flags. See if count is positive.
3173 25-070 120 104 025            JFS OUTZER             ;If positive, must display any zero digit.
3174 25-073 066 166                LLI 166                ;If not, change pointer to MSW of working register
3175 25-075 307                    LAM                    ;And test to see if any significant digits coming up
3176 25-076 044 340                NDI 340                ;By forming a mask and testing for presence of bits
3177 25-100 110 104 025            JFZ OUTZER             ;If more significant digits coming up soon, display the
3178 25-103 007                    RET                    ;Zero digit. Else, exit to calling routine. Finished.
3179 25-104 250         OUTZER:    XRA                    ;Clear the accumulator to restore zero digit value
3180 25-105 004 260     OUTDGX:    ADI 260                ;Add 260 (octal) to BCD code in ACC to form ASCII
3181 25-107 106 202 003            CAL ECHO               ;Code and call the user's display driver subroutine
3182 25-112 066 110     DECRDG:    LLI 110                ;Set pointer to FIXED/FLOAT indicator storage
3183 25-114 307                    LAM                    ;Fetch the indicator to the accumulator
3184 25-115 240                    NDA                    ;Exercise the CPU flags
3185 25-116 110 137 025            JFZ CKDECP             ;If indicator non-zero, doing fixed point output
3186 25-121 066 107                LLI 107                ;Else, get output digit counter
3187 25-123 327                    LCM
3188 25-124 021                    DCC                    ;Decrement the digit counter & restore to storage
3189 25-125 372                    LMC
3190 25-126 150 300 025            JTZ EXPOUT             ;When digit counter is zero, go take care of exponent
3191 25-131 106 223 025 PUSHIT:    CAL OUTX10             ;Else push next BCD digit out of working register
3192 25-134 104 045 025            JMP OUTDGS             ;And continue the outputting process
3193 25-137 066 157     CKDECP:    LLI 157                ;For fixed point output, decimal exponent serves as
3194 25-141 327                    LCM                    ;Counter for number of digits before decimal point
3195 25-142 021                    DCC                    ;Fetch the counter and decrement it to account for
3196 25-143 372                    LMC                    ;Current digit being processed. Restore to storage.
3197 25-144 110 154 025            JFZ NODECP             ;If count does not go to zero, jump ahead.
3198 25-147 006 256                LAI 256                ;When count reaches zero, load ASCII code for period
3199 25-151 106 202 003            CAL ECHO               ;And call user's display driver to display decimal point
3200 25-154 066 107     NODECP:    LLI 107                ;Set pointer to output digit counter storage location
3201 25-156 327                    LCM                    ;Fetch the digit counter
3202 25-157 021                    DCC                    ;Decrement the value
3203 25-160 372                    LMC                    ;Restore to storage
3204 25-161 053                    RTZ                    ;If counter reaches zero, exit to caller. Finished.
3205 25-162 104 131 025            JMP PUSHIT             ;Else continue to output the number.
3206 25-165 066 157     ZERODG:    LLI 157                ;If first digit of floating point number is a zero, set
3207 25-167 327                    LCM                    ;Pointer to decimal exponent storage location.
3208 25-170 021                    DCC                    ;Decrement the value to compensate for skipping
3209 25-171 372                    LMC                    ;Display of first digit. Restore to storage.
3210 25-172 066 166                LLI 166                ;Change pointer to MSW of output working register
3211 25-174 307                    LAM                    ;Fetch MSW of output working register
3212 25-175 240                    NDA                    ;Test the contents
3213 25-176 110 112 025            JFZ DECRDG             ;If non-zero, continue outputting
3214 25-201 061                    DCL                    ;Else decrement pointer to next byte in working register
3215 25-202 307                    LAM                    ;Fetch its contents
3216 25-203 240                    NDA                    ;Test
3217 25-204 110 112 025            JFZ DECRDG             ;If non-zero, continue outputting
3218 25-207 061                    DCL                    ;Else decrement pointer to LSW of working register
3219 25-210 307                    LAM                    ;Fetch its contents
3220 25-211 240                    NDA                    ;Test
3221 25-212 110 112 025            JFZ DECRDG             ;If non-zero, continue outputting
3222 25-215 066 157                LLI 157                ;If decimal mantissa is zero, set pointer to decirnal
3223 25-217 370                    LMA                    ;Exponent storage and clear it
3224 25-220 104 112 025            JMP DECRDG             ;Finish outputting
3225                    
3226                                                      ;Following routine multiplies the binary number in the
3227                                                      ;output working register by ten to push the most signifi-
3228                                                      ;cant digit out to the MSW+L byte.
3229                    
3230 25-223 066 167     OUTX10:    LLI 167                ;Set pointer to work ing register M SW+ 1
3231 25-225 076 000                LMI 000                ;Clear it in preparation for receiving next digit pushed
3232 25-227 066 164                LLI 164                ;Into it. Change pointer to working register LSW.
3233 25-231 335                    LDH                    ;Set up register D to same page as H.
3234 25-232 046 160                LEI 160                ;Set second pointer to LSW of second working register
3235 25-234 016 004                LBI 004                ;Set precision counter
3236 25-236 106 013 021            CAL MOVEIT             ;Move first working register into second
3237 25-241 066 164                LLI 164                ;Reset pointer to LSW of first working register
3238 25-243 016 004                LBI 004                ;Set precision counter
3239 25-245 106 177 022            CAL ROTATL             ;Rotate contents of first working register left (X 2)
3240 25-250 066 164                LLI 164                ;Reset pointer to LSW
3241 25-252 016 004                LBI 004                ;Reset precision counter
3242 25-254 106 177 022            CAL ROTATL             ;Rotate contents left again (X 4)
3243 25-257 066 160                LLI 160                ;Set pointer to LSW of original value in 2'nd register
3244 25-261 046 164                LEI 164                ;Set pointer to LSW of rotated value
3245 25-263 016 004                LBI 004                ;Set precision counter
3246 25-265 106 127 022            CAL ADDER              ;Add rotated value to original value (X 5)
3247 25-270 066 164                LLI 164                ;Reset pointer to LSW of first working register
3248 25-272 016 004                LBI 004                ;Set precision counter
3249 25-274 106 177 022            CAL ROTATL             ;Rotate contents left again (X 10)
3250 25-277 007                    RET                    ;Exit to calling routine
3251                    
3252                                                      ;The final group of routines in the floating point output
3253                                                      ;section take care of outputting the decimal exponent
3254                                                      ;portion of floating point numbers.
3255                    
3256 25-300 066 157     EXPOUT:    LLI 157                ;Set pointer to decimal exponent storage location
3257 25-302 307                    LAM                    ;Fetch value to the accumulator
3258 25-303 240                    NDA                    ;Test the value
3259 25-304 053                    RTZ                    ;If zero, then no exponent portion. Exit to caller.
3260 25-305 006 305                LAI 305                ;Else, load ACC with ASCII code for letter E.
3261 25-307 106 202 003            CAL ECHO               ;Display E for Exponent via user's display driver rtn
3262 25-312 307                    LAM                    ;Get decimal exponent value back into ACC
3263 25-313 240                    NDA                    ;Test again
3264 25-314 160 324 025            JTS EXOUTN             ;If value is negative, skip ahead
3265 25-317 006 253                LAI 253                ;If positive, load ASCII code for + sign
3266 25-321 104 333 025            JMP AHEAD2             ;Jump to display the + sign
3267 25-324 054 377     EXOUTN:    XRI 377                ;When decimal exponent is negative, must negate
3268 25-326 004 001                ADI 001                ;Value for display purposes. Perform two's complement
3269 25-330 370                    LMA                    ;And restore the negated value to storage location
3270 25-331 006 255                LAI 255                ;Load ASCII code for minus sign
3271 25-333 106 202 003 AHEAD2:    CAL ECHO               ;Display the ASCII character in ACC
3272 25-336 016 000                LBI 000                ;Clear register B
3273 25-340 307                    LAM                    ;Fetch the decimal exponent value back into ACC
3274 25-341 024 012     SUB12:     SUI 012                ;Subtract 10 (decimal) from value in ACC
3275 25-343 160 353 025            JTS TOMUCH             ;Break out of loop when accumulator goes negative
3276 25-346 370                    LMA                    ;Else restore value to storage location
3277 25-347 010                    INB                    ;Increment register B as a counter
3278 25-350 104 341 025            JMP SUB12              ;Repeat loop to form tens value of decimal exponent
3279 25-353 006 260     TOMUCH:    LAI 260                ;Load base ASCII value for digit into the accumulator
3280 25-355 201                    ADB                    ;Add to the count in B to forin tens digit of decimal
3281 25-356 106 202 003            CAL ECHO               ;Exponent. Display via user's driver subroutine
3282 25-361 307                    LAM                    ;Fetch remainder of decimal exponent value
3283 25-362 004 260                ADI 260                ;Add in ASCII base value to form final digit
3284 25-364 106 202 003            CAL ECHO               ;Display second digit of decirnal exponent
3285 25-367 007                    RET                    ;Finished outputting. Return to caller.
3286                    ;;; The above RETURN SHOULD BE AT 25 367
3287                    
3288                    ;;; NOW OPEN AREA UP TO 26 000 CAN BE USED FOR PATCHING...
3289                    
3290                    	ORG 026#000
3291 26-000 000          	DATA 000		; CC FOR INPUT LINE BUFFER
3292 26-001             	DATA *79 		; THE INPUT LINE BUFFER
3293 26-120 000 000 000  	DATA 000,000,000,000	; THESE ARE SYMBOL BUFFER STORAGE
     26-123 000 
3294 26-124 000 000 000  	DATA 000,000,000,000
     26-127 000 
3295 26-130 000 000 000  	DATA 000,000,000,000	; SHOULD BE 26-120 TO 26 143
     26-133 000 
3296 26-134 000 000 000  	DATA 000,000,000,000
     26-137 000 
3297 26-140 000 000 000  	DATA 000,000,000,000
     26-143 000 
3298 26-144 000 000 000  	DATA 000,000,000,000	; THESE LOCATIONS ARE AUXILIARY SYMBOL BUFFER
     26-147 000 
3299 26-150 000 000 000  	DATA 000,000,000,000
     26-153 000 
3300 26-154 000 000 000  	DATA 000,000,000,000	; SHOULD BE 26 144 TO 26 175
     26-157 000 
3301 26-160 000 000 000  	DATA 000,000,000,000
     26-163 000 
3302 26-164 000 000 000  	DATA 000,000,000,000
     26-167 000 
3303 26-170 000 000 000  	DATA 000,000,000,000
     26-173 000 
3304 26-174 000 000      	DATA 000,000
3305 26-176 000          	DATA 000		; TEMP SCAN STORAGE REGISTER
3306 26-177 000          	DATA 000		; TAB FLAG
3307 26-200 000          	DATA 000		; EVAL CURRENT TEMP REG.
3308 26-201 000          	DATA 000		; SYNTAX LINE NUMBER
3309 26-202 000          	DATA 000		; SCAN TEMPORARY REGISTER
3310 26-203 000          	DATA 000		; STATEMENT TOKEN
3311 26-204 000 000      	DATA 000,000		; TEMPORARY WORKING REGISTERS
3312 26-206 000 000      	DATA 000,000		; ARRAY POINTERS
3313                    ;;; NOW WE SHOULD BE UP TO 26 210
3314 26-210 000          	DATA 000		; OPERATOR STACK POINTER
3315 26-211             	DATA *15		; OPERATOR STACK
3316 26-230 000          	DATA 000		; FUN/ARRAY STACK POINTER
3317 26-231             	DATA *7			; FUNCTION/ARRAY STACK
3318                    ;;; THE LAST BYTE SHOULD HAVE BEEN 26 237
3319                    
3320                    
3321                    	;; HEIRARCHY TABLE (FOR OUT OF STACK OPS)
3322                    	;; USED BY PARSER ROUTINE.
3323                    ;;; This SHOULD START AT 26 240
3324 26-240 000          	DATA 000		; EOS
3325 26-241 003          	DATA 003		; PLUS SIGN
3326 26-242 003          	DATA 003		; MINUS SIGN
3327 26-243 004          	DATA 004		; MULTIPLICATION SIGN
3328 26-244 004          	DATA 004		; DIVISION SIGN
3329 26-245 005          	DATA 005		; EXPONENT SIGN
3330 26-246 006          	DATA 006		; LEFT PARENTHESIS
3331 26-247 001          	DATA 001		; RIGHT PARENTHESIS
3332 26-250 002          	DATA 002		; NOT ASSIGNED
3333 26-251 002          	DATA 002		; LESS THAN SIGN
3334 26-252 002          	DATA 002		; Equal sign
3335 26-253 002          	DATA 002		; GREATER THAN SIGN
3336 26-254 002          	DATA 002		; LESS THAN OR EQUAL COMBO
3337 26-255 002          	DATA 002		; EQUAL OR GREATER THAN
3338 26-256 002          	DATA 002		; LESS THAN OR GREATER THAN
3339                    
3340                    	;; HEIRARCHY TABLE (FOR INTO STACK OPS)
3341                    	;; USED BY PARSER ROUTINE.
3342                    ;;; This SHOULD START AT 26 257
3343 26-257 000          	DATA 000		; EOS
3344 26-260 003          	DATA 003		; PLUS SIGN
3345 26-261 003          	DATA 003		; MINUS SIGN
3346 26-262 004          	DATA 004		; MULTIPLICATION SIGN
3347 26-263 004          	DATA 004		; DIVISION SIGN
3348 26-264 005          	DATA 005		; EXPONENTIATION SIGN
3349 26-265 001          	DATA 001		; LEFT PARENTHESIS
3350 26-266 001          	DATA 001		; RIGHT PARENTHESIS
3351 26-267 002          	DATA 002		; NOT ASSIGNED
3352 26-270 002          	DATA 002		; LESS THAN SIGN
3353 26-271 002          	DATA 002		; EQUAL SIGN
3354 26-272 002          	DATA 002		; GREATER THAN SIGN
3355 26-273 002          	DATA 002		; LESS THAN OR EQUAL SIGN
3356 26-274 002          	DATA 002		; EQUAL TO OR GREATER THAN
3357 26-275 002          	DATA 002		; LESS THAN OR GREATER THAN
3358                    
3359 26-276 000          	DATA 000		; EVAL START POINTER
3360 26-277 000          	DATA 000		; EVAL FINISH POINTER
3361                    
3362                    	;; FUNCTION NAMES TABLE
3363                    ;;; This SHOULD START AT 26 300
3364 26-300 003          	DATA 3
3365 26-301 311 316 324  	DATA "INT"
3366 26-304 003          	DATA 3
3367 26-305 323 307 316  	DATA "SGN"
3368 26-310 003          	DATA 3
3369 26-311 301 302 323  	DATA "ABS"
3370 26-314 003          	DATA 3
3371 26-315 323 321 322  	DATA "SQR"
3372 26-320 003          	DATA 3
3373 26-321 324 301 302  	DATA "TAB"
3374 26-324 003          	DATA 3
3375 26-325 322 316 304  	DATA "RND"
3376 26-330 003          	DATA 3
3377 26-331 303 310 322  	DATA "CHR"
3378 26-334 003          	DATA 3
3379 26-335 325 304 306  	DATA "UDF"
3380                    
3381 26-340 000 000 000  	DATA 000,000,000,000	; LINE NUMBER BUFFER STORAGE
     26-343 000 
3382 26-344 000 000 000  	DATA 000,000,000,000	; (SHOULD BE 340-347)
     26-347 000 
3383 26-350 000 000 000  	DATA 000,000,000,000	; AUX LINE NUMBER BUFFER
     26-353 000 
3384 26-354 000 000 000  	DATA 000,000,000,000	; (SHOULD BE 350-357)
     26-357 000 
3385                    ;;; The following data is a change in page 3 of Scelbal update issue 4
3386                    ;;; which apparently makes the "INSERT" command work correctly, the
3387                    ;;; first time (later SCR commands load 33 into this spot) 
3388 26-360 033          	DATA 033 		; USER PGM LINE PTR (PG)
3389 26-361 000          	DATA 000 		; USER PGM LINE PTR (LOW)
3390 26-362 000          	DATA 000 		; AUX PGM LINE PTR (PG)
3391 26-363 000          	DATA 000 		; AUX PGM LINE PTR (LOW)
3392 26-364 000          	DATA 000 		; END OF USER PGM BUFFER PTR (PG)
3393 26-365 000          	DATA 000 		; END OF USER PGM BUFFER PTR (LOW)
3394 26-366 000          	DATA 000		; PARENTHESIS COUNTER (366)
3395 26-367 000          	DATA 000		; QUOTE INDICATOR
3396 26-370 000          	DATA 000		; TABLE COUNTER (370)
3397                    ;;; locations 371-377 NOT ASSIGNED
3398                    
3399                    	ORG 027#000
3400 27-000 003          	DATA 3
3401 27-001 322 305 315  	DATA "REM"
3402 27-004 002          	DATA 2
3403 27-005 311 306      	DATA "IF"
3404 27-007 003          	DATA 3    ;MGA 3/31/12 Loboyko transcription error
3405 27-010 314 305 324  	DATA "LET"
3406 27-013 004          	DATA 4
3407 27-014 307 317 324  	DATA "GOTO"
     27-017 317 
3408 27-020 005          	DATA 5
3409 27-021 320 322 311  	DATA "PRINT"
     27-024 316 324 
3410 27-026 005          	DATA 5
3411 27-027 311 316 320  	DATA "INPUT"
     27-032 325 324 
3412 27-034 003          	DATA 3
3413 27-035 306 317 322  	DATA "FOR"
3414 27-040 004          	DATA 4
3415 27-041 316 305 330  	DATA "NEXT"
     27-044 324 
3416 27-045 005          	DATA 5
3417 27-046 307 317 323  	DATA "GOSUB"
     27-051 325 302 
3418 27-053 006          	DATA 6    ;MGA 4/12/12 another Loboyko transcription error
3419 27-054 322 305 324  	DATA "RETURN"
     27-057 325 322 316
3420 27-062 003          	DATA 3
3421 27-063 304 311 315  	DATA "DIM"
3422 27-066 003          	DATA 3
3423 27-067 305 316 304  	DATA "END"
3424 27-072 000          	DATA 0			; END OF TABLE, SHOULD BE 072
3425                    
3426 27-073 000          	DATA 000		; GOSUB STACK POINTER
3427 27-074             	DATA *1			; NOT ASSIGNED;
3428 27-075 000          	DATA 000		; NUMBER OF ARRAYS COUNTER
3429 27-076 000          	DATA 000		; ARRAY POINTER
3430 27-077 000          	DATA 000		; VARIABLES COUNTER SHOULD BE 077
3431 27-100 000 000 000  	DATA 000,000,000,000	; USED AS THE GOSUB STACK 100-117
     27-103 000 
3432 27-104 000 000 000  	DATA 000,000,000,000
     27-107 000 
3433 27-110 000 000 000  	DATA 000,000,000,000
     27-113 000 
3434 27-114 000 000 000  	DATA 000,000,000,000
     27-117 000 
3435 27-120 000 000 000  	DATA 000,000,000,000	; USED AS ARRAY VARIABLES TABLE
     27-123 000 
3436 27-124 000 000 000  	DATA 000,000,000,000	; SHOULD BE 120-137
     27-127 000 
3437 27-130 000 000 000  	DATA 000,000,000,000
     27-133 000 
3438 27-134 000 000 000  	DATA 000,000,000,000
     27-137 000 
3439                    
3440 27-140 000 000 000  	DATA 000,000,000,000	; USED FOR FOR/NEXT STACK STORAGE
     27-143 000 
3441 27-144 000 000 000  	DATA 000,000,000,000	; SHOULD BE 140 TO 177
     27-147 000 
3442 27-150 000 000 000  	DATA 000,000,000,000
     27-153 000 
3443 27-154 000 000 000  	DATA 000,000,000,000
     27-157 000 
3444 27-160 000 000 000  	DATA 000,000,000,000
     27-163 000 
3445 27-164 000 000 000  	DATA 000,000,000,000
     27-167 000 
3446 27-170 000 000 000  	DATA 000,000,000,000
     27-173 000 
3447 27-174 000 000 000  	DATA 000,000,000,000
     27-177 000 
3448 27-200 000          	DATA 000		; FOR/NEXT STACK POINTER
3449 27-201 000          	DATA 000		; ARRAY/VARIABLE FLAG
3450 27-202 000          	DATA 000  		; STOSYM COUNTER
3451 27-203 000          	DATA 000		; FUN/ARRAY STACK POINTER (203
3452 27-204 000          	DATA 000		; ARRAY VALUES POINTER
3453 27-205             	DATA *3			; NOT USED (SHOULD BE 205-207)
3454 27-210 000          	DATA 000		; USED AS VARIABLES SYMBOL TABLE
3455 27-211             	DATA *119		; (SHOULD BE 211-377 RESERVED)
3456                    ;;; The above should cover 211 to 377
3457                    	;; THERE ARE NOW ADDRESSES AT START OF PAGE 30, NOT ASSIGNED;
3458                    
3459                    
3460                    ;;; The following is PATCH NR.1
3461                    	ORG 030#000
3462 30-000 066 123     PATCH1:	LLI 123
3463 30-002 076 000     	LMI 000
3464 30-004 066 133     	LLI 133
3465 30-006 076 000     	LMI 000
3466 30-010 007         	RET
3467                    
3468                    	
3469                    	
3470                    	ORG 030#013
3471                    	
3472 30-013 066 144     NEXT:      LLI 144                ;Load L with start of AUX SYMBOL BUFFER
3473 30-015 056 026                LHI \HB\OLDPG26        ;** Set H to page of AUX SYMBOL BUFFER
3474 30-017 076 000                LMI 000                ;Initialize AUX SYMBOL BUFFER by clearing first byte
3475 30-021 066 202                LLI 202                ;Change L to address of SCAN pointer
3476 30-023 317                    LBM                    ;Fetch pointer value to CPU register B
3477 30-024 010                    INB                    ;Add one to the current pointer value
3478 30-025 066 201                LLI 201                ;Load L with address of NEXT pointer storage location
3479 30-027 371                    LMB                    ;Place the updated SCAN pointer as the NEXT pointer
3480 30-030 066 201     NEXT1:     LLI 201                ;Reset L to address of NEXT pointer storage location
3481 30-032 106 240 002            CAL GETCHR             ;Fetch the character pointed to by the NEXT pointer
3482 30-035 150 045 030            JTZ NEXT2              ;If the character is a space, ignore it
3483 30-040 066 144                LLI 144                ;Else, load L with start of AUX SYMBOL BUFFER
3484 30-042 106 314 002            CAL CONCT1             ;Concatenate the character onto the AUX SYMBOL BF
3485 30-045 066 201     NEXT2:     LLI 201                ;Reset L to address of NEXT pointer storage location
3486 30-047 106 003 003            CAL LOOP               ;Advance the NEXT pointer and see if end of line
3487 30-052 110 030 030            JFZ NEXT1              ;Fetch next character in line if not end of line
3488 30-055 066 144                LLI 144                ;When reach end of line, should have variable name
3489 30-057 307                    LAM                    ;In the AUX SYMBOL BUFFER. Fetch the (cc) for
3490 30-060 074 001                CPI 001                ;The buffer and see if variable name is just one letter
3491 30-062 110 071 030            JFZ NEXT3              ;If more than one proceed directly to look for name
3492 30-065 066 146                LLI 146                ;In FOR/NEXT STACK. If have just a one letter name
3493 30-067 076 000                LMI 000                ;Then set second character in buffer to zero
3494 30-071 066 205     NEXT3:     LLI 205                ;Load L with address of FOR/NEXT STACK pointer
3495 30-073 056 027                LHI \HB\OLDPG27        ;** Set H to page of FOR/NEXT STACK pointer
3496 30-075 307                    LAM                    ;Fetch the FOR/NEXT STACK pointer value to ACC
3497 30-076 002                    RLC                    ;Rotate value left to multiply by two. Then rotate it
3498 30-077 002                    RLC                    ;Left again to multiply by four. Add base address plus
3499 30-100 004 136                ADI 136                ;Two to form pointer to variable name in top of stack
3500 30-102 056 027                LHI \HB\OLDPG27        ;** Set H to page of FOR/NEXT STACK
3501 30-104 360                    LLA                    ;Move pointer value from ACC to CPU register L
3502 30-105 036 026                LDI \HB\OLDPG26        ;** Set register D to page of AUX SYMBOL BUFFER
3503 30-107 046 145                LEI 145                ;Set register E to first character in the buffer
3504 30-111 016 002                LBI 002                ;Set B to serve as a character counter
3505 30-113 106 370 002            CAL STRCPC             ;See if variable name in the NEXT statement same as
3506 30-116 150 130 030            JTZ NEXT4              ;That stored in the top of the FOR/NEXT STACK
3507 30-121 006 306     FORNXT:    LAI 306                ;Load ACC with ASCII code for letter F
3508 30-123 026 316                LCI 316                ;Load register C with ASCII code for letter N
3509 30-125 104 226 002            JMP ERROR              ;Display For/Next (FN) error message if required
3510 30-130 066 360     NEXT4:     LLI 360                ;Load L with address of user program line pointer
3511 30-132 056 026                LHI \HB\OLDPG26        ;** Load H with page of user pgm line pntr storage loc.
3512 30-134 337                    LDM                    ;Fetch the page portion of the line pointer into D
3513 30-135 060                    INL                    ;Advance the memory pointer
3514 30-136 347                    LEM                    ;Fetch the low portion of the line pointer into E
3515 30-137 060                    INL                    ;Advance pntr to AUXILIARY LINE POINTER storage
3516 30-140 373                    LMD                    ;Location and store value of line pointer there too (page)
3517 30-141 060                    INL                    ;Advance pointer to second byte of AUXILIARY line
3518 30-142 374                    LME                    ;Pointer and store value of line pointer (low portion)
3519 30-143 066 205                LLI 205                ;Load L with address of FOR/NEXT STACK pointer
3520 30-145 056 027                LHI \HB\OLDPG27        ;** Set H to page of FOR/NEXT STACK pointer
3521 30-147 307                    LAM                    ;Fetch the FOR/NEXT STACK pointer value to ACC
3522 30-150 002                    RLC                    ;Rotate value left to multiply by two. Then rotate it
3523 30-151 002                    RLC                    ;Left again to multiply by four. Add base address to
3524 30-152 004 134                ADI 134                ;Form pointer to top of FOR/NEXT STACK and place
3525 30-154 360                    LLA                    ;The pointer value into CPU register L. Fetch the page
3526 30-155 337                    LDM                    ;Address of the associated FOR statement line pointer
3527 30-156 060                    INL                    ;Into register D. Advance the pointer and fetch the low
3528 30-157 347                    LEM                    ;Address value into register E. Prepare to change user
3529 30-160 066 360                LLI 360                ;Program line pointer to the FOR statement line by
3530 30-162 056 026                LHI \HB\OLDPG26        ;** Setting H & L to the user pgrn line pntr storage loc.
3531 30-164 373                    LMD                    ;Place the page value in the pointer storage location
3532 30-165 060                    INL                    ;Advance the memory pointer
3533 30-166 374                    LME                    ;Place the low value in the pointer storage location
3534 30-167 353                    LHD                    ;Now set up H and L to point to the start of the
3535 30-170 364                    LLE                    ;Associated FOR statement line in the user pgm buffer
3536 30-171 036 026                LDI \HB\OLDPG26        ;** Change D to point to the line input buffer
3537 30-173 046 000                LEI 000                ;And set L to the gtart of the line input buffer
3538 30-175 106 046 012            CAL MOVEC              ;Move the associated FOR statement line into the input
3539 30-200 066 325                LLI 325                ;Line buffer. Set L to point to start of TO string which is
3540 30-202 056 001                LHI \HB\OLDPG1         ;** Stored in a text strings storage area on this page
3541 30-204 106 012 013            CAL INSTR              ;Search the statement line for the occurrence of TO
3542 30-207 304                    LAE                    ;Register E will be zero if TO not found. Move E to ACC
3543 30-210 240                    NDA                    ;To make a test. If TO found then proceed to set up for
3544 30-211 150 121 030            JTZ FORNXT             ;Evaluation. If TO not found, then have error condition.
3545 30-214 004 002                ADI 002                ;Advance the pointer over the characters in TO string
3546 30-216 066 276                LLI 276                ;Change L to point to EVAL pointer storage location
3547 30-220 056 026                LHI \HB\OLDPG26        ;** Set H to page of EVAL pointer. Set up the starting
3548 30-222 370                    LMA                    ;Position for the EVAL subroutine (after TO string)
3549 30-223 066 330                LLI 330                ;Set L to point to start of STEP string which is stored
3550 30-225 056 001                LHI \HB\OLDPG1         ;** In text stxings storage area on this page. Search the
3551 30-227 106 012 013            CAL INSTR              ;Statement line for the occurrence of STEP
3552 30-232 304                    LAE                    ;Register E will be zero if STEP not found. Move E to
3553 30-233 240                    NDA                    ;The accumulator to make a test. If STEP found must
3554 30-234 110 300 030            JFZ NEXT5              ;Evaluate expression after STEP to get STEP SIZE.
3555 30-237 066 004                LLI 004                ;Else, have an IMPLIED STEP SIZE of 1.0. Set pointer
3556 30-241 056 001                LHI \HB\OLDPG1         ;** To start of storage area for 1.0 in floating point
3557 30-243 106 244 022            CAL FLOAD              ;Format and call subroutine to load FPACC with 1.0
3558 30-246 066 304                LLI 304                ;Set L to start of FOR/NEXT STEP SIZE storage loc.
3559 30-250 106 255 022            CAL FSTORE             ;Store the value 1.0 in the F/N STEP SIZE registers
3560 30-253 066 000                LLI 000                ;Change L to the start of the input line buffer
3561 30-255 056 026                LHI \HB\OLDPG26        ;** Set H to the page of the input line buffer
3562 30-257 317                    LBM                    ;Fetch the (cc) into CPU register B (length of FOR line)
3563 30-260 066 277                LLI 277                ;Change L to EVAL FINISH pointer stomge location
3564 30-262 371                    LMB                    ;Set the EVAL FINISH pointer to the end of the line
3565 30-263 106 224 003            CAL EVAL               ;Evaluate the LIMIT expression to obtain FOR LIMIT
3566 30-266 066 310                LLI 310                ;Load L with address of start of F/N LIMIT registers
3567 30-270 056 001                LHI \HB\OLDPG1         ;** Load H with page of FOR/NEXT LIMIT registers
3568 30-272 106 255 022            CAL FSTORE  ;MGA 3/31/12 no lab here Store the FOR/NEXT LIMIT value
3569 30-275 104 351 030            JMP NEXT6              ;Since have IMPLIED STEP jump ahead
3570 30-300 041         NEXT5:     DCE  ;MGA 3/21/12 lab here When have STEP directive, subtract one from pointer
3571 30-301 066 277                LLI 277                ;To get to character before S in STEP. Save this value in
3572 30-303 056 026                LHI \HB\OLDPG26        ;** The EVAL FINISH pointer stomge location to serve
3573 30-305 374                    LME                    ;As evaluation end location when obtaining TO Iiinit
3574 30-306 106 224 003            CAL EVAL               ;Evaluate the LIMIT expression to obtain FOR LIMIT
3575 30-311 066 310                LLI 310                ;Load L with address of start of FIN LIMIT registers
3576 30-313 056 001                LHI \HB\OLDPG1         ;** Load H with page of FORINEXT LIMIT registers
3577 30-315 106 255 022            CAL FSTORE             ;Store the FOR/NEXT LIMIT value
3578 30-320 066 277                LLI 277                ;Reset L to EVAL FINISH pointer storage location
3579 30-322 056 026                LHI \HB\OLDPG26        ;** Set H to page of EVAL FINISH pointer storage loc.
3580 30-324 307                    LAM                    ;Fetch the pointer value (character before S in STEP)
3581 30-325 004 005                ADI 005                ;Add five to change pointer to character after P in STEP
3582 30-327 061                    DCL                    ;Decrement L to point to EVAL (start) pointer
3583 30-330 370                    LMA                    ;Set up the starting position for the EVAL subroutine
3584 30-331 066 000                LLI 000                ; Load L with starting address of the line input buffer
3585 30-333 317                    LBM                    ;Fetch the (cc) for the line input buffer (line length)
3586 30-334 066 277                LLI 277                ;Change L to the EVAL FINISH storage location
3587 30-336 371                    LMB                    ;Set the EVAL FINISH pointer
3588 30-337 106 224 003            CAL EVAL               ;Evaluate the STEP SIZE expression
3589 30-342 066 304                LLI 304                ;Load L with address of start of F/N STEP registers
3590 30-344 056 001                LHI \HB\OLDPG1         ;** Set H to page of FIN STEP registers
3591 30-346 106 255 022            CAL FSTORE             ;Store the FOR/NEXT STEP SIZE value
3592 30-351 066 144     NEXT6:     LLI 144                ;Load L with address of AUX SYMBOL BUFFER
3593 30-353 056 026                LHI \HB\OLDPG26        ;** Set H to page of the AUX SYMBOL BUFFER
3594 30-355 076 000                LMI 000                ;Initialize AUX SUMBOL BUFFER with a zero byte
3595 30-357 066 034                LLI 034                ;Set L to start of FOR string which is stored in the
3596 30-361 056 027                LHI \HB\OLDPG27        ;** KEYWORD look-up table on this page
3597 30-363 106 012 013            CAL INSTR              ;Search the statement line for the FOR directive
3598 30-366 304                    LAE                    ;Register E will be zero if FOR not found. Move E to
3599 30-367 240                    NDA                    ;ACC and -make test to see if FOR directive located
3600 30-370 066 202                LLI 202                ;Load L with address of SCAN pointer
3601 30-372 056 026                LHI \HB\OLDPG26        ;** Load H with page of SCAN pointer
3602 30-374 370                    LMA                    ;Set up pointer to occurrence of FOR directive in line
3603 30-375 150 121 030            JTZ FORNXT             ;If FOR not found, have an error condition
3604 31-000 004 003                ADI 003                ;If have FOR, add three to advance pointer over FOR
3605 31-002 066 203                LLI 203                ;Set L to point to F/N pointer storage location
3606 31-004 370                    LMA                    ;Set F/N pointer to character after FOR directive
3607 31-005 066 203     NEXT7:     LLI 203                ;Set L to point to FIN pointer storage location
3608 31-007 106 240 002            CAL GETCHR             ;Fetch a character from position pointed to by FIN pntr
3609 31-012 150 027 031            JTZ NEXT8              ;If character is a space, ignore it
3610 31-015 074 275                CPI 275                ;Else, test to see if character is "=" sign
3611 31-017 150 042 031            JTZ NEXT9              ;If yes, have picked up variable name, jump ahead
3612 31-022 066 144                LLI 144                ;If not, set L to the start of the AUX SYMBOL BUFFER
3613 31-024 106 314 002            CAL CONCT1             ;And store the character in the AUX SYMBOL BUFFER
3614 31-027 066 203     NEXT8:     LLI 203                ;Load L with address of the F/N pointer
3615 31-031 106 003 003            CAL LOOP               ;Increment the pointer and see if end of the line
3616 31-034 110 005 031            JFZ NEXT7              ;If not, continue fetching characters
3617 31-037 104 121 030            JMP FORNXT             ;If end of line before "=" sign then have error condx
3618 31-042 066 202     NEXT9:     LLI 202                ;Load L with address of SCAN pointer
3619 31-044 056 026                LHI \HB\OLDPG26        ;** Load H with page of SCAN pointer
3620 31-046 307                    LAM                    ;Fetch pointer value to ACC (points to start of FOR
3621 31-047 004 003                ADI 003                ;Directive) and add three to move pointer over FOR
3622 31-051 066 276                LLI 276                ;Directive. Change L to EVAL pointer storage location
3623 31-053 370                    LMA                    ;Set EVAL pointer to character after FOR in line
3624 31-054 066 203                LLI 203                ;Load L with address of FIN pointer storage location
3625 31-056 317                    LBM                    ;Fetch pointer to register B (points to "=" sign) and
3626 31-057 011                    DCB                    ;Decrement the pointer (to character before "=" sign)
3627 31-060 066 277                LLI 277                ;Load L with address of EVAL FINISH pointer
3628 31-062 371                    LMB                    ;Set EVAL FINISH pointer
3629 31-063 106 224 003            CAL EVAL               ;Call subroutine to obtain current value of the variable
3630 31-066 066 304                LLI 304                ;Load L with address of start of F/N STEP registers
3631 31-070 056 001                LHI \HB\OLDPG1         ;** Set H to page of F/N STEP registers
3632 31-072 106 277 022            CAL FACXOP             ;Call subroutine to set up FP registers for addition
3633 31-075 106 211 020            CAL FPADD              ;Add FIN STEP size to current VARIABLE value
3634 31-100 066 314                LLI 314                ;Load L with address of FIN TEMP storage registers
3635 31-102 056 001                LHI \HB\OLDPG1         ;**Set H to page of FIN TEMP storage registers
3636 31-104 106 255 022            CAL FSTORE             ;Save the result of the addition in F/N TEMP registers
3637 31-107 066 310                LLI 310                ;Load L with starting address of F/N LIMIT registers
3638 31-111 106 277 022            CAL FACXOP             ;Call subroutine to set up FP registers for subtraction
3639 31-114 106 032 021            CAL FPSUB              ;Subtract F/N LIMIT value from VARIABLE value
3640 31-117 066 306                LLI 306                ;Set pointer to MSW of F/N STEP registers
3641 31-121 307                    LAM                    ;Fetch this value into the ACC
3642 31-122 240                    NDA                    ;Test to see if STEP value might be zero
3643 31-123 066 126                LLI 126                ;Load L with address of MSW of FPACC
3644 31-125 307                    LAM                    ;Fetch this value into the ACC
3645 31-126 150 121 030            JTZ FORNXT             ;If STEP size was zero, then endless loop, an error condx
3646 31-131 160 170 031            JTS NEXT11             ;If STEP size less than zero make alternate test on limit
3647 31-134 240                    NDA                    ;Test the contents of the MSW of the FPACC
3648 31-135 160 177 031            JTS NEXT12             ;Continue FORINEXT loop if current variable value is
3649 31-140 150 177 031            JTZ NEXT12             ;Less than or equal to the F/N LIMIT value
3650 31-143 066 363     NEXT10:    LLI 363                ;If out of LIMIT range, load L with address of the AUX
3651 31-145 056 026                LHI \HB\OLDPG26        ;** PGM LINE pointer. (Contains pointer to the NEXT
3652 31-147 347                    LEM                    ;Statement line that initiated this routine.) Fetch the
3653 31-150 061                    DCL                    ;Low part of the address into E, decrement the memory
3654 31-151 337                    LDM                    ;And get the page part of the address into CPU register
3655 31-152 061                    DCL                    ;Decrement memory pointer to the low portion of the
3656 31-153 374                    LME                    ;User pgm buffer line pointer (regular pointer) and set it
3657 31-154 061                    DCL                    ;With the value from the AUX line pntr, decrement the
3658 31-155 373                    LMD                    ;Pointer and do the same for the page portion
3659 31-156 066 205                LLI 205                ;Set L to address of FOR/NEXT STACK pointer
3660 31-160 056 027                LHI \HB\OLDPG27        ;** Set H to page of FOR/NEXT STACK pointer
3661 31-162 317                    LBM                    ;Fetch and decrement the
3662 31-163 011                    DCB                    ;FOR/NEXT STACK pointer value
3663 31-164 371                    LMB                    ;To perform effective popping operation
3664 31-165 104 116 013            JMP NXTLIN             ;Statement line after NEXT statement is done next
3665 31-170 240         NEXT11:    NDA                    ;When F/N STEP is negative, reverse test so that if the
3666 31-171 120 177 031            JFS NEXT12             ;Variable value is greater than or equal to the F/N LIMIT
3667 31-174 104 143 031            JMP NEXT10             ;The FOR/NEXT loop continues. Else it is finished.
3668 31-177 066 314     NEXT12:    LLI 314                ;Load L with address of FIN TEMP storage registers
3669 31-201 056 001                LHI \HB\OLDPG1         ;** Set H to FIN TEMP storage registers page
3670 31-203 106 244 022            CAL FLOAD              ;Transfer the updated variable value to the FPACC
3671 31-206 106 252 010            CAL RESTSY             ;Restore the variable name and value
3672 31-211 106 055 010            CAL STOSYM             ;In the VARIABLES table. Exit routine so that
3673 31-214 104 116 013            JMP NXTLIN             ;Statement line after FOR statement is done next
3674                    
3675                    ;;; The label BACKSP SHOULD BE AT 31 217
3676                    
3677 31-217 006 215     BACKSP:    LAI 215                ;Load ASCII code for carriage-return into the ACC
3678 31-221 106 202 003            CAL ECHO               ;Display the carriage-return
3679 31-224 106 202 003            CAL ECHO               ;Repeat to provide extra time if TTY
3680 31-227 066 043                LLI 043                ;Load L with address of COLUMN COUNTER
3681 31-231 056 001                LHI \HB\OLDPG1         ;** Set H to page of COLUMN COUNTER
3682 31-233 076 001                LMI 001                ;Set COLUMN COUNTER to first column
3683 31-235 066 124                LLI 124                ;Set L to address containing desired TAB position
3684 31-237 307                    LAM                    ;Fetch the desired TAB position value
3685 31-240 240                    NDA                    ;Test to see if it is
3686 31-241 063                    RTS                    ;Negative or zero
3687 31-242 053                    RTZ                    ;In which case return to caller
3688 31-243 104 022 010            JMP TAB1               ;Else, proceed to perform the TAB operation.
3689                    
3690                    	
3691                    ;;; The label FOR5 SHOULD START AT 31 246
3692                    	
3693 31-246 066 205     FOR5:      LLI 205                ;Load L with address of the FOR/NEXT STACK pointer
3694 31-250 056 027                LHI \HB\OLDPG27        ;** Load H with page of the FOR/NEXT STACK pntr
3695 31-252 307                    LAM                    ;Fetch the stack pointer to the ACC.
3696 31-253 002                    RLC                    ;Rotate it left to multiply by two, then rotate it again to
3697 31-254 002                    RLC                    ;Multiply by four. Add this value to the base address
3698 31-255 004 136                ADI 136                ;Plus two of the base address to point to the next part of
3699 31-257 340                    LEA                    ;The FOR/NEXT STACK. Place this value in register E.
3700 31-260 335                    LDH                    ;Set D to the FORINEXT STACK area page.
3701 31-261 066 145                LLI 145                ;Load L with the address of the first character in the
3702 31-263 056 026                LHI \HB\OLDPG26        ;** AUX SYMBOL BUFFER and set up H to this page.
3703 31-265 016 002                LBI 002                ;Set up register B as a number of bytes to move counter.
3704 31-267 106 013 021            CAL MOVEIT             ;Move the variable name into the FOR/NEXT STACK.
3705 31-272 106 055 010            CAL STOSYM             ;Store initial variable value in the VARIABLES TABLE.
3706 31-275 104 116 013            JMP NXTLIN             ;Continue with next line in user program buffer.
3707                    
3708                    
3709                    ;;; The label PARSEP SHOULD START AT 31 300
3710 31-300 066 176     PARSEP:    LLI 176                ;Load L with PARSER TOKEN storage location. Set
3711 31-302 076 000                LMI 000                ;The value indicating end of expression. Call the
3712 31-304 106 324 004            CAL PARSER             ;PARSER subroutine for final time for the expression.
3713 31-307 066 227                LLI 227                ;Change L to point to the ARITH STACK pointer.
3714 31-311 056 001                LHI \HB\OLDPG1         ;** Set H to the page of the ARITH STACK pointer.
3715 31-313 307                    LAM                    ;Fetch the ARITH STACK pointer value.
3716 31-314 074 230                CPI 230                ;Should indicate only one value (answer) in stack.
3717 31-316 053                    RTZ                    ;Exit with answer in FPACC if ARITH STACK is O.K.
3718 31-317 104 152 011            JMP SYNERR             ;Else have a syntax error!
3719                    	
3720                    	
3721                    ;;; THERE IS SOME BLANK ADDRESSES HERE 317-NEXT PAGE
3722                    	
3723                    
3724                    	ORG 032#000
3725 32-000 066 014     SQRX:      LLI 014                ;Load L with address of FP TEMP registers
3726 32-002 056 001                LHI \HB\OLDPG1         ;** Set H to page of FP TEMP. Move contents of FPACC
3727 32-004 106 255 022            CAL FSTORE             ;[Argument of SQR(X)] into FP TEMP for storage.
3728 32-007 066 126                LLI 126                ;Load L with MSW of FPACC
3729 32-011 307                    LAM                    ;Fetch the MSW into the accumulator
3730 32-012 240                    NDA                    ;Check the sign of the number in the FPACC
3731 32-013 160 217 032            JTS SQRERR             ;If number negative, cannot take square root
3732 32-016 150 247 006            JTZ CFALSE             ;If number is zero, return with zero value in FPACC
3733 32-021 066 017                LLI 017                ;Load L with address of FP TEMP Exponent register
3734 32-023 307                    LAM                    ;Fetch the Exponent value into the ACC
3735 32-024 240                    NDA                    ;Check sign of the Fxponent
3736 32-025 160 041 032            JTS NEGEXP             ;If Exponent less than zero, process negative Exponent
3737 32-030 032                    RAR                    ;If Exponent positive, rotate right to divide by two
3738 32-031 310                    LBA                    ;And save the result in CPU register B
3739 32-032 006 000                LAI 000                ;Clear the accumulator without disturbing Carry bit
3740 32-034 022                    RAL                    ;Rotate Carry bit into the ACC to save remainder
3741 32-035 370                    LMA                    ;Store the remainder back in FP TEMP Exponent reg.
3742 32-036 104 062 032            JMP SQREXP             ;Jump to continue processing
3743 32-041 310         NEGEXP:    LBA                    ;For negative Exponent, form two Is complement by
3744 32-042 250                    XRA                    ;Placing the positive value in CPU register B, clearing
3745 32-043 221                    SUB                    ;The accumulator, and then subtracting B from the ACC
3746 32-044 240                    NDA                    ;Clear the Carry bit after the complementing operation
3747 32-045 032                    RAR                    ;Rotate the value right to divide by two
3748 32-046 310                    LBA                    ;Save the result in CPU register B
3749 32-047 006 000                LAI 000                ;Clear the accumulator without disturbing Carry bit
3750 32-051 210                    ACA                    ;Add Carry bit to the accumulator as remainder
3751 32-052 370                    LMA                    ;Store the remainder back in FP TEMP Exponent reg
3752 32-053 150 057 032            JTZ NOREMD             ;If remainder was zero skip ahead. If not, increment the
3753 32-056 010                    INB                    ;Result of the divide by two ops to compen for negative
3754 32-057 250         NOREMD:    XRA                    ;Clear the accumulator
3755 32-060 221                    SUB                    ;Subtract the quotient of the divide by two op to
3756 32-061 310                    LBA                    ;Form two's complement and save the result in register B
3757 32-062 066 013     SQREXP:    LLI 013                ;Load L with address of TEMP register
3758 32-064 371                    LMB                    ;Store Fxponent quotient from above ops in TEMP
3759 32-065 066 004                LLI 004                ;Load L with address of FP registers containing +1.0
3760 32-067 046 034                LEI 034                ;Load E with address of SQR APPROX working registers
3761 32-071 335                    LDH                    ;Set D to same page as H
3762 32-072 016 004                LBI 004                ;Set up register B as a number of bytes to move counter
3763 32-074 106 013 021            CAL MOVEIT             ;Transfer value +1.0 into SQR APPROX registers
3764 32-077 106 247 006            CAL CFALSE             ;Now clear the FPACC registers
3765 32-102 066 044                LLI 044                ;Load L with address of LAST SQR APPROX temp regs.
3766 32-104 106 255 022            CAL FSTORE             ;Initialize the LAST SQR APPROX regs to value of zero
3767 32-107 066 034     SQRLOP:    LLI 034                ;Load L with address of SQR APPROX working registers
3768 32-111 106 244 022            CAL FLOAD              ;Transfer SQR APPROX into the FPACC
3769 32-114 066 014                LLI 014                ;Load L with address of SQR ARG storage registers
3770 32-116 106 266 022            CAL OPLOAD             ;Transfer SQR ARG into the FPOP
3771 32-121 106 322 021            CAL FPDIV              ;Divde SQR ARG by SQR APPROX (Fon-n X/A)
3772 32-124 066 034                LLI 034                ;Load L with address of SQR APPROX registers
3773 32-126 106 266 022            CAL OPLOAD             ;Transfer SQR APPROX into the FPOP
3774 32-131 106 211 020            CAL FPADD              ;Add to form value (X/A + A)
3775 32-134 066 127                LLI 127                ;Load L with address of FPACC Exponent register
3776 32-136 317                    LBM                    ;Fetch Exponent value into CPU register B
3777 32-137 011                    DCB                    ;Subtract one to effectively divide FPACC by two
3778 32-140 371                    LMB                    ;Restore to memory. (Now have ((X/A + A) /2)
3779 32-141 066 034                LLI 034                ;Load L with address of SQR APPROX registers
3780 32-143 106 255 022            CAL FSTORE             ;Store contents of FPACC as new SQR APPROX
3781 32-146 066 044                LLI 044                ;Load L with address of LAST SQR APPROX registers
3782 32-150 106 266 022            CAL OPLOAD             ;Transfer LAST SQR APPROX into the FPOP
3783 32-153 106 032 021            CAL FPSUB              ;Subtract (LAST SQR APPROX - SQR APPROX)
3784 32-156 066 127                LLI 127                ;Load L with address of FPACC Exponent
3785 32-160 307                    LAM                    ;Fetch the Exponent into the accumulator
3786 32-161 074 367                CPI 367                ;See if difference less than 2 to the minus ninth
3787                    ;;; The below is changed for PATCH 2
3788                    ;;; following is the original code
3789                    ;;;           JTS SQRCNV             ;If so, approximation has converged
3790                    ;;; Now is the new line
3791 32-163 104 364 032 	   JMP PATCH2
3792                    ;;;;           DCL
3793                    ;;;;           LAM
3794                    ;;;;           NDA
3795                    ;;;;           JTZ SQRCNV             ;THIS IS PATCH #2
3796 32-166 066 034     SQR1:	   LLI 034                ;Else, load L with address of SQR APPROX
3797 32-170 335                    LDH                    ;Set D to same page as H
3798 32-171 046 044                LEI 044                ;And E with address of LAST SQR APPROX
3799 32-173 016 004                LBI 004                ;Set up register B as a number of bytes to move counter
3800 32-175 106 013 021            CAL MOVEIT             ;Transfer SQR APPROX into LAST SQR APPROX
3801 32-200 104 107 032            JMP SQRLOP             ;Continue ops until approximation converges
3802 32-203 066 013     SQRCNV:    LLI 013                ;Load L with address of TEMP register. Fetch the
3803 32-205 307                    LAM                    ;Exponenent quotient store there into accumulator.
3804 32-206 066 037                LLI 037                ;Change L to point to SQR APPROX exponent.
3805 32-210 207                    ADM                    ;Add SQR APPROX exponent to quotient value.
3806 32-211 370                    LMA                    ;Store sum back in SQR APPROX Exponent register.
3807 32-212 066 034                LLI 034                ;Load L with address of SQR APPROX. Transfer the
3808 32-214 104 244 022            JMP FLOAD              ;SQR APPROX into FPACC as answer and exit.
3809 32-217 006 323     SQRERR:    LAI 323                ;Load ASCII code for letter S into the accumulator.
3810 32-221 026 321                LCI 321                ;Load ASCII code for letter Q into CPU register C.
3811 32-223 104 226 002            JMP ERROR              ;Display the SQuare root (SQ) error message.
3812                    ;;; above instruction starts at 223
3813                    ;;; some blank addresses available here.
3814                    	ORG 032#240
3815 32-240 066 064     RNDX:      LLI 064                ;Load L with address of SEED storage registers
3816 32-242 056 001                LHI \HB\OLDPG1         ;** Set H to page for floating point working registers
3817 32-244 106 244 022            CAL FLOAD              ;Transfer SEED into the FPACC
3818 32-247 066 050                LLI 050                ;Load L with address of random constant A
3819 32-251 106 266 022            CAL OPLOAD             ;Transfer random constant A into the FPOP
3820 32-254 106 046 021            CAL FPMULT             ;Multiply to form (SEED * A)
3821 32-257 066 060                LLI 060                ;Load L with address of random constant C
3822 32-261 106 266 022            CAL OPLOAD             ;Transfer random constant C into the FPOP
3823 32-264 106 211 020            CAL FPADD              ;Add to fom (SEED * A) + C
3824 32-267 066 064                LLI 064                ;Load L with address of SEED storage registers
3825 32-271 106 255 022            CAL FSTORE             ;Store I (SEED * A) + C] in former SEED registers
3826 32-274 066 127                LLI 127                ;Load L with address of FPACC Exponent register
3827 32-276 307                    LAM                    ;Fetch Exponent value into the accumulator
3828 32-277 024 020                SUI 020                ;Subtract 16 (decimal) to effectively divide by 65,536
3829 32-301 370                    LMA                    ;Now FPACC = [((SEED * A) + C)/65,536]
3830 32-302 106 000 020            CAL FPFIX              ;Convert floating to fixed point to obtain integer part
3831 32-305 066 123                LLI 123                ;Load L with address of FPACC Extension register
3832 32-307 076 000                LMI 000                ;Clear the FPACC Extension register
3833 32-311 066 127                LLI 127                ;Load L with address of FPACC Exponent
3834 32-313 076 000                LMI 000                ;Clear the FPACC Exponent register
3835 32-315 106 064 020            CAL FPFLT              ;Fetch INT(((SEED * A) + C)/65,536) into the FPACC
3836 32-320 066 127                LLI 127                ;Load L with address of FPACC Exponent
3837 32-322 307                    LAM                    ;Fetch FPACC Exponent into the accumulator
3838 32-323 004 020                ADI 020                ;Add 16 (decimal) to effectively multiply by 65,536
3839 32-325 370                    LMA                    ;(65,536 * INT[ ((SEED * A) + C)/65,5361) in FPACC
3840 32-326 066 064                LLI 064                ;Load L with address of [(SEED * A) + C]
3841 32-330 106 266 022            CAL OPLOAD             ;Transfer it into FPOP. Subtract FPACC to form
3842 32-333 106 032 021            CAL FPSUB              ;[(SEED * A) + C] MOD 65,536
3843 32-336 066 064                LLI 064                ;Load L with address of former SEED registers
3844 32-340 106 255 022            CAL FSTORE             ;Store SEED MOD 65,536 in place of [(SEED * A) + Cl
3845 32-343 066 127                LLI 127                ;Load L with address of FPACC Exponent
3846 32-345 307                    LAM                    ;Fetch FPACC Exponent into the ACC and subtract
3847 32-346 024 020                SUI 020                ;16 (decimal) to form (SEED MOD 65,536)/65,536
3848 32-350 370                    LMA                    ;So that random number in FPACC is between
3849 32-351 007                    RET                    ;0.0 and +1.0 and exit to calling routine
3850                    ;;; THE ABOVE RETURN SHOULD BE 32 351
3851                    	
3852                    
3853                    ;;; NOTE OPEN ADDRESSES TO END OF PAGE 32
3854                    
3855                    ;;; following is PATCH 2
3856                    	ORG 032#364
3857 32-364 160 203 032 PATCH2:	JTS SQRCNV
3858 32-367 061         	DCL
3859 32-370 307         	LAM
3860 32-371 240         	NDA
3861 32-372 150 203 032 	JTZ SQRCNV
3862 32-375 104 166 032 	JMP SQR1
3863                    ;;; The above jump should start at 32 375
3864                    	
3865                    
3866                    	;; PAGES 33 TO REMAINDER OF MEMORY
3867                    	;; OR START OF OPTIONAL ARRAY HANDLING
3868                    	;; ROUTINES USED AS USER PROGRAM BUFFER
3869                    
3870                    
3871                    
3872                    	;; OPTIONAL ARRAY ROUTINES ASSEMBLED FOR OPERATION
3873                    	;; IN THE UPPER 3 PAGES OF A 12K SYSTEM ARE LISTED HERE.
3874                    
3875                    	ORG 055#000
3876                    	
3877 55-000 066 126     PRIGH1:    LLI 126                ;Load L with address of the MSW in the FPACC
3878 55-002 056 001                LHI \HB\OLDPG1         ;** Set H to page of FPACC
3879 55-004 307                    LAM                    ;Fetch MSW of FPACC into the ACC.
3880 55-005 240                    NDA                    ;Test to see if value in FPACC is positive.
3881 55-006 160 136 055            JTS OUTRNG             ;If not, go display error message.
3882 55-011 106 000 020            CAL FPFIX              ;If O.K. then convert floating point to fixed point
3883 55-014 066 124                LLI 124                ;Load L with address of LSAL of converted value
3884 55-016 307                    LAM                    ;Fetch the LSW of the value into the ACC
3885 55-017 024 001                SUI 001                ;Subtract one from the value to establish proper
3886 55-021 002                    RLC                    ;Origin for future ops. Now rotate the value twice
3887 55-022 002                    RLC                    ;To effectively multiply by four. Save the
3888 55-023 320                    LCA                    ;Calculated result in CPU register C
3889 55-024 066 203                LLI 203                ;Load L with address of F/A STACK TEMP
3890 55-026 056 027                LHI \HB\OLDPG27        ;** Load H with page of F/A STACK TEMP
3891 55-030 307                    LAM                    ;Fetch the value into the accumulator
3892 55-031 054 377                XRI 377                ;Complement the value
3893 55-033 002                    RLC                    ;Rotate the value twice to multiply by four (the number
3894 55-034 002                    RLC                    ;Of bytes per entry in the ARRAY VARIABLES table).
3895 55-035 004 120                ADI 120                ;Add the starting address of the ARRAY VARIABLES
3896 55-037 056 027                LHI \HB\OLDPG27        ;** TABLE to forin pointer. Set page address in H.
3897 55-041 360                    LLA                    ;Point to the name in the ARRAY VARIABLES
3898 55-042 060                    INL                    ;Increment the pointer value twice to move over the
3899 55-043 060                    INL                    ;Name in the table and point to starting address for the
3900 55-044 307                    LAM                    ;Array values in the ARRAY VALUES table. Fetch this
3901 55-045 202                    ADC                    ;Address to the ACC. Now add in the figure calculated
3902 55-046 360                    LLA                    ;To reach desired subscripted data storage location. Set
3903 55-047 056 057                LHI \HB\OLDPG57        ;tt The pointer to that location. Load the floating point
3904 55-051 104 244 022            JMP FLOAD              ;Value stored there into the FPACC and exit to caller.
3905                    	
3906                    	
3907                    ;;; The label FUNAR2 SHOULD START AT 55-054
3908 55-054 066 202     FUNAR2:    LLI 202                ;Load L with address of TEMP COUNTER
3909 55-056 056 027                LHI \HB\OLDPG27        ;** Load H with page of counter
3910 55-060 317                    LBM                    ;Fetch the counter value
3911 55-061 010                    INB                    ;Increment the value
3912 55-062 371                    LMB                    ;Restore the value to memory
3913 55-063 026 002                LCI 002                ;Initialize register C to a value of two for future ops
3914 55-065 066 114                LLI 114                ;Load L with address of start of ARRAY VARIABLES
3915 55-067 056 027                LHI \HB\OLDPG27        ;** TABLE (less four). Set H to page of the table.
3916 55-071 106 230 007            CAL TABADR             ;Calculate address of start of next narne in table.
3917 55-074 036 026                LDI \HB\OLDPG26        ;** Load D with page of the SYMBOL BUFFER
3918 55-076 046 120                LEI 120                ;Set E to starting address of the SYMBOL BUFFER
3919 55-100 106 332 002            CAL STRCP              ;Compare name in ARRAY VARIABLES table to the
3920 55-103 150 124 055            JTZ FUNAR3             ;Contents of the SYMBOL BUFFER. If match, go set up
3921 55-106 066 202                LLI 202                ;Array token value. Else, reset L to address of TEMP
3922 55-110 056 027                LHI \HB\OLDPG27        ;** COUNTER. Set H to page of TEMP COUNTER.
3923 55-112 307                    LAM                    ;Fetch the counter value into the accumulator.
3924 55-113 066 075                LLI 075                ;Change L to number of arrays storage location.
3925 55-115 277                    CPM                    ;Compare number of entries checked against number
3926 55-116 110 054 055            JFZ FUNAR2             ;Possible. Keep searching table if not finished.
3927 55-121 104 172 007            JMP FAERR              ;If finished and no match than have F/A error condx.
3928 55-124 066 202     FUNAR3:    LLI 202                ;Load L with address of TEMP COUNTER
3929 55-126 056 027                LHI \HB\OLDPG27        ;** Load H with page of counter.
3930 55-130 250                    XRA                    ;Clear the accumulator. Subtract the value in the TEMP
3931 55-131 237                    SBM                    ;COUNTER from zero to obtain two's complement.
3932 55-132 370                    LMA                    ;Place this back in counter location as ARRAY TOKEN
3933 55-133 104 207 007            JMP FUNAR4             ;VALUE (negative). Go place the value on F/A STACK.
3934                    	
3935                    
3936                    ;;; The label OUTRNG STARTS AT 55 136
3937 55-136 006 317     OUTRNG:    LAI 317                ;Load the ASCII code for letter 0 into the accumulator
3938 55-140 026 322                LCI 322                ;Load the ASCII code for letter R into register C
3939 55-142 104 226 002            JMP ERROR              ;Go display Out of Range (OR) error message.
3940                    	
3941                    
3942                    
3943                    	
3944 55-145 106 252 010 ARRAY:     CAL RESTSY             ;Transfer contents of AUX SYMBOL BUFFER into the
3945 55-150 104 160 055            JMP ARRAY2             ;SYMBOL BUFFER. (Entry when have actual LET)
3946 55-153 066 202     ARRAY1:    LLI 202                ;Load L with address of SCAN pointer
3947 55-155 104 162 055            JMP ARRAY3             ;Proceed to process. (Entry point for IMPLIED LET)
3948 55-160 066 203     ARRAY2:    LLI 203                ;Load L with address of LET pointer
3949 55-162 056 026     ARRAY3:    LHI \HB\OLDPG26        ;** Set H to pointer page
3950 55-164 317                    LBM                    ;Fetch pointer to location where "(" found in statement
3951 55-165 010                    INB                    ;Line. Increment it to point to next character in the line.
3952 55-166 066 276                LLI 276                ;Load L with address of EVAL pointer and load it with
3953 55-170 371                    LMB                    ;The starting address for the EVAL routine
3954 55-171 066 206                LLI 206                ;Change L to address of ARRAY SETUP pointer
3955 55-173 371                    LMB                    ;And also store address in that location
3956 55-174 066 206     ARRAY4:    LLI 206                ;Load L with address of ARRAY SETUP pointer
3957 55-176 106 240 002            CAL GETCHR             ;Fetch character pointed to by ARRAY SETUP pntr
3958 55-201 074 251                CPI 251                ;See if character is ")" ? If so, then have located
3959 55-203 150 225 055            JTZ ARRAY5             ;End of the subscript. If not, reset
3960 55-206 066 206                LLI 206                ;to the ARRAY SETUP pointer. Increment the
3961 55-210 106 003 003            CAL LOOP               ;Pointer and test for the end of the statement line.
3962 55-213 110 174 055            JFZ ARRAY4             ;If not end of line, continue looking for right paren.
3963 55-216 006 301                LAI 301                ;If reach end of line before right parenthesis than load
3964 55-220 026 306                LCI 306                ;ASCII code for letters A and F and display message
3965 55-222 104 226 002            JMP ERROR              ;Indicating Array Forrnat (AF) error condition
3966 55-225 066 206     ARRAY5:    LLI 206                ;Load L with address of ARRAY SETUP pointer
3967 55-227 317                    LBM                    ;Fetch pointer (pointing to ")"sign) into register B
3968 55-230 011                    DCB                    ;Decrement it to move back to end of subscript number
3969 55-231 066 277                LLI 277                ;Load L with address of EVAL FINISH pointer location
3970 55-233 371                    LMB                    ;Place the pointer value in the EVAL FINISH pointer
3971 55-234 066 207                LLI 207                ;Load L with address of LOOP COUNTER
3972 55-236 076 000                LMI 000                ;Initialize LOOP COUNTER to value of zero
3973 55-240 066 207     ARRAY6:    LLI 207                ;Load L with address of LOOP COUNTER
3974 55-242 056 026                LHI \HB\OLDPG26        ;** Load H with page of LOOP COUNTER
3975 55-244 317                    LBM                    ;Fetch the counter value
3976 55-245 010                    INB                    ;Increment it
3977 55-246 371                    LMB                    ;Restore the counter value to memory
3978 55-247 026 002                LCI 002                ;Set up counter in register C for future ops
3979 55-251 066 114                LLI 114                ;Load L with address of start of ARRAY VARIABLES
3980 55-253 056 027                LHI \HB\OLDPG27        ;** Table less four). Set H to page of the table.
3981 55-255 106 230 007            CAL TABADR             ;Calculate the address of next entry in the table
3982 55-260 046 120                LEI 120                ;Load register E with starting address of SYMBOL BUFF
3983 55-262 036 026                LDI \HB\OLDPG26        ;** Set D to page of SYMBOL BUFFER
3984 55-264 106 332 002            CAL STRCP              ;Compare entry in table against contents of SYMBOL BF
3985 55-267 150 312 055            JTZ ARRAY7             ;If match, have found array naine in the table.
3986 55-272 066 207                LLI 207                ;Else, set L to address of the LOOP COUNTER
3987 55-274 056 026                LHI \HB\OLDPG26        ;** Set H to page of the LOOP COUNTER
3988 55-276 307                    LAM                    ;Fetch the counter value to the ACC
3989 55-277 066 075                LLI 075                ;Change L to the counter containing number of arrays
3990 55-301 056 027                LHI \HB\OLDPG27        ;** Set H to the proper page
3991 55-303 277                    CPM                    ;Compare number of arrays to count in LOOP CNTR
3992 55-304 110 240 055            JFZ ARRAY6             ;If more entries in the table, continue looking for match
3993 55-307 104 172 007            JMP FAERR              ;If no matching name in table then have an error condx.
3994 55-312 106 224 003 ARRAY7:    CAL EVAL               ;Call subroutine to evaluate subscript expression
3995 55-315 106 000 020            CAL FPFIX              ;Convert the subscript value obtained to fixed forrnat
3996 55-320 066 207                LLI 207                ;Load L with address of LOOP COUNTER
3997 55-322 056 026                LHI \HB\OLDPG26        ;** Set H to page of the LOOP COUNTER
3998 55-324 317                    LBM                    ;Fetch the value in the LOOP COUNTER into the ACC
3999 55-325 026 002                LCI 002                ;Set up counter in register C future ops
4000 55-327 066 114                LLI 114                ;Load L with address of ARRAY VARIABLES
4001 55-331 056 027                LHI \HB\OLDPG27        ;** Table less four). Set H to page of the table.
4002 55-333 106 230 007            CAL TABADR             ;Calculate the address of entry in the table
4003 55-336 060                    INL                    ;Advance the ARRAY VARIABLES table pointer twice
4004 55-337 060                    INL                    ;To advance pointer over array name.
4005 55-340 327                    LCM                    ;Fetch array base address in ARRAY VALUES table
4006 55-341 066 124                LLI 124                ;Load L with address of subscript value
4007 55-343 056 001                LHI \HB\OLDPG1         ;** Set H to page of subscript value
4008 55-345 307                    LAM                    ;Fetch the subscript value into the accumulator
4009 55-346 024 001                SUI 001                ;Subtract one from subscript value to allow for zero
4010 55-350 002                    RLC                    ;Origin. Now multiply by four
4011 55-351 002                    RLC                    ;Using rotates (number of bytes required for each entry
4012 55-352 202                    ADC                    ;In the ARRAY VALUES table). Add in base address to
4013 55-353 066 204                LLI 204                ;The calculated value to form final address in the
4014 55-355 056 027                LHI \HB\OLDPG27        ;** ARRAY VALUES table. Now set H & L to TEMP
4015 55-357 370                    LMA                    ;ARRAY ELEMENT storage location & store the addr.
4016 55-360 066 201                LLI 201                ;Change L to point to ARRAY FLAG
4017 55-362 076 377                LMI 377                ;Set the ARRAY FLAG for future use
4018 55-364 007                    RET                    ;Exit to calling routine
4019                    
4020                    	
4021                    ;;; The label DIM SHOULD START AT 55 365
4022 55-365 106 255 002 DIM:       CAL CLESYM             ;Initialize the SYMBOL BUFFER to cleared condition
4023 55-370 066 202                LLI 202                ;Load L with address of SCAN pointer
4024 55-372 317                    LBM                    ;Fetch SCAN pointer value into register B
4025 55-373 010                    INB                    ;Add one to the SCAN pointer value
4026 55-374 066 203                LLI 203                ;Change L to DIM pointer (formerly TOKEN) storage
4027 55-376 371                    LMB                    ;Store the updated SCAN pointer as the DIM pointer
4028 55-377 066 203     DIM1:      LLI 203                ;Load L with the address of DIM pointer storage location
4029 56-001 106 240 002            CAL GETCHR             ;Fetch a character from the line input buffer
4030 56-004 150 017 056            JTZ DIM2               ;If character fetched is a space, ignore it
4031 56-007 074 250                CPI 250                ;Else see if character is "(" left parenthesis
4032 56-011 150 032 056            JTZ DIM3               ;If so, should have ARRAY VARIABLE naine in buffer
4033 56-014 106 310 002            CAL CONCTS             ;If not, append the character to the SYMBOL BUFFER
4034 56-017 066 203     DIM2:      LLI 203                ;Load L with the address of DIM pointer stomge location
4035 56-021 106 003 003            CAL LOOP               ;Increment the pointer and see if end of line
4036 56-024 110 377 055            JFZ DIM1               ;If not end of line, fetch next character
4037 56-027 104 337 056            JMP DIMERR             ;Else have a DIMension error condition
4038 56-032 066 206     DIM3:      LLI 206                ;Load L with address of ARRAY pointer storage loc
4039 56-034 076 000                LMI 000                ;Initialize ARRAY pointer to starting value of zero
4040 56-036 066 206     DIM4:      LLI 206                ;Load L with address of ARRAY pointer storage loc
4041 56-040 056 026                LHI \HB\OLDPG26        ;** Set H to page of ARRAY pointer storage location
4042 56-042 307                    LAM                    ;Fetch value in ARRAY pointer to ACC (effectively
4043 56-043 002                    RLC                    ;Represents number of arrays defined in pgm). Rotate
4044 56-044 002                    RLC                    ;Left twice to multiply by four (niunber of bytes per
4045 56-045 004 114                ADI 114                ;entry in ARRAY VARIABLES table). Add to base
4046 56-047 056 027                LHI \HB\OLDPG27        ;** Address to form pointer to ARRAY VARIA.BLES
4047 56-051 360                    LLA                    ;Table and set up H & L as the memory pointer.
4048 56-052 046 120                LEI 120                ;Load E with starting address of the SYMBOL BUFFER
4049 56-054 036 026                LDI \HB\OLDPG26        ;** Load D with the page address of the SYMBOL BUFF
4050 56-056 106 332 002            CAL STRCP              ;Compare contents of SYMBOL BF to entry in ARRAY
4051 56-061 150 301 056            JTZ DIM9               ;VARIABLES table. If same, have duplicate array name.
4052 56-064 066 206                LLI 206                ;Else, load L with address of ARRAY pointer storage
4053 56-066 056 026                LHI \HB\OLDPG26        ;** Load H with page of ARRAY pointer storage
4054 56-070 317                    LBM                    ;Fetch the ARRAY pointer value to register B
4055 56-071 010                    INB                    ;Increment the value
4056 56-072 371                    LMB                    ;Restore it to ARRAY pointer storage location
4057 56-073 066 075                LLI 075                ;Change L to number of arrays storage location
4058 56-075 056 027                LHI \HB\OLDPG27        ;** Set H to page of the number of arrays stomge loc
4059 56-077 307                    LAM                    ;Fetch the number of arrays value to the ACC
4060 56-100 011                    DCB                    ;Restore B to previous count
4061 56-101 271                    CPB                    ;Compare number of arrays tested against nr defined
4062 56-102 110 036 056            JFZ DIM4               ;If not equal, continue searching ARRAY VARIABLES
4063 56-105 066 075                LLI 075                ;Table. When table searched with no match, then must
4064 56-107 056 027                LHI \HB\OLDPG27        ;** Append naine to table. First set pointer to number
4065 56-111 317                    LBM                    ;Of arrays storage location. Fetch that value and
4066 56-112 010                    INB                    ;Add one to account for new name being added.
4067 56-113 371                    LMB                    ;Restore the updated value back to memory.
4068 56-114 066 076                LLI 076                ;Change pointer to ARRAY TEMP pointer storage
4069 56-116 371                    LMB                    ;Store pointer to current array in ARRAY TEMP too.
4070 56-117 066 206                LLI 206                ;Load L with address of ARRAY pointer stomge loc.
4071 56-121 056 026                LHI \HB\OLDPG26        ;** Set H to page of ARRAY pointer storage location
4072 56-123 371                    LMB                    ;And update it also for new array being added.
4073 56-124 307                    LAM                    ;Fetch the current ARRAY pointer value to the ACC
4074 56-125 002                    RLC                    ;Multiply it times four by performing two rotate left
4075 56-126 002                    RLC                    ;Operations and add it to base value to form address in
4076 56-127 004 114                ADI 114                ;The ARRAY VARIABLES table. Place the low part
4077 56-131 340                    LEA                    ;Of this calculated address value into register E.
4078 56-132 036 027                LDI \HB\OLDPG27        ;** Set register D to the page of the table.
4079 56-134 066 120                LLI 120                ;Load L with the start of the SYMBOL BUFFER
4080 56-136 056 026                LHI \HB\OLDPG26        ;** Load H with the page of the SYMBOL BUFFER
4081 56-140 106 046 012            CAL MOVEC              ;Move the array name from the SYMBOL BUFFER to
4082 56-143 106 255 002            CAL CLESYM             ;The ARRAY VARIABLES table. Then clear the
4083 56-146 066 203                LLI 203                ;SYMBOL BUFFER. Reset L to the DIM pointer storage
4084 56-150 056 026                LHI \HB\OLDPG26        ;** Location. Set H to the DIM pointer page.
4085 56-152 317                    LBM                    ;Fetch the pointer value (points to "(" part of DIM
4086 56-153 010                    INB                    ;Statement). Increment the pointer to next character in
4087 56-154 066 204                LLI 204                ;The line input buffer. Cbange L to DIMEN pointer.
4088 56-156 371                    LMB                    ;Store the updated DIM pointer in DIMEN storage loc.
4089 56-157 066 204     DIM5:      LLI 204                ;Set L to DIMEN pointer storage location
4090 56-161 106 240 002            CAL GETCHR             ;Fetch character in line input buffer
4091 56-164 150 211 056            JTZ DIM6               ;Ignore character for space
4092 56-167 074 251                CPI 251                ;If not space, see if character is right parenthesis
4093 56-171 150 224 056            JTZ DIM7               ;If yes, process DIMension size (array length)
4094 56-174 074 260                CPI 260                ;If not, see if character is a valid decimal number
4095 56-176 160 337 056            JTS DIMERR             ;If not valid number, have DIMension error condition
4096 56-201 074 272                CPI 272                ;Continue testing for valid decitnal number
4097 56-203 120 337 056            JFS DIMERR             ;If not valid number, then DIMension error condition
4098 56-206 106 310 002            CAL CONCTS             ;If valid decirnal number, append digit to SYMBOL BF
4099 56-211 066 204     DIM6:      LLI 204                ;Set L to DIMEN pointer storage location
4100 56-213 106 003 003            CAL LOOP               ;Advance the pointer value and check for end of the line
4101 56-216 110 157 056            JFZ DIM5               ;If not end of line, continue fetching DIMension size
4102 56-221 104 337 056            JMP DIMERR             ;If end of line before right parenthesis, have error condx.
4103 56-224 066 120     DIM7:      LLI 120                ;Load L with address of start of SYMBOL BUFFER
4104 56-226 056 026                LHI \HB\OLDPG26        ;** Load H with page of SYMBOL BUFFER. (Now
4105 56-230 106 044 023            CAL DINPUT             ;Contains DIMension size.) Convert buffer to floating
4106 56-233 106 000 020            CAL FPFIX              ;Point number and then reformat to fixed point.
4107 56-236 066 124                LLI 124                ;Load L with address of LSW of fixed point number
4108 56-240 307                    LAM                    ; And fetch the low order byte of the nr into the ACC
4109 56-241 002                    RLC                    ;Rotate it left two tirnes to multiply it by four (the
4110 56-242 002                    RLC                    ;Number of bytes required to store a floating point nr).
4111 56-243 320                    LCA                    ;Store this value in CPU register C temporarily
4112 56-244 066 076                LLI 076                ;Set L to ARRAY TEMP storage location.
4113 56-246 056 027                LHI \HB\OLDPG27        ;** Set H to ARRAY TEMP pointer page.
4114 56-250 307                    LAM                    ;Fetch the value in ARRAY TEMP (points to ARRAY
4115 56-251 024 001                SUI 001                ;VARIABLES table). Subtract one from the pointer
4116 56-253 002                    RLC                    ;Value and multiply the result by four using rotate left
4117 56-254 002                    RLC                    ;Instructions. Add this value to a base address
4118 56-255 004 122                ADI 122                ;(Augmented by two) to point to ARRAY VALUES
4119 56-257 360                    LLA                    ;Pointer storage location in the ARRAY VARIABLES
4120 56-260 056 027                LHI \HB\OLDPG27        ;Table and set the pointer up in registers H & L.
4121 56-262 317                    LBM                    ;Fetch the starting address in the ARRAY VALUES
4122 56-263 004 004                ADI 004                ;Table for the previous array into register B. Now add
4123 56-265 360                    LLA                    ;Four to the ARRAY VARIABLES table pointer to
4124 56-266 301                    LAB                    ;Point to curront ARRAY VALUES starting address.
4125 56-267 202                    ADC                    ;Add the previous array starting address plus number of
4126 56-270 370                    LMA                    ;Bytes required and store as starting loc for next array
4127 56-271 066 204     DIM8:      LLI 204                ;Set L to address of DIMEN pointer storage location
4128 56-273 056 026                LHI \HB\OLDPG26        ;** Set H to page of DIMEN pointer
4129 56-275 317                    LBM                    ;Fetch pointer value (points to ") " in line)
4130 56-276 066 203                LLI 203                ;Change L to DIM pointer storage location
4131 56-300 371                    LMB                    ;Store former DIMEN value back in DIM pointer
4132 56-301 066 203     DIM9:      LLI 203                ;Load L with address of DIM pointer storage location
4133 56-303 106 240 002            CAL GETCHR             ;Fetch a character from the line input buffer
4134 56-306 074 254                CPI 254                ;See if character is a comma (,) sign
4135 56-310 150 326 056            JTZ DIM10              ;If yes, have another array being defined on the line
4136 56-313 066 203                LLI 203                ;If not, reset L to the DIM pointer
4137 56-315 106 003 003            CAL LOOP               ;Increment the pointer and see if end of the line
4138 56-320 110 301 056            JFZ DIM9               ;If not end of the line, keep looking for a comma
4139 56-323 104 116 013            JMP NXTLIN             ;Else exit the DIM statement routine to continue pgm
4140 56-326 066 203     DIM10:     LLI 203                ;Set L to DIM pointer storage location
4141 56-330 317                    LBM                    ;Fetch pointer value (points to comma sign just found)
4142 56-331 066 202                LLI 202                ;Load L with address of SCAN pointer storage location
4143 56-333 371                    LMB                    ;Place DIM pointer into the-SCAN pointer
4144 56-334 104 365 055            JMP DIM                ;Continue processing DIM statement line for next array
4145 56-337 006 304     DIMERR:    LAI 304                ;On error condition, load ASCII code for letter D in ACC
4146 56-341 026 305                LCI 305                ;And ASCII code for letter E in CPU register C
4147 56-343 104 226 002            JMP ERROR              ;Go display the Dirnension Error (DE) message.
4148                    
4149                    	
4150                    
4151                    
4152                    
4153                    
Symbol Count: 389
    Symbol  Oct Val  DecVal
    ------  -------  ------
  ENDPGRAM      055     45
  BGNPGRAM      033     27
    OLDPG1    1 000    256
   OLDPG26   26 000   5632
   OLDPG27   27 000   5888
   OLDPG57   57 000  12032
      save      100     64
      load      100     64
    INPORT      005      5
   OUTPORT      016     14
      CINP      103     67
     MORE1      113     75
      STOP      153    107
     MORE3      162    114
    NEXBIT      167    119
     TIMER      177    127
     MORE2      201    129
     UDEFX      207    135
    CPRINT      210    136
    BITOUT      264    180
    SYNTAX    2 000    512
    SYNTX1    2 015    525
    SYNTX2    2 044    548
    SYNTX3    2 061    561
    SYNTX4    2 067    567
    SYNTX5    2 124    596
    SYNTXL    2 137    607
    SYNTX6    2 171    633
    SYNTX7    2 210    648
    SYNTX8    2 215    653
    BIGERR    2 222    658
     ERROR    2 226    662
    GETCHR    2 240    672
    CLESYM    2 255    685
    CONCTA    2 264    692
    CONCTN    2 276    702
    CONCTS    2 310    712
    CONCT1    2 314    716
    CONCTE    2 327    727
     STRCP    2 332    730
    STRCPL    2 344    740
    STRCPE    2 356    750
    STRCPC    2 370    760
       ADV    2 377    767
      LOOP    3 003    771
     STRIN    3 014    780
    STRIN1    3 016    782
    NOTDEL    3 045    805
    STRINF    3 102    834
     SUBHL    3 113    843
     TEXTC    3 121    849
    TEXTCL    3 125    853
      CRLF    3 141    865
       DEC    3 164    884
     DECNO    3 172    890
    INDEXB    3 174    892
      ECHO    3 202    898
    CINPUT    3 221    913
      EVAL    3 224    916
     SCAN1    3 254    940
     SCAN2    3 300    960
     SCAN3    3 345    997
    SCANFN    3 351   1001
     SCAN4    3 357   1007
     SCAN5    3 373   1019
     SCAN6    4 007   1031
     SCAN7    4 033   1051
     SCAN8    4 064   1076
     SCAN9    4 100   1088
    SCAN11    4 143   1123
    SCAN12    4 206   1158
    SCAN13    4 251   1193
    SCAN14    4 260   1200
    SCAN15    4 267   1207
    SCAN16    4 276   1214
    SCAN10    4 301   1217
    PARSER    4 324   1236
    PARNUM    4 356   1262
    NOEXPO    5 005   1285
    LOOKUP    5 033   1307
    LOOKU1    5 061   1329
    LOOKU2    5 111   1353
    LOOKU4    5 201   1409
     PARSE    5 231   1433
    PARSE1    5 307   1479
    PARSE2    5 332   1498
    FPOPER    5 364   1524
    PARNER    6 104   1604
        LT    6 121   1617
        EQ    6 136   1630
        GT    6 153   1643
        LE    6 173   1659
        GE    6 213   1675
        NE    6 230   1688
     CTRUE    6 242   1698
     FPONE    6 242   1698
    CFALSE    6 247   1703
     AD4DE    6 256   1710
    INTEXP    6 263   1715
    MULOOP    6 341   1761
    DVLOOP    6 362   1778
    PRIGHT    7 003   1795
    FUNARR    7 100   1856
    FUNAR1    7 115   1869
     FAERR    7 172   1914
    FUNAR4    7 207   1927
    TABADR    7 230   1944
    TABAD1    7 231   1945
      INTX    7 243   1955
      INT1    7 327   2007
      INT2    7 341   2017
      ABSX    7 346   2022
      SGNX    7 360   2032
      CHRX    7 377   2047
      TABX   10 017   2063
      TAB1   10 022   2066
      TABC   10 042   2082
    TABLOP   10 045   2085
    STOSYM   10 055   2093
    STOSY1   10 100   2112
    STOSY2   10 126   2134
    STOSY3   10 156   2158
    STOSY5   10 227   2199
    SAVESY   10 240   2208
    RESTSY   10 252   2218
    MOVECP   10 261   2225
      EXEC   10 266   2230
     EXEC1   10 275   2237
      LIST   10 333   2267
    NOLIST   10 354   2284
    SCRLOP   11 060   2352
     NOSCR   11 071   2361
    SYNERR   11 152   2410
    SYNTOK   11 161   2417
    GETAUX   11 177   2431
    GETAU0   11 211   2441
    GETAU1   11 242   2466
    GETAU2   11 267   2487
    PATCH3   11 307   2503
    NOTEND   11 336   2526
    NOSAME   12 005   2565
     MOVEC   12 046   2598
    MOVEPG   12 050   2600
    CONTIN   12 073   2619
    GETCHP   12 123   2643
    REMOVE   12 144   2660
    REMOV1   12 167   2679
    INSERT   12 205   2693
    INSER1   12 231   2713
    INSER3   12 255   2733
    INCLIN   12 255   2733
    CPHLDE   12 277   2751
     ADBDE   12 305   2757
     CTRLC   12 313   2763
    FINERR   12 322   2770
    FINER1   12 351   2793
     DVERR   12 357   2799
    FIXERR   12 366   2806
    NUMERR   12 375   2813
     INSTR   13 012   2826
    INSTR1   13 016   2830
    INSTR2   13 061   2865
     ADVDE   13 064   2868
       RUN   13 070   2872
    NXTLIN   13 116   2894
    SAMLIN   13 156   2926
    DIRECT   13 211   2953
     PRINT   13 345   3045
    PRINT1   13 366   3062
    PRINT2   14 002   3074
    PRINT3   14 043   3107
    PRINT4   14 075   3133
    PRINT5   14 114   3148
    PRINT6   14 125   3157
     QUOTE   14 203   3203
    QUOTE1   14 220   3216
    QUOTER   14 246   3238
    QUOTE2   14 263   3251
    PFPOUT   14 314   3276
      ZERO   14 336   3294
      FRAC   14 350   3304
    PCOMMA   14 357   3311
     PCOM1   15 003   3331
      LET0   15 013   3339
       LET   15 031   3353
      LET1   15 042   3362
      LET2   15 053   3371
      LET3   15 113   3403
      LET4   15 122   3410
    LETERR   15 132   3418
      LET5   15 141   3425
      GOTO   15 174   3452
     GOTO1   15 211   3465
     GOTO2   15 240   3488
     GOTO3   15 250   3496
     GOTO4   15 261   3505
     GOTO5   15 270   3512
     GOTO6   15 315   3533
     GOTO7   15 340   3552
    GOTOER   16 020   3600
        IF   16 027   3607
     IFERR   16 073   3643
       IF1   16 102   3650
       IF2   16 143   3683
       IF3   16 166   3702
       IF4   16 200   3712
     GOSUB   16 236   3742
    GOSUB1   16 255   3757
    RETURN   16 304   3780
    GOSERR   16 347   3815
    RETERR   16 356   3822
     INPUT   16 365   3829
    INPUT1   16 377   3839
    INPUT2   17 037   3871
    INPUT3   17 042   3874
    INPUT4   17 063   3891
    INPUTX   17 104   3908
    INPUTN   17 140   3936
       FP0   17 157   3951
       FOR   17 164   3956
    FORERR   17 243   4003
      FOR1   17 252   4010
      FOR2   17 266   4022
      FOR3   17 310   4040
      FOR4   17 323   4051
     FPFIX   20 000   4096
    FPFIXL   20 033   4123
    FPZERO   20 051   4137
     FPFLT   20 064   4148
    FPNORM   20 066   4150
    NOEXC0   20 100   4160
    ACZERT   20 120   4176
     LOOK0   20 124   4180
    ACNONZ   20 143   4195
    ACCSET   20 166   4214
    RESIGN   20 175   4221
    FPCOMP   20 202   4226
     FPADD   20 211   4233
     MOVOP   20 222   4242
    NONZAC   20 235   4253
    CKEQEX   20 242   4258
    SKPNEG   20 264   4276
    LINEUP   20 303   4291
    MORACC   20 313   4299
    SHIFT0   20 327   4311
     MOROP   20 330   4312
    SHACOP   20 341   4321
    SHLOOP   20 374   4348
    FSHIFT   21 002   4354
    BRING1   21 007   4359
    MOVEIT   21 013   4363
     FPSUB   21 032   4378
    FPMULT   21 046   4390
    ADDEXP   21 051   4393
    SETMCT   21 062   4402
    MULTIP   21 066   4406
    EXMLDV   21 146   4454
    CKSIGN   21 166   4470
    CLRNEX   21 175   4477
    CLROPL   21 203   4483
    CLRNX1   21 207   4487
    OPSGNT   21 230   4504
    NEGFPA   21 251   4521
    ADOPPP   21 270   4536
    MROUND   21 302   4546
    CROUND   21 307   4551
     FPDIV   21 322   4562
    SUBEXP   21 334   4572
    SETDCT   21 345   4581
    DIVIDE   21 351   4585
      NOGO   21 376   4606
    QUOROT   21 377   4607
    DVEXIT   22 070   4664
    SETSUB   22 101   4673
     ADDER   22 127   4695
    ADDMOR   22 130   4696
    COMPLM   22 150   4712
    MORCOM   22 155   4717
    ROTATL   22 177   4735
      ROTL   22 200   4736
    ROTATR   22 211   4745
      ROTR   22 212   4746
    SUBBER   22 223   4755
    SUBTRA   22 224   4756
     FLOAD   22 244   4772
    FSTORE   22 255   4781
    OPLOAD   22 266   4790
     SETIT   22 272   4794
    FACXOP   22 277   4799
    SAVEHL   22 317   4815
    RESTHL   22 337   4831
    SWITCH   22 356   4846
    GETINP   22 365   4853
      NOT0   23 010   4872
    INDEXC   23 036   4894
    DINPUT   23 044   4900
    CLRNX2   23 055   4909
    CLRNX3   23 067   4919
    NINPUT   23 115   4941
    NOTPLM   23 120   4944
    PERIOD   23 201   4993
    FNDEXP   23 221   5009
    EXPINP   23 241   5025
    NOEXPS   23 244   5028
    ENDINP   23 311   5065
    FININP   23 327   5079
    POSEXP   23 365   5109
     EXPOK   24 000   5120
     FPX10   24 010   5128
    MINEXP   24 033   5147
     FPD10   24 033   5147
    DECBIN   24 056   5166
     FPOUT   24 165   5237
    OUTNEG   24 207   5255
    AHEAD1   24 220   5264
    OUTFLT   24 253   5291
    OUTFIX   24 271   5305
    DECEXT   24 277   5311
    DECREP   24 327   5335
    DECEXD   24 336   5342
    DECOUT   24 360   5360
    COMPEN   25 010   5384
    OUTDIG   25 032   5402
    OUTDGS   25 045   5413
    OUTZER   25 104   5444
    OUTDGX   25 105   5445
    DECRDG   25 112   5450
    PUSHIT   25 131   5465
    CKDECP   25 137   5471
    NODECP   25 154   5484
    ZERODG   25 165   5493
    OUTX10   25 223   5523
    EXPOUT   25 300   5568
    EXOUTN   25 324   5588
    AHEAD2   25 333   5595
     SUB12   25 341   5601
    TOMUCH   25 353   5611
    PATCH1   30 000   6144
      NEXT   30 013   6155
     NEXT1   30 030   6168
     NEXT2   30 045   6181
     NEXT3   30 071   6201
    FORNXT   30 121   6225
     NEXT4   30 130   6232
     NEXT5   30 300   6336
     NEXT6   30 351   6377
     NEXT7   31 005   6405
     NEXT8   31 027   6423
     NEXT9   31 042   6434
    NEXT10   31 143   6499
    NEXT11   31 170   6520
    NEXT12   31 177   6527
    BACKSP   31 217   6543
      FOR5   31 246   6566
    PARSEP   31 300   6592
      SQRX   32 000   6656
    NEGEXP   32 041   6689
    NOREMD   32 057   6703
    SQREXP   32 062   6706
    SQRLOP   32 107   6727
      SQR1   32 166   6774
    SQRCNV   32 203   6787
    SQRERR   32 217   6799
      RNDX   32 240   6816
    PATCH2   32 364   6900
    PRIGH1   55 000  11520
    FUNAR2   55 054  11564
    FUNAR3   55 124  11604
    OUTRNG   55 136  11614
     ARRAY   55 145  11621
    ARRAY1   55 153  11627
    ARRAY2   55 160  11632
    ARRAY3   55 162  11634
    ARRAY4   55 174  11644
    ARRAY5   55 225  11669
    ARRAY6   55 240  11680
    ARRAY7   55 312  11722
       DIM   55 365  11765
      DIM1   55 377  11775
      DIM2   56 017  11791
      DIM3   56 032  11802
      DIM4   56 036  11806
      DIM5   56 157  11887
      DIM6   56 211  11913
      DIM7   56 224  11924
      DIM8   56 271  11961
      DIM9   56 301  11969
     DIM10   56 326  11990
    DIMERR   56 337  11999
